// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/davidroman0O/tempolite/internal/persistence/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/activitydata"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/activityexecution"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/activityexecutiondata"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/entity"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/execution"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/hierarchy"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/queue"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/run"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/sagadata"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/sagaexecution"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/sagaexecutiondata"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/sideeffectdata"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/sideeffectexecution"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/sideeffectexecutiondata"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/version"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/workflowdata"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/workflowexecution"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/workflowexecutiondata"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// ActivityData is the client for interacting with the ActivityData builders.
	ActivityData *ActivityDataClient
	// ActivityExecution is the client for interacting with the ActivityExecution builders.
	ActivityExecution *ActivityExecutionClient
	// ActivityExecutionData is the client for interacting with the ActivityExecutionData builders.
	ActivityExecutionData *ActivityExecutionDataClient
	// Entity is the client for interacting with the Entity builders.
	Entity *EntityClient
	// Execution is the client for interacting with the Execution builders.
	Execution *ExecutionClient
	// Hierarchy is the client for interacting with the Hierarchy builders.
	Hierarchy *HierarchyClient
	// Queue is the client for interacting with the Queue builders.
	Queue *QueueClient
	// Run is the client for interacting with the Run builders.
	Run *RunClient
	// SagaData is the client for interacting with the SagaData builders.
	SagaData *SagaDataClient
	// SagaExecution is the client for interacting with the SagaExecution builders.
	SagaExecution *SagaExecutionClient
	// SagaExecutionData is the client for interacting with the SagaExecutionData builders.
	SagaExecutionData *SagaExecutionDataClient
	// SideEffectData is the client for interacting with the SideEffectData builders.
	SideEffectData *SideEffectDataClient
	// SideEffectExecution is the client for interacting with the SideEffectExecution builders.
	SideEffectExecution *SideEffectExecutionClient
	// SideEffectExecutionData is the client for interacting with the SideEffectExecutionData builders.
	SideEffectExecutionData *SideEffectExecutionDataClient
	// Version is the client for interacting with the Version builders.
	Version *VersionClient
	// WorkflowData is the client for interacting with the WorkflowData builders.
	WorkflowData *WorkflowDataClient
	// WorkflowExecution is the client for interacting with the WorkflowExecution builders.
	WorkflowExecution *WorkflowExecutionClient
	// WorkflowExecutionData is the client for interacting with the WorkflowExecutionData builders.
	WorkflowExecutionData *WorkflowExecutionDataClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.ActivityData = NewActivityDataClient(c.config)
	c.ActivityExecution = NewActivityExecutionClient(c.config)
	c.ActivityExecutionData = NewActivityExecutionDataClient(c.config)
	c.Entity = NewEntityClient(c.config)
	c.Execution = NewExecutionClient(c.config)
	c.Hierarchy = NewHierarchyClient(c.config)
	c.Queue = NewQueueClient(c.config)
	c.Run = NewRunClient(c.config)
	c.SagaData = NewSagaDataClient(c.config)
	c.SagaExecution = NewSagaExecutionClient(c.config)
	c.SagaExecutionData = NewSagaExecutionDataClient(c.config)
	c.SideEffectData = NewSideEffectDataClient(c.config)
	c.SideEffectExecution = NewSideEffectExecutionClient(c.config)
	c.SideEffectExecutionData = NewSideEffectExecutionDataClient(c.config)
	c.Version = NewVersionClient(c.config)
	c.WorkflowData = NewWorkflowDataClient(c.config)
	c.WorkflowExecution = NewWorkflowExecutionClient(c.config)
	c.WorkflowExecutionData = NewWorkflowExecutionDataClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                     ctx,
		config:                  cfg,
		ActivityData:            NewActivityDataClient(cfg),
		ActivityExecution:       NewActivityExecutionClient(cfg),
		ActivityExecutionData:   NewActivityExecutionDataClient(cfg),
		Entity:                  NewEntityClient(cfg),
		Execution:               NewExecutionClient(cfg),
		Hierarchy:               NewHierarchyClient(cfg),
		Queue:                   NewQueueClient(cfg),
		Run:                     NewRunClient(cfg),
		SagaData:                NewSagaDataClient(cfg),
		SagaExecution:           NewSagaExecutionClient(cfg),
		SagaExecutionData:       NewSagaExecutionDataClient(cfg),
		SideEffectData:          NewSideEffectDataClient(cfg),
		SideEffectExecution:     NewSideEffectExecutionClient(cfg),
		SideEffectExecutionData: NewSideEffectExecutionDataClient(cfg),
		Version:                 NewVersionClient(cfg),
		WorkflowData:            NewWorkflowDataClient(cfg),
		WorkflowExecution:       NewWorkflowExecutionClient(cfg),
		WorkflowExecutionData:   NewWorkflowExecutionDataClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                     ctx,
		config:                  cfg,
		ActivityData:            NewActivityDataClient(cfg),
		ActivityExecution:       NewActivityExecutionClient(cfg),
		ActivityExecutionData:   NewActivityExecutionDataClient(cfg),
		Entity:                  NewEntityClient(cfg),
		Execution:               NewExecutionClient(cfg),
		Hierarchy:               NewHierarchyClient(cfg),
		Queue:                   NewQueueClient(cfg),
		Run:                     NewRunClient(cfg),
		SagaData:                NewSagaDataClient(cfg),
		SagaExecution:           NewSagaExecutionClient(cfg),
		SagaExecutionData:       NewSagaExecutionDataClient(cfg),
		SideEffectData:          NewSideEffectDataClient(cfg),
		SideEffectExecution:     NewSideEffectExecutionClient(cfg),
		SideEffectExecutionData: NewSideEffectExecutionDataClient(cfg),
		Version:                 NewVersionClient(cfg),
		WorkflowData:            NewWorkflowDataClient(cfg),
		WorkflowExecution:       NewWorkflowExecutionClient(cfg),
		WorkflowExecutionData:   NewWorkflowExecutionDataClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		ActivityData.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.ActivityData, c.ActivityExecution, c.ActivityExecutionData, c.Entity,
		c.Execution, c.Hierarchy, c.Queue, c.Run, c.SagaData, c.SagaExecution,
		c.SagaExecutionData, c.SideEffectData, c.SideEffectExecution,
		c.SideEffectExecutionData, c.Version, c.WorkflowData, c.WorkflowExecution,
		c.WorkflowExecutionData,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.ActivityData, c.ActivityExecution, c.ActivityExecutionData, c.Entity,
		c.Execution, c.Hierarchy, c.Queue, c.Run, c.SagaData, c.SagaExecution,
		c.SagaExecutionData, c.SideEffectData, c.SideEffectExecution,
		c.SideEffectExecutionData, c.Version, c.WorkflowData, c.WorkflowExecution,
		c.WorkflowExecutionData,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *ActivityDataMutation:
		return c.ActivityData.mutate(ctx, m)
	case *ActivityExecutionMutation:
		return c.ActivityExecution.mutate(ctx, m)
	case *ActivityExecutionDataMutation:
		return c.ActivityExecutionData.mutate(ctx, m)
	case *EntityMutation:
		return c.Entity.mutate(ctx, m)
	case *ExecutionMutation:
		return c.Execution.mutate(ctx, m)
	case *HierarchyMutation:
		return c.Hierarchy.mutate(ctx, m)
	case *QueueMutation:
		return c.Queue.mutate(ctx, m)
	case *RunMutation:
		return c.Run.mutate(ctx, m)
	case *SagaDataMutation:
		return c.SagaData.mutate(ctx, m)
	case *SagaExecutionMutation:
		return c.SagaExecution.mutate(ctx, m)
	case *SagaExecutionDataMutation:
		return c.SagaExecutionData.mutate(ctx, m)
	case *SideEffectDataMutation:
		return c.SideEffectData.mutate(ctx, m)
	case *SideEffectExecutionMutation:
		return c.SideEffectExecution.mutate(ctx, m)
	case *SideEffectExecutionDataMutation:
		return c.SideEffectExecutionData.mutate(ctx, m)
	case *VersionMutation:
		return c.Version.mutate(ctx, m)
	case *WorkflowDataMutation:
		return c.WorkflowData.mutate(ctx, m)
	case *WorkflowExecutionMutation:
		return c.WorkflowExecution.mutate(ctx, m)
	case *WorkflowExecutionDataMutation:
		return c.WorkflowExecutionData.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// ActivityDataClient is a client for the ActivityData schema.
type ActivityDataClient struct {
	config
}

// NewActivityDataClient returns a client for the ActivityData from the given config.
func NewActivityDataClient(c config) *ActivityDataClient {
	return &ActivityDataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `activitydata.Hooks(f(g(h())))`.
func (c *ActivityDataClient) Use(hooks ...Hook) {
	c.hooks.ActivityData = append(c.hooks.ActivityData, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `activitydata.Intercept(f(g(h())))`.
func (c *ActivityDataClient) Intercept(interceptors ...Interceptor) {
	c.inters.ActivityData = append(c.inters.ActivityData, interceptors...)
}

// Create returns a builder for creating a ActivityData entity.
func (c *ActivityDataClient) Create() *ActivityDataCreate {
	mutation := newActivityDataMutation(c.config, OpCreate)
	return &ActivityDataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ActivityData entities.
func (c *ActivityDataClient) CreateBulk(builders ...*ActivityDataCreate) *ActivityDataCreateBulk {
	return &ActivityDataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ActivityDataClient) MapCreateBulk(slice any, setFunc func(*ActivityDataCreate, int)) *ActivityDataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ActivityDataCreateBulk{err: fmt.Errorf("calling to ActivityDataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ActivityDataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ActivityDataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ActivityData.
func (c *ActivityDataClient) Update() *ActivityDataUpdate {
	mutation := newActivityDataMutation(c.config, OpUpdate)
	return &ActivityDataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ActivityDataClient) UpdateOne(ad *ActivityData) *ActivityDataUpdateOne {
	mutation := newActivityDataMutation(c.config, OpUpdateOne, withActivityData(ad))
	return &ActivityDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ActivityDataClient) UpdateOneID(id int) *ActivityDataUpdateOne {
	mutation := newActivityDataMutation(c.config, OpUpdateOne, withActivityDataID(id))
	return &ActivityDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ActivityData.
func (c *ActivityDataClient) Delete() *ActivityDataDelete {
	mutation := newActivityDataMutation(c.config, OpDelete)
	return &ActivityDataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ActivityDataClient) DeleteOne(ad *ActivityData) *ActivityDataDeleteOne {
	return c.DeleteOneID(ad.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ActivityDataClient) DeleteOneID(id int) *ActivityDataDeleteOne {
	builder := c.Delete().Where(activitydata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ActivityDataDeleteOne{builder}
}

// Query returns a query builder for ActivityData.
func (c *ActivityDataClient) Query() *ActivityDataQuery {
	return &ActivityDataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeActivityData},
		inters: c.Interceptors(),
	}
}

// Get returns a ActivityData entity by its id.
func (c *ActivityDataClient) Get(ctx context.Context, id int) (*ActivityData, error) {
	return c.Query().Where(activitydata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ActivityDataClient) GetX(ctx context.Context, id int) *ActivityData {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEntity queries the entity edge of a ActivityData.
func (c *ActivityDataClient) QueryEntity(ad *ActivityData) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ad.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(activitydata.Table, activitydata.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, activitydata.EntityTable, activitydata.EntityColumn),
		)
		fromV = sqlgraph.Neighbors(ad.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ActivityDataClient) Hooks() []Hook {
	return c.hooks.ActivityData
}

// Interceptors returns the client interceptors.
func (c *ActivityDataClient) Interceptors() []Interceptor {
	return c.inters.ActivityData
}

func (c *ActivityDataClient) mutate(ctx context.Context, m *ActivityDataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ActivityDataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ActivityDataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ActivityDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ActivityDataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ActivityData mutation op: %q", m.Op())
	}
}

// ActivityExecutionClient is a client for the ActivityExecution schema.
type ActivityExecutionClient struct {
	config
}

// NewActivityExecutionClient returns a client for the ActivityExecution from the given config.
func NewActivityExecutionClient(c config) *ActivityExecutionClient {
	return &ActivityExecutionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `activityexecution.Hooks(f(g(h())))`.
func (c *ActivityExecutionClient) Use(hooks ...Hook) {
	c.hooks.ActivityExecution = append(c.hooks.ActivityExecution, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `activityexecution.Intercept(f(g(h())))`.
func (c *ActivityExecutionClient) Intercept(interceptors ...Interceptor) {
	c.inters.ActivityExecution = append(c.inters.ActivityExecution, interceptors...)
}

// Create returns a builder for creating a ActivityExecution entity.
func (c *ActivityExecutionClient) Create() *ActivityExecutionCreate {
	mutation := newActivityExecutionMutation(c.config, OpCreate)
	return &ActivityExecutionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ActivityExecution entities.
func (c *ActivityExecutionClient) CreateBulk(builders ...*ActivityExecutionCreate) *ActivityExecutionCreateBulk {
	return &ActivityExecutionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ActivityExecutionClient) MapCreateBulk(slice any, setFunc func(*ActivityExecutionCreate, int)) *ActivityExecutionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ActivityExecutionCreateBulk{err: fmt.Errorf("calling to ActivityExecutionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ActivityExecutionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ActivityExecutionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ActivityExecution.
func (c *ActivityExecutionClient) Update() *ActivityExecutionUpdate {
	mutation := newActivityExecutionMutation(c.config, OpUpdate)
	return &ActivityExecutionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ActivityExecutionClient) UpdateOne(ae *ActivityExecution) *ActivityExecutionUpdateOne {
	mutation := newActivityExecutionMutation(c.config, OpUpdateOne, withActivityExecution(ae))
	return &ActivityExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ActivityExecutionClient) UpdateOneID(id int) *ActivityExecutionUpdateOne {
	mutation := newActivityExecutionMutation(c.config, OpUpdateOne, withActivityExecutionID(id))
	return &ActivityExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ActivityExecution.
func (c *ActivityExecutionClient) Delete() *ActivityExecutionDelete {
	mutation := newActivityExecutionMutation(c.config, OpDelete)
	return &ActivityExecutionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ActivityExecutionClient) DeleteOne(ae *ActivityExecution) *ActivityExecutionDeleteOne {
	return c.DeleteOneID(ae.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ActivityExecutionClient) DeleteOneID(id int) *ActivityExecutionDeleteOne {
	builder := c.Delete().Where(activityexecution.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ActivityExecutionDeleteOne{builder}
}

// Query returns a query builder for ActivityExecution.
func (c *ActivityExecutionClient) Query() *ActivityExecutionQuery {
	return &ActivityExecutionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeActivityExecution},
		inters: c.Interceptors(),
	}
}

// Get returns a ActivityExecution entity by its id.
func (c *ActivityExecutionClient) Get(ctx context.Context, id int) (*ActivityExecution, error) {
	return c.Query().Where(activityexecution.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ActivityExecutionClient) GetX(ctx context.Context, id int) *ActivityExecution {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryExecution queries the execution edge of a ActivityExecution.
func (c *ActivityExecutionClient) QueryExecution(ae *ActivityExecution) *ExecutionQuery {
	query := (&ExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ae.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(activityexecution.Table, activityexecution.FieldID, id),
			sqlgraph.To(execution.Table, execution.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, activityexecution.ExecutionTable, activityexecution.ExecutionColumn),
		)
		fromV = sqlgraph.Neighbors(ae.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExecutionData queries the execution_data edge of a ActivityExecution.
func (c *ActivityExecutionClient) QueryExecutionData(ae *ActivityExecution) *ActivityExecutionDataQuery {
	query := (&ActivityExecutionDataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ae.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(activityexecution.Table, activityexecution.FieldID, id),
			sqlgraph.To(activityexecutiondata.Table, activityexecutiondata.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, activityexecution.ExecutionDataTable, activityexecution.ExecutionDataColumn),
		)
		fromV = sqlgraph.Neighbors(ae.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ActivityExecutionClient) Hooks() []Hook {
	return c.hooks.ActivityExecution
}

// Interceptors returns the client interceptors.
func (c *ActivityExecutionClient) Interceptors() []Interceptor {
	return c.inters.ActivityExecution
}

func (c *ActivityExecutionClient) mutate(ctx context.Context, m *ActivityExecutionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ActivityExecutionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ActivityExecutionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ActivityExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ActivityExecutionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ActivityExecution mutation op: %q", m.Op())
	}
}

// ActivityExecutionDataClient is a client for the ActivityExecutionData schema.
type ActivityExecutionDataClient struct {
	config
}

// NewActivityExecutionDataClient returns a client for the ActivityExecutionData from the given config.
func NewActivityExecutionDataClient(c config) *ActivityExecutionDataClient {
	return &ActivityExecutionDataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `activityexecutiondata.Hooks(f(g(h())))`.
func (c *ActivityExecutionDataClient) Use(hooks ...Hook) {
	c.hooks.ActivityExecutionData = append(c.hooks.ActivityExecutionData, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `activityexecutiondata.Intercept(f(g(h())))`.
func (c *ActivityExecutionDataClient) Intercept(interceptors ...Interceptor) {
	c.inters.ActivityExecutionData = append(c.inters.ActivityExecutionData, interceptors...)
}

// Create returns a builder for creating a ActivityExecutionData entity.
func (c *ActivityExecutionDataClient) Create() *ActivityExecutionDataCreate {
	mutation := newActivityExecutionDataMutation(c.config, OpCreate)
	return &ActivityExecutionDataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ActivityExecutionData entities.
func (c *ActivityExecutionDataClient) CreateBulk(builders ...*ActivityExecutionDataCreate) *ActivityExecutionDataCreateBulk {
	return &ActivityExecutionDataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ActivityExecutionDataClient) MapCreateBulk(slice any, setFunc func(*ActivityExecutionDataCreate, int)) *ActivityExecutionDataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ActivityExecutionDataCreateBulk{err: fmt.Errorf("calling to ActivityExecutionDataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ActivityExecutionDataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ActivityExecutionDataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ActivityExecutionData.
func (c *ActivityExecutionDataClient) Update() *ActivityExecutionDataUpdate {
	mutation := newActivityExecutionDataMutation(c.config, OpUpdate)
	return &ActivityExecutionDataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ActivityExecutionDataClient) UpdateOne(aed *ActivityExecutionData) *ActivityExecutionDataUpdateOne {
	mutation := newActivityExecutionDataMutation(c.config, OpUpdateOne, withActivityExecutionData(aed))
	return &ActivityExecutionDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ActivityExecutionDataClient) UpdateOneID(id int) *ActivityExecutionDataUpdateOne {
	mutation := newActivityExecutionDataMutation(c.config, OpUpdateOne, withActivityExecutionDataID(id))
	return &ActivityExecutionDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ActivityExecutionData.
func (c *ActivityExecutionDataClient) Delete() *ActivityExecutionDataDelete {
	mutation := newActivityExecutionDataMutation(c.config, OpDelete)
	return &ActivityExecutionDataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ActivityExecutionDataClient) DeleteOne(aed *ActivityExecutionData) *ActivityExecutionDataDeleteOne {
	return c.DeleteOneID(aed.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ActivityExecutionDataClient) DeleteOneID(id int) *ActivityExecutionDataDeleteOne {
	builder := c.Delete().Where(activityexecutiondata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ActivityExecutionDataDeleteOne{builder}
}

// Query returns a query builder for ActivityExecutionData.
func (c *ActivityExecutionDataClient) Query() *ActivityExecutionDataQuery {
	return &ActivityExecutionDataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeActivityExecutionData},
		inters: c.Interceptors(),
	}
}

// Get returns a ActivityExecutionData entity by its id.
func (c *ActivityExecutionDataClient) Get(ctx context.Context, id int) (*ActivityExecutionData, error) {
	return c.Query().Where(activityexecutiondata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ActivityExecutionDataClient) GetX(ctx context.Context, id int) *ActivityExecutionData {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryActivityExecution queries the activity_execution edge of a ActivityExecutionData.
func (c *ActivityExecutionDataClient) QueryActivityExecution(aed *ActivityExecutionData) *ActivityExecutionQuery {
	query := (&ActivityExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := aed.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(activityexecutiondata.Table, activityexecutiondata.FieldID, id),
			sqlgraph.To(activityexecution.Table, activityexecution.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, activityexecutiondata.ActivityExecutionTable, activityexecutiondata.ActivityExecutionColumn),
		)
		fromV = sqlgraph.Neighbors(aed.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ActivityExecutionDataClient) Hooks() []Hook {
	return c.hooks.ActivityExecutionData
}

// Interceptors returns the client interceptors.
func (c *ActivityExecutionDataClient) Interceptors() []Interceptor {
	return c.inters.ActivityExecutionData
}

func (c *ActivityExecutionDataClient) mutate(ctx context.Context, m *ActivityExecutionDataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ActivityExecutionDataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ActivityExecutionDataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ActivityExecutionDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ActivityExecutionDataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ActivityExecutionData mutation op: %q", m.Op())
	}
}

// EntityClient is a client for the Entity schema.
type EntityClient struct {
	config
}

// NewEntityClient returns a client for the Entity from the given config.
func NewEntityClient(c config) *EntityClient {
	return &EntityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `entity.Hooks(f(g(h())))`.
func (c *EntityClient) Use(hooks ...Hook) {
	c.hooks.Entity = append(c.hooks.Entity, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `entity.Intercept(f(g(h())))`.
func (c *EntityClient) Intercept(interceptors ...Interceptor) {
	c.inters.Entity = append(c.inters.Entity, interceptors...)
}

// Create returns a builder for creating a Entity entity.
func (c *EntityClient) Create() *EntityCreate {
	mutation := newEntityMutation(c.config, OpCreate)
	return &EntityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Entity entities.
func (c *EntityClient) CreateBulk(builders ...*EntityCreate) *EntityCreateBulk {
	return &EntityCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EntityClient) MapCreateBulk(slice any, setFunc func(*EntityCreate, int)) *EntityCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EntityCreateBulk{err: fmt.Errorf("calling to EntityClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EntityCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EntityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Entity.
func (c *EntityClient) Update() *EntityUpdate {
	mutation := newEntityMutation(c.config, OpUpdate)
	return &EntityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EntityClient) UpdateOne(e *Entity) *EntityUpdateOne {
	mutation := newEntityMutation(c.config, OpUpdateOne, withEntity(e))
	return &EntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EntityClient) UpdateOneID(id int) *EntityUpdateOne {
	mutation := newEntityMutation(c.config, OpUpdateOne, withEntityID(id))
	return &EntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Entity.
func (c *EntityClient) Delete() *EntityDelete {
	mutation := newEntityMutation(c.config, OpDelete)
	return &EntityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EntityClient) DeleteOne(e *Entity) *EntityDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EntityClient) DeleteOneID(id int) *EntityDeleteOne {
	builder := c.Delete().Where(entity.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EntityDeleteOne{builder}
}

// Query returns a query builder for Entity.
func (c *EntityClient) Query() *EntityQuery {
	return &EntityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEntity},
		inters: c.Interceptors(),
	}
}

// Get returns a Entity entity by its id.
func (c *EntityClient) Get(ctx context.Context, id int) (*Entity, error) {
	return c.Query().Where(entity.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EntityClient) GetX(ctx context.Context, id int) *Entity {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRun queries the run edge of a Entity.
func (c *EntityClient) QueryRun(e *Entity) *RunQuery {
	query := (&RunClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entity.Table, entity.FieldID, id),
			sqlgraph.To(run.Table, run.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, entity.RunTable, entity.RunColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExecutions queries the executions edge of a Entity.
func (c *EntityClient) QueryExecutions(e *Entity) *ExecutionQuery {
	query := (&ExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entity.Table, entity.FieldID, id),
			sqlgraph.To(execution.Table, execution.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, entity.ExecutionsTable, entity.ExecutionsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQueue queries the queue edge of a Entity.
func (c *EntityClient) QueryQueue(e *Entity) *QueueQuery {
	query := (&QueueClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entity.Table, entity.FieldID, id),
			sqlgraph.To(queue.Table, queue.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, entity.QueueTable, entity.QueueColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVersions queries the versions edge of a Entity.
func (c *EntityClient) QueryVersions(e *Entity) *VersionQuery {
	query := (&VersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entity.Table, entity.FieldID, id),
			sqlgraph.To(version.Table, version.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, entity.VersionsTable, entity.VersionsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkflowData queries the workflow_data edge of a Entity.
func (c *EntityClient) QueryWorkflowData(e *Entity) *WorkflowDataQuery {
	query := (&WorkflowDataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entity.Table, entity.FieldID, id),
			sqlgraph.To(workflowdata.Table, workflowdata.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, entity.WorkflowDataTable, entity.WorkflowDataColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActivityData queries the activity_data edge of a Entity.
func (c *EntityClient) QueryActivityData(e *Entity) *ActivityDataQuery {
	query := (&ActivityDataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entity.Table, entity.FieldID, id),
			sqlgraph.To(activitydata.Table, activitydata.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, entity.ActivityDataTable, entity.ActivityDataColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySagaData queries the saga_data edge of a Entity.
func (c *EntityClient) QuerySagaData(e *Entity) *SagaDataQuery {
	query := (&SagaDataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entity.Table, entity.FieldID, id),
			sqlgraph.To(sagadata.Table, sagadata.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, entity.SagaDataTable, entity.SagaDataColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySideEffectData queries the side_effect_data edge of a Entity.
func (c *EntityClient) QuerySideEffectData(e *Entity) *SideEffectDataQuery {
	query := (&SideEffectDataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entity.Table, entity.FieldID, id),
			sqlgraph.To(sideeffectdata.Table, sideeffectdata.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, entity.SideEffectDataTable, entity.SideEffectDataColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EntityClient) Hooks() []Hook {
	return c.hooks.Entity
}

// Interceptors returns the client interceptors.
func (c *EntityClient) Interceptors() []Interceptor {
	return c.inters.Entity
}

func (c *EntityClient) mutate(ctx context.Context, m *EntityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EntityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EntityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EntityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Entity mutation op: %q", m.Op())
	}
}

// ExecutionClient is a client for the Execution schema.
type ExecutionClient struct {
	config
}

// NewExecutionClient returns a client for the Execution from the given config.
func NewExecutionClient(c config) *ExecutionClient {
	return &ExecutionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `execution.Hooks(f(g(h())))`.
func (c *ExecutionClient) Use(hooks ...Hook) {
	c.hooks.Execution = append(c.hooks.Execution, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `execution.Intercept(f(g(h())))`.
func (c *ExecutionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Execution = append(c.inters.Execution, interceptors...)
}

// Create returns a builder for creating a Execution entity.
func (c *ExecutionClient) Create() *ExecutionCreate {
	mutation := newExecutionMutation(c.config, OpCreate)
	return &ExecutionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Execution entities.
func (c *ExecutionClient) CreateBulk(builders ...*ExecutionCreate) *ExecutionCreateBulk {
	return &ExecutionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ExecutionClient) MapCreateBulk(slice any, setFunc func(*ExecutionCreate, int)) *ExecutionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ExecutionCreateBulk{err: fmt.Errorf("calling to ExecutionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ExecutionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ExecutionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Execution.
func (c *ExecutionClient) Update() *ExecutionUpdate {
	mutation := newExecutionMutation(c.config, OpUpdate)
	return &ExecutionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ExecutionClient) UpdateOne(e *Execution) *ExecutionUpdateOne {
	mutation := newExecutionMutation(c.config, OpUpdateOne, withExecution(e))
	return &ExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ExecutionClient) UpdateOneID(id int) *ExecutionUpdateOne {
	mutation := newExecutionMutation(c.config, OpUpdateOne, withExecutionID(id))
	return &ExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Execution.
func (c *ExecutionClient) Delete() *ExecutionDelete {
	mutation := newExecutionMutation(c.config, OpDelete)
	return &ExecutionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ExecutionClient) DeleteOne(e *Execution) *ExecutionDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ExecutionClient) DeleteOneID(id int) *ExecutionDeleteOne {
	builder := c.Delete().Where(execution.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ExecutionDeleteOne{builder}
}

// Query returns a query builder for Execution.
func (c *ExecutionClient) Query() *ExecutionQuery {
	return &ExecutionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeExecution},
		inters: c.Interceptors(),
	}
}

// Get returns a Execution entity by its id.
func (c *ExecutionClient) Get(ctx context.Context, id int) (*Execution, error) {
	return c.Query().Where(execution.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ExecutionClient) GetX(ctx context.Context, id int) *Execution {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEntity queries the entity edge of a Execution.
func (c *ExecutionClient) QueryEntity(e *Execution) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(execution.Table, execution.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, execution.EntityTable, execution.EntityColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkflowExecution queries the workflow_execution edge of a Execution.
func (c *ExecutionClient) QueryWorkflowExecution(e *Execution) *WorkflowExecutionQuery {
	query := (&WorkflowExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(execution.Table, execution.FieldID, id),
			sqlgraph.To(workflowexecution.Table, workflowexecution.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, execution.WorkflowExecutionTable, execution.WorkflowExecutionColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActivityExecution queries the activity_execution edge of a Execution.
func (c *ExecutionClient) QueryActivityExecution(e *Execution) *ActivityExecutionQuery {
	query := (&ActivityExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(execution.Table, execution.FieldID, id),
			sqlgraph.To(activityexecution.Table, activityexecution.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, execution.ActivityExecutionTable, execution.ActivityExecutionColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySagaExecution queries the saga_execution edge of a Execution.
func (c *ExecutionClient) QuerySagaExecution(e *Execution) *SagaExecutionQuery {
	query := (&SagaExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(execution.Table, execution.FieldID, id),
			sqlgraph.To(sagaexecution.Table, sagaexecution.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, execution.SagaExecutionTable, execution.SagaExecutionColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySideEffectExecution queries the side_effect_execution edge of a Execution.
func (c *ExecutionClient) QuerySideEffectExecution(e *Execution) *SideEffectExecutionQuery {
	query := (&SideEffectExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(execution.Table, execution.FieldID, id),
			sqlgraph.To(sideeffectexecution.Table, sideeffectexecution.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, execution.SideEffectExecutionTable, execution.SideEffectExecutionColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ExecutionClient) Hooks() []Hook {
	return c.hooks.Execution
}

// Interceptors returns the client interceptors.
func (c *ExecutionClient) Interceptors() []Interceptor {
	return c.inters.Execution
}

func (c *ExecutionClient) mutate(ctx context.Context, m *ExecutionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ExecutionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ExecutionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ExecutionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Execution mutation op: %q", m.Op())
	}
}

// HierarchyClient is a client for the Hierarchy schema.
type HierarchyClient struct {
	config
}

// NewHierarchyClient returns a client for the Hierarchy from the given config.
func NewHierarchyClient(c config) *HierarchyClient {
	return &HierarchyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `hierarchy.Hooks(f(g(h())))`.
func (c *HierarchyClient) Use(hooks ...Hook) {
	c.hooks.Hierarchy = append(c.hooks.Hierarchy, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `hierarchy.Intercept(f(g(h())))`.
func (c *HierarchyClient) Intercept(interceptors ...Interceptor) {
	c.inters.Hierarchy = append(c.inters.Hierarchy, interceptors...)
}

// Create returns a builder for creating a Hierarchy entity.
func (c *HierarchyClient) Create() *HierarchyCreate {
	mutation := newHierarchyMutation(c.config, OpCreate)
	return &HierarchyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Hierarchy entities.
func (c *HierarchyClient) CreateBulk(builders ...*HierarchyCreate) *HierarchyCreateBulk {
	return &HierarchyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *HierarchyClient) MapCreateBulk(slice any, setFunc func(*HierarchyCreate, int)) *HierarchyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &HierarchyCreateBulk{err: fmt.Errorf("calling to HierarchyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*HierarchyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &HierarchyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Hierarchy.
func (c *HierarchyClient) Update() *HierarchyUpdate {
	mutation := newHierarchyMutation(c.config, OpUpdate)
	return &HierarchyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HierarchyClient) UpdateOne(h *Hierarchy) *HierarchyUpdateOne {
	mutation := newHierarchyMutation(c.config, OpUpdateOne, withHierarchy(h))
	return &HierarchyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HierarchyClient) UpdateOneID(id int) *HierarchyUpdateOne {
	mutation := newHierarchyMutation(c.config, OpUpdateOne, withHierarchyID(id))
	return &HierarchyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Hierarchy.
func (c *HierarchyClient) Delete() *HierarchyDelete {
	mutation := newHierarchyMutation(c.config, OpDelete)
	return &HierarchyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HierarchyClient) DeleteOne(h *Hierarchy) *HierarchyDeleteOne {
	return c.DeleteOneID(h.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HierarchyClient) DeleteOneID(id int) *HierarchyDeleteOne {
	builder := c.Delete().Where(hierarchy.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HierarchyDeleteOne{builder}
}

// Query returns a query builder for Hierarchy.
func (c *HierarchyClient) Query() *HierarchyQuery {
	return &HierarchyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeHierarchy},
		inters: c.Interceptors(),
	}
}

// Get returns a Hierarchy entity by its id.
func (c *HierarchyClient) Get(ctx context.Context, id int) (*Hierarchy, error) {
	return c.Query().Where(hierarchy.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HierarchyClient) GetX(ctx context.Context, id int) *Hierarchy {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRun queries the run edge of a Hierarchy.
func (c *HierarchyClient) QueryRun(h *Hierarchy) *RunQuery {
	query := (&RunClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := h.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hierarchy.Table, hierarchy.FieldID, id),
			sqlgraph.To(run.Table, run.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, hierarchy.RunTable, hierarchy.RunColumn),
		)
		fromV = sqlgraph.Neighbors(h.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParentEntity queries the parent_entity edge of a Hierarchy.
func (c *HierarchyClient) QueryParentEntity(h *Hierarchy) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := h.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hierarchy.Table, hierarchy.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, hierarchy.ParentEntityTable, hierarchy.ParentEntityColumn),
		)
		fromV = sqlgraph.Neighbors(h.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildEntity queries the child_entity edge of a Hierarchy.
func (c *HierarchyClient) QueryChildEntity(h *Hierarchy) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := h.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hierarchy.Table, hierarchy.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, hierarchy.ChildEntityTable, hierarchy.ChildEntityColumn),
		)
		fromV = sqlgraph.Neighbors(h.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *HierarchyClient) Hooks() []Hook {
	return c.hooks.Hierarchy
}

// Interceptors returns the client interceptors.
func (c *HierarchyClient) Interceptors() []Interceptor {
	return c.inters.Hierarchy
}

func (c *HierarchyClient) mutate(ctx context.Context, m *HierarchyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&HierarchyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&HierarchyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&HierarchyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&HierarchyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Hierarchy mutation op: %q", m.Op())
	}
}

// QueueClient is a client for the Queue schema.
type QueueClient struct {
	config
}

// NewQueueClient returns a client for the Queue from the given config.
func NewQueueClient(c config) *QueueClient {
	return &QueueClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `queue.Hooks(f(g(h())))`.
func (c *QueueClient) Use(hooks ...Hook) {
	c.hooks.Queue = append(c.hooks.Queue, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `queue.Intercept(f(g(h())))`.
func (c *QueueClient) Intercept(interceptors ...Interceptor) {
	c.inters.Queue = append(c.inters.Queue, interceptors...)
}

// Create returns a builder for creating a Queue entity.
func (c *QueueClient) Create() *QueueCreate {
	mutation := newQueueMutation(c.config, OpCreate)
	return &QueueCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Queue entities.
func (c *QueueClient) CreateBulk(builders ...*QueueCreate) *QueueCreateBulk {
	return &QueueCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *QueueClient) MapCreateBulk(slice any, setFunc func(*QueueCreate, int)) *QueueCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &QueueCreateBulk{err: fmt.Errorf("calling to QueueClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*QueueCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &QueueCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Queue.
func (c *QueueClient) Update() *QueueUpdate {
	mutation := newQueueMutation(c.config, OpUpdate)
	return &QueueUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *QueueClient) UpdateOne(q *Queue) *QueueUpdateOne {
	mutation := newQueueMutation(c.config, OpUpdateOne, withQueue(q))
	return &QueueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *QueueClient) UpdateOneID(id int) *QueueUpdateOne {
	mutation := newQueueMutation(c.config, OpUpdateOne, withQueueID(id))
	return &QueueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Queue.
func (c *QueueClient) Delete() *QueueDelete {
	mutation := newQueueMutation(c.config, OpDelete)
	return &QueueDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *QueueClient) DeleteOne(q *Queue) *QueueDeleteOne {
	return c.DeleteOneID(q.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *QueueClient) DeleteOneID(id int) *QueueDeleteOne {
	builder := c.Delete().Where(queue.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &QueueDeleteOne{builder}
}

// Query returns a query builder for Queue.
func (c *QueueClient) Query() *QueueQuery {
	return &QueueQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeQueue},
		inters: c.Interceptors(),
	}
}

// Get returns a Queue entity by its id.
func (c *QueueClient) Get(ctx context.Context, id int) (*Queue, error) {
	return c.Query().Where(queue.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *QueueClient) GetX(ctx context.Context, id int) *Queue {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEntities queries the entities edge of a Queue.
func (c *QueueClient) QueryEntities(q *Queue) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := q.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(queue.Table, queue.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, queue.EntitiesTable, queue.EntitiesColumn),
		)
		fromV = sqlgraph.Neighbors(q.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *QueueClient) Hooks() []Hook {
	return c.hooks.Queue
}

// Interceptors returns the client interceptors.
func (c *QueueClient) Interceptors() []Interceptor {
	return c.inters.Queue
}

func (c *QueueClient) mutate(ctx context.Context, m *QueueMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&QueueCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&QueueUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&QueueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&QueueDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Queue mutation op: %q", m.Op())
	}
}

// RunClient is a client for the Run schema.
type RunClient struct {
	config
}

// NewRunClient returns a client for the Run from the given config.
func NewRunClient(c config) *RunClient {
	return &RunClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `run.Hooks(f(g(h())))`.
func (c *RunClient) Use(hooks ...Hook) {
	c.hooks.Run = append(c.hooks.Run, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `run.Intercept(f(g(h())))`.
func (c *RunClient) Intercept(interceptors ...Interceptor) {
	c.inters.Run = append(c.inters.Run, interceptors...)
}

// Create returns a builder for creating a Run entity.
func (c *RunClient) Create() *RunCreate {
	mutation := newRunMutation(c.config, OpCreate)
	return &RunCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Run entities.
func (c *RunClient) CreateBulk(builders ...*RunCreate) *RunCreateBulk {
	return &RunCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RunClient) MapCreateBulk(slice any, setFunc func(*RunCreate, int)) *RunCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RunCreateBulk{err: fmt.Errorf("calling to RunClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RunCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RunCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Run.
func (c *RunClient) Update() *RunUpdate {
	mutation := newRunMutation(c.config, OpUpdate)
	return &RunUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RunClient) UpdateOne(r *Run) *RunUpdateOne {
	mutation := newRunMutation(c.config, OpUpdateOne, withRun(r))
	return &RunUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RunClient) UpdateOneID(id int) *RunUpdateOne {
	mutation := newRunMutation(c.config, OpUpdateOne, withRunID(id))
	return &RunUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Run.
func (c *RunClient) Delete() *RunDelete {
	mutation := newRunMutation(c.config, OpDelete)
	return &RunDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RunClient) DeleteOne(r *Run) *RunDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RunClient) DeleteOneID(id int) *RunDeleteOne {
	builder := c.Delete().Where(run.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RunDeleteOne{builder}
}

// Query returns a query builder for Run.
func (c *RunClient) Query() *RunQuery {
	return &RunQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRun},
		inters: c.Interceptors(),
	}
}

// Get returns a Run entity by its id.
func (c *RunClient) Get(ctx context.Context, id int) (*Run, error) {
	return c.Query().Where(run.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RunClient) GetX(ctx context.Context, id int) *Run {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEntities queries the entities edge of a Run.
func (c *RunClient) QueryEntities(r *Run) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(run.Table, run.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, run.EntitiesTable, run.EntitiesColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHierarchies queries the hierarchies edge of a Run.
func (c *RunClient) QueryHierarchies(r *Run) *HierarchyQuery {
	query := (&HierarchyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(run.Table, run.FieldID, id),
			sqlgraph.To(hierarchy.Table, hierarchy.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, run.HierarchiesTable, run.HierarchiesColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RunClient) Hooks() []Hook {
	return c.hooks.Run
}

// Interceptors returns the client interceptors.
func (c *RunClient) Interceptors() []Interceptor {
	return c.inters.Run
}

func (c *RunClient) mutate(ctx context.Context, m *RunMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RunCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RunUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RunUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RunDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Run mutation op: %q", m.Op())
	}
}

// SagaDataClient is a client for the SagaData schema.
type SagaDataClient struct {
	config
}

// NewSagaDataClient returns a client for the SagaData from the given config.
func NewSagaDataClient(c config) *SagaDataClient {
	return &SagaDataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sagadata.Hooks(f(g(h())))`.
func (c *SagaDataClient) Use(hooks ...Hook) {
	c.hooks.SagaData = append(c.hooks.SagaData, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sagadata.Intercept(f(g(h())))`.
func (c *SagaDataClient) Intercept(interceptors ...Interceptor) {
	c.inters.SagaData = append(c.inters.SagaData, interceptors...)
}

// Create returns a builder for creating a SagaData entity.
func (c *SagaDataClient) Create() *SagaDataCreate {
	mutation := newSagaDataMutation(c.config, OpCreate)
	return &SagaDataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SagaData entities.
func (c *SagaDataClient) CreateBulk(builders ...*SagaDataCreate) *SagaDataCreateBulk {
	return &SagaDataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SagaDataClient) MapCreateBulk(slice any, setFunc func(*SagaDataCreate, int)) *SagaDataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SagaDataCreateBulk{err: fmt.Errorf("calling to SagaDataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SagaDataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SagaDataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SagaData.
func (c *SagaDataClient) Update() *SagaDataUpdate {
	mutation := newSagaDataMutation(c.config, OpUpdate)
	return &SagaDataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SagaDataClient) UpdateOne(sd *SagaData) *SagaDataUpdateOne {
	mutation := newSagaDataMutation(c.config, OpUpdateOne, withSagaData(sd))
	return &SagaDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SagaDataClient) UpdateOneID(id int) *SagaDataUpdateOne {
	mutation := newSagaDataMutation(c.config, OpUpdateOne, withSagaDataID(id))
	return &SagaDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SagaData.
func (c *SagaDataClient) Delete() *SagaDataDelete {
	mutation := newSagaDataMutation(c.config, OpDelete)
	return &SagaDataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SagaDataClient) DeleteOne(sd *SagaData) *SagaDataDeleteOne {
	return c.DeleteOneID(sd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SagaDataClient) DeleteOneID(id int) *SagaDataDeleteOne {
	builder := c.Delete().Where(sagadata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SagaDataDeleteOne{builder}
}

// Query returns a query builder for SagaData.
func (c *SagaDataClient) Query() *SagaDataQuery {
	return &SagaDataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSagaData},
		inters: c.Interceptors(),
	}
}

// Get returns a SagaData entity by its id.
func (c *SagaDataClient) Get(ctx context.Context, id int) (*SagaData, error) {
	return c.Query().Where(sagadata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SagaDataClient) GetX(ctx context.Context, id int) *SagaData {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEntity queries the entity edge of a SagaData.
func (c *SagaDataClient) QueryEntity(sd *SagaData) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sagadata.Table, sagadata.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, sagadata.EntityTable, sagadata.EntityColumn),
		)
		fromV = sqlgraph.Neighbors(sd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SagaDataClient) Hooks() []Hook {
	return c.hooks.SagaData
}

// Interceptors returns the client interceptors.
func (c *SagaDataClient) Interceptors() []Interceptor {
	return c.inters.SagaData
}

func (c *SagaDataClient) mutate(ctx context.Context, m *SagaDataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SagaDataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SagaDataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SagaDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SagaDataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SagaData mutation op: %q", m.Op())
	}
}

// SagaExecutionClient is a client for the SagaExecution schema.
type SagaExecutionClient struct {
	config
}

// NewSagaExecutionClient returns a client for the SagaExecution from the given config.
func NewSagaExecutionClient(c config) *SagaExecutionClient {
	return &SagaExecutionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sagaexecution.Hooks(f(g(h())))`.
func (c *SagaExecutionClient) Use(hooks ...Hook) {
	c.hooks.SagaExecution = append(c.hooks.SagaExecution, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sagaexecution.Intercept(f(g(h())))`.
func (c *SagaExecutionClient) Intercept(interceptors ...Interceptor) {
	c.inters.SagaExecution = append(c.inters.SagaExecution, interceptors...)
}

// Create returns a builder for creating a SagaExecution entity.
func (c *SagaExecutionClient) Create() *SagaExecutionCreate {
	mutation := newSagaExecutionMutation(c.config, OpCreate)
	return &SagaExecutionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SagaExecution entities.
func (c *SagaExecutionClient) CreateBulk(builders ...*SagaExecutionCreate) *SagaExecutionCreateBulk {
	return &SagaExecutionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SagaExecutionClient) MapCreateBulk(slice any, setFunc func(*SagaExecutionCreate, int)) *SagaExecutionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SagaExecutionCreateBulk{err: fmt.Errorf("calling to SagaExecutionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SagaExecutionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SagaExecutionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SagaExecution.
func (c *SagaExecutionClient) Update() *SagaExecutionUpdate {
	mutation := newSagaExecutionMutation(c.config, OpUpdate)
	return &SagaExecutionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SagaExecutionClient) UpdateOne(se *SagaExecution) *SagaExecutionUpdateOne {
	mutation := newSagaExecutionMutation(c.config, OpUpdateOne, withSagaExecution(se))
	return &SagaExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SagaExecutionClient) UpdateOneID(id int) *SagaExecutionUpdateOne {
	mutation := newSagaExecutionMutation(c.config, OpUpdateOne, withSagaExecutionID(id))
	return &SagaExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SagaExecution.
func (c *SagaExecutionClient) Delete() *SagaExecutionDelete {
	mutation := newSagaExecutionMutation(c.config, OpDelete)
	return &SagaExecutionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SagaExecutionClient) DeleteOne(se *SagaExecution) *SagaExecutionDeleteOne {
	return c.DeleteOneID(se.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SagaExecutionClient) DeleteOneID(id int) *SagaExecutionDeleteOne {
	builder := c.Delete().Where(sagaexecution.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SagaExecutionDeleteOne{builder}
}

// Query returns a query builder for SagaExecution.
func (c *SagaExecutionClient) Query() *SagaExecutionQuery {
	return &SagaExecutionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSagaExecution},
		inters: c.Interceptors(),
	}
}

// Get returns a SagaExecution entity by its id.
func (c *SagaExecutionClient) Get(ctx context.Context, id int) (*SagaExecution, error) {
	return c.Query().Where(sagaexecution.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SagaExecutionClient) GetX(ctx context.Context, id int) *SagaExecution {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryExecution queries the execution edge of a SagaExecution.
func (c *SagaExecutionClient) QueryExecution(se *SagaExecution) *ExecutionQuery {
	query := (&ExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := se.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sagaexecution.Table, sagaexecution.FieldID, id),
			sqlgraph.To(execution.Table, execution.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, sagaexecution.ExecutionTable, sagaexecution.ExecutionColumn),
		)
		fromV = sqlgraph.Neighbors(se.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExecutionData queries the execution_data edge of a SagaExecution.
func (c *SagaExecutionClient) QueryExecutionData(se *SagaExecution) *SagaExecutionDataQuery {
	query := (&SagaExecutionDataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := se.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sagaexecution.Table, sagaexecution.FieldID, id),
			sqlgraph.To(sagaexecutiondata.Table, sagaexecutiondata.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, sagaexecution.ExecutionDataTable, sagaexecution.ExecutionDataColumn),
		)
		fromV = sqlgraph.Neighbors(se.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SagaExecutionClient) Hooks() []Hook {
	return c.hooks.SagaExecution
}

// Interceptors returns the client interceptors.
func (c *SagaExecutionClient) Interceptors() []Interceptor {
	return c.inters.SagaExecution
}

func (c *SagaExecutionClient) mutate(ctx context.Context, m *SagaExecutionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SagaExecutionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SagaExecutionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SagaExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SagaExecutionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SagaExecution mutation op: %q", m.Op())
	}
}

// SagaExecutionDataClient is a client for the SagaExecutionData schema.
type SagaExecutionDataClient struct {
	config
}

// NewSagaExecutionDataClient returns a client for the SagaExecutionData from the given config.
func NewSagaExecutionDataClient(c config) *SagaExecutionDataClient {
	return &SagaExecutionDataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sagaexecutiondata.Hooks(f(g(h())))`.
func (c *SagaExecutionDataClient) Use(hooks ...Hook) {
	c.hooks.SagaExecutionData = append(c.hooks.SagaExecutionData, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sagaexecutiondata.Intercept(f(g(h())))`.
func (c *SagaExecutionDataClient) Intercept(interceptors ...Interceptor) {
	c.inters.SagaExecutionData = append(c.inters.SagaExecutionData, interceptors...)
}

// Create returns a builder for creating a SagaExecutionData entity.
func (c *SagaExecutionDataClient) Create() *SagaExecutionDataCreate {
	mutation := newSagaExecutionDataMutation(c.config, OpCreate)
	return &SagaExecutionDataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SagaExecutionData entities.
func (c *SagaExecutionDataClient) CreateBulk(builders ...*SagaExecutionDataCreate) *SagaExecutionDataCreateBulk {
	return &SagaExecutionDataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SagaExecutionDataClient) MapCreateBulk(slice any, setFunc func(*SagaExecutionDataCreate, int)) *SagaExecutionDataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SagaExecutionDataCreateBulk{err: fmt.Errorf("calling to SagaExecutionDataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SagaExecutionDataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SagaExecutionDataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SagaExecutionData.
func (c *SagaExecutionDataClient) Update() *SagaExecutionDataUpdate {
	mutation := newSagaExecutionDataMutation(c.config, OpUpdate)
	return &SagaExecutionDataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SagaExecutionDataClient) UpdateOne(sed *SagaExecutionData) *SagaExecutionDataUpdateOne {
	mutation := newSagaExecutionDataMutation(c.config, OpUpdateOne, withSagaExecutionData(sed))
	return &SagaExecutionDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SagaExecutionDataClient) UpdateOneID(id int) *SagaExecutionDataUpdateOne {
	mutation := newSagaExecutionDataMutation(c.config, OpUpdateOne, withSagaExecutionDataID(id))
	return &SagaExecutionDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SagaExecutionData.
func (c *SagaExecutionDataClient) Delete() *SagaExecutionDataDelete {
	mutation := newSagaExecutionDataMutation(c.config, OpDelete)
	return &SagaExecutionDataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SagaExecutionDataClient) DeleteOne(sed *SagaExecutionData) *SagaExecutionDataDeleteOne {
	return c.DeleteOneID(sed.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SagaExecutionDataClient) DeleteOneID(id int) *SagaExecutionDataDeleteOne {
	builder := c.Delete().Where(sagaexecutiondata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SagaExecutionDataDeleteOne{builder}
}

// Query returns a query builder for SagaExecutionData.
func (c *SagaExecutionDataClient) Query() *SagaExecutionDataQuery {
	return &SagaExecutionDataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSagaExecutionData},
		inters: c.Interceptors(),
	}
}

// Get returns a SagaExecutionData entity by its id.
func (c *SagaExecutionDataClient) Get(ctx context.Context, id int) (*SagaExecutionData, error) {
	return c.Query().Where(sagaexecutiondata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SagaExecutionDataClient) GetX(ctx context.Context, id int) *SagaExecutionData {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySagaExecution queries the saga_execution edge of a SagaExecutionData.
func (c *SagaExecutionDataClient) QuerySagaExecution(sed *SagaExecutionData) *SagaExecutionQuery {
	query := (&SagaExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sed.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sagaexecutiondata.Table, sagaexecutiondata.FieldID, id),
			sqlgraph.To(sagaexecution.Table, sagaexecution.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, sagaexecutiondata.SagaExecutionTable, sagaexecutiondata.SagaExecutionColumn),
		)
		fromV = sqlgraph.Neighbors(sed.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SagaExecutionDataClient) Hooks() []Hook {
	return c.hooks.SagaExecutionData
}

// Interceptors returns the client interceptors.
func (c *SagaExecutionDataClient) Interceptors() []Interceptor {
	return c.inters.SagaExecutionData
}

func (c *SagaExecutionDataClient) mutate(ctx context.Context, m *SagaExecutionDataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SagaExecutionDataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SagaExecutionDataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SagaExecutionDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SagaExecutionDataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SagaExecutionData mutation op: %q", m.Op())
	}
}

// SideEffectDataClient is a client for the SideEffectData schema.
type SideEffectDataClient struct {
	config
}

// NewSideEffectDataClient returns a client for the SideEffectData from the given config.
func NewSideEffectDataClient(c config) *SideEffectDataClient {
	return &SideEffectDataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sideeffectdata.Hooks(f(g(h())))`.
func (c *SideEffectDataClient) Use(hooks ...Hook) {
	c.hooks.SideEffectData = append(c.hooks.SideEffectData, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sideeffectdata.Intercept(f(g(h())))`.
func (c *SideEffectDataClient) Intercept(interceptors ...Interceptor) {
	c.inters.SideEffectData = append(c.inters.SideEffectData, interceptors...)
}

// Create returns a builder for creating a SideEffectData entity.
func (c *SideEffectDataClient) Create() *SideEffectDataCreate {
	mutation := newSideEffectDataMutation(c.config, OpCreate)
	return &SideEffectDataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SideEffectData entities.
func (c *SideEffectDataClient) CreateBulk(builders ...*SideEffectDataCreate) *SideEffectDataCreateBulk {
	return &SideEffectDataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SideEffectDataClient) MapCreateBulk(slice any, setFunc func(*SideEffectDataCreate, int)) *SideEffectDataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SideEffectDataCreateBulk{err: fmt.Errorf("calling to SideEffectDataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SideEffectDataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SideEffectDataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SideEffectData.
func (c *SideEffectDataClient) Update() *SideEffectDataUpdate {
	mutation := newSideEffectDataMutation(c.config, OpUpdate)
	return &SideEffectDataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SideEffectDataClient) UpdateOne(sed *SideEffectData) *SideEffectDataUpdateOne {
	mutation := newSideEffectDataMutation(c.config, OpUpdateOne, withSideEffectData(sed))
	return &SideEffectDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SideEffectDataClient) UpdateOneID(id int) *SideEffectDataUpdateOne {
	mutation := newSideEffectDataMutation(c.config, OpUpdateOne, withSideEffectDataID(id))
	return &SideEffectDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SideEffectData.
func (c *SideEffectDataClient) Delete() *SideEffectDataDelete {
	mutation := newSideEffectDataMutation(c.config, OpDelete)
	return &SideEffectDataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SideEffectDataClient) DeleteOne(sed *SideEffectData) *SideEffectDataDeleteOne {
	return c.DeleteOneID(sed.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SideEffectDataClient) DeleteOneID(id int) *SideEffectDataDeleteOne {
	builder := c.Delete().Where(sideeffectdata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SideEffectDataDeleteOne{builder}
}

// Query returns a query builder for SideEffectData.
func (c *SideEffectDataClient) Query() *SideEffectDataQuery {
	return &SideEffectDataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSideEffectData},
		inters: c.Interceptors(),
	}
}

// Get returns a SideEffectData entity by its id.
func (c *SideEffectDataClient) Get(ctx context.Context, id int) (*SideEffectData, error) {
	return c.Query().Where(sideeffectdata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SideEffectDataClient) GetX(ctx context.Context, id int) *SideEffectData {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEntity queries the entity edge of a SideEffectData.
func (c *SideEffectDataClient) QueryEntity(sed *SideEffectData) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sed.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sideeffectdata.Table, sideeffectdata.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, sideeffectdata.EntityTable, sideeffectdata.EntityColumn),
		)
		fromV = sqlgraph.Neighbors(sed.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SideEffectDataClient) Hooks() []Hook {
	return c.hooks.SideEffectData
}

// Interceptors returns the client interceptors.
func (c *SideEffectDataClient) Interceptors() []Interceptor {
	return c.inters.SideEffectData
}

func (c *SideEffectDataClient) mutate(ctx context.Context, m *SideEffectDataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SideEffectDataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SideEffectDataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SideEffectDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SideEffectDataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SideEffectData mutation op: %q", m.Op())
	}
}

// SideEffectExecutionClient is a client for the SideEffectExecution schema.
type SideEffectExecutionClient struct {
	config
}

// NewSideEffectExecutionClient returns a client for the SideEffectExecution from the given config.
func NewSideEffectExecutionClient(c config) *SideEffectExecutionClient {
	return &SideEffectExecutionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sideeffectexecution.Hooks(f(g(h())))`.
func (c *SideEffectExecutionClient) Use(hooks ...Hook) {
	c.hooks.SideEffectExecution = append(c.hooks.SideEffectExecution, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sideeffectexecution.Intercept(f(g(h())))`.
func (c *SideEffectExecutionClient) Intercept(interceptors ...Interceptor) {
	c.inters.SideEffectExecution = append(c.inters.SideEffectExecution, interceptors...)
}

// Create returns a builder for creating a SideEffectExecution entity.
func (c *SideEffectExecutionClient) Create() *SideEffectExecutionCreate {
	mutation := newSideEffectExecutionMutation(c.config, OpCreate)
	return &SideEffectExecutionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SideEffectExecution entities.
func (c *SideEffectExecutionClient) CreateBulk(builders ...*SideEffectExecutionCreate) *SideEffectExecutionCreateBulk {
	return &SideEffectExecutionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SideEffectExecutionClient) MapCreateBulk(slice any, setFunc func(*SideEffectExecutionCreate, int)) *SideEffectExecutionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SideEffectExecutionCreateBulk{err: fmt.Errorf("calling to SideEffectExecutionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SideEffectExecutionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SideEffectExecutionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SideEffectExecution.
func (c *SideEffectExecutionClient) Update() *SideEffectExecutionUpdate {
	mutation := newSideEffectExecutionMutation(c.config, OpUpdate)
	return &SideEffectExecutionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SideEffectExecutionClient) UpdateOne(see *SideEffectExecution) *SideEffectExecutionUpdateOne {
	mutation := newSideEffectExecutionMutation(c.config, OpUpdateOne, withSideEffectExecution(see))
	return &SideEffectExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SideEffectExecutionClient) UpdateOneID(id int) *SideEffectExecutionUpdateOne {
	mutation := newSideEffectExecutionMutation(c.config, OpUpdateOne, withSideEffectExecutionID(id))
	return &SideEffectExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SideEffectExecution.
func (c *SideEffectExecutionClient) Delete() *SideEffectExecutionDelete {
	mutation := newSideEffectExecutionMutation(c.config, OpDelete)
	return &SideEffectExecutionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SideEffectExecutionClient) DeleteOne(see *SideEffectExecution) *SideEffectExecutionDeleteOne {
	return c.DeleteOneID(see.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SideEffectExecutionClient) DeleteOneID(id int) *SideEffectExecutionDeleteOne {
	builder := c.Delete().Where(sideeffectexecution.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SideEffectExecutionDeleteOne{builder}
}

// Query returns a query builder for SideEffectExecution.
func (c *SideEffectExecutionClient) Query() *SideEffectExecutionQuery {
	return &SideEffectExecutionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSideEffectExecution},
		inters: c.Interceptors(),
	}
}

// Get returns a SideEffectExecution entity by its id.
func (c *SideEffectExecutionClient) Get(ctx context.Context, id int) (*SideEffectExecution, error) {
	return c.Query().Where(sideeffectexecution.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SideEffectExecutionClient) GetX(ctx context.Context, id int) *SideEffectExecution {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryExecution queries the execution edge of a SideEffectExecution.
func (c *SideEffectExecutionClient) QueryExecution(see *SideEffectExecution) *ExecutionQuery {
	query := (&ExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := see.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sideeffectexecution.Table, sideeffectexecution.FieldID, id),
			sqlgraph.To(execution.Table, execution.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, sideeffectexecution.ExecutionTable, sideeffectexecution.ExecutionColumn),
		)
		fromV = sqlgraph.Neighbors(see.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExecutionData queries the execution_data edge of a SideEffectExecution.
func (c *SideEffectExecutionClient) QueryExecutionData(see *SideEffectExecution) *SideEffectExecutionDataQuery {
	query := (&SideEffectExecutionDataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := see.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sideeffectexecution.Table, sideeffectexecution.FieldID, id),
			sqlgraph.To(sideeffectexecutiondata.Table, sideeffectexecutiondata.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, sideeffectexecution.ExecutionDataTable, sideeffectexecution.ExecutionDataColumn),
		)
		fromV = sqlgraph.Neighbors(see.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SideEffectExecutionClient) Hooks() []Hook {
	return c.hooks.SideEffectExecution
}

// Interceptors returns the client interceptors.
func (c *SideEffectExecutionClient) Interceptors() []Interceptor {
	return c.inters.SideEffectExecution
}

func (c *SideEffectExecutionClient) mutate(ctx context.Context, m *SideEffectExecutionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SideEffectExecutionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SideEffectExecutionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SideEffectExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SideEffectExecutionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SideEffectExecution mutation op: %q", m.Op())
	}
}

// SideEffectExecutionDataClient is a client for the SideEffectExecutionData schema.
type SideEffectExecutionDataClient struct {
	config
}

// NewSideEffectExecutionDataClient returns a client for the SideEffectExecutionData from the given config.
func NewSideEffectExecutionDataClient(c config) *SideEffectExecutionDataClient {
	return &SideEffectExecutionDataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sideeffectexecutiondata.Hooks(f(g(h())))`.
func (c *SideEffectExecutionDataClient) Use(hooks ...Hook) {
	c.hooks.SideEffectExecutionData = append(c.hooks.SideEffectExecutionData, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sideeffectexecutiondata.Intercept(f(g(h())))`.
func (c *SideEffectExecutionDataClient) Intercept(interceptors ...Interceptor) {
	c.inters.SideEffectExecutionData = append(c.inters.SideEffectExecutionData, interceptors...)
}

// Create returns a builder for creating a SideEffectExecutionData entity.
func (c *SideEffectExecutionDataClient) Create() *SideEffectExecutionDataCreate {
	mutation := newSideEffectExecutionDataMutation(c.config, OpCreate)
	return &SideEffectExecutionDataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SideEffectExecutionData entities.
func (c *SideEffectExecutionDataClient) CreateBulk(builders ...*SideEffectExecutionDataCreate) *SideEffectExecutionDataCreateBulk {
	return &SideEffectExecutionDataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SideEffectExecutionDataClient) MapCreateBulk(slice any, setFunc func(*SideEffectExecutionDataCreate, int)) *SideEffectExecutionDataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SideEffectExecutionDataCreateBulk{err: fmt.Errorf("calling to SideEffectExecutionDataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SideEffectExecutionDataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SideEffectExecutionDataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SideEffectExecutionData.
func (c *SideEffectExecutionDataClient) Update() *SideEffectExecutionDataUpdate {
	mutation := newSideEffectExecutionDataMutation(c.config, OpUpdate)
	return &SideEffectExecutionDataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SideEffectExecutionDataClient) UpdateOne(seed *SideEffectExecutionData) *SideEffectExecutionDataUpdateOne {
	mutation := newSideEffectExecutionDataMutation(c.config, OpUpdateOne, withSideEffectExecutionData(seed))
	return &SideEffectExecutionDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SideEffectExecutionDataClient) UpdateOneID(id int) *SideEffectExecutionDataUpdateOne {
	mutation := newSideEffectExecutionDataMutation(c.config, OpUpdateOne, withSideEffectExecutionDataID(id))
	return &SideEffectExecutionDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SideEffectExecutionData.
func (c *SideEffectExecutionDataClient) Delete() *SideEffectExecutionDataDelete {
	mutation := newSideEffectExecutionDataMutation(c.config, OpDelete)
	return &SideEffectExecutionDataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SideEffectExecutionDataClient) DeleteOne(seed *SideEffectExecutionData) *SideEffectExecutionDataDeleteOne {
	return c.DeleteOneID(seed.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SideEffectExecutionDataClient) DeleteOneID(id int) *SideEffectExecutionDataDeleteOne {
	builder := c.Delete().Where(sideeffectexecutiondata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SideEffectExecutionDataDeleteOne{builder}
}

// Query returns a query builder for SideEffectExecutionData.
func (c *SideEffectExecutionDataClient) Query() *SideEffectExecutionDataQuery {
	return &SideEffectExecutionDataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSideEffectExecutionData},
		inters: c.Interceptors(),
	}
}

// Get returns a SideEffectExecutionData entity by its id.
func (c *SideEffectExecutionDataClient) Get(ctx context.Context, id int) (*SideEffectExecutionData, error) {
	return c.Query().Where(sideeffectexecutiondata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SideEffectExecutionDataClient) GetX(ctx context.Context, id int) *SideEffectExecutionData {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySideEffectExecution queries the side_effect_execution edge of a SideEffectExecutionData.
func (c *SideEffectExecutionDataClient) QuerySideEffectExecution(seed *SideEffectExecutionData) *SideEffectExecutionQuery {
	query := (&SideEffectExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := seed.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sideeffectexecutiondata.Table, sideeffectexecutiondata.FieldID, id),
			sqlgraph.To(sideeffectexecution.Table, sideeffectexecution.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, sideeffectexecutiondata.SideEffectExecutionTable, sideeffectexecutiondata.SideEffectExecutionColumn),
		)
		fromV = sqlgraph.Neighbors(seed.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SideEffectExecutionDataClient) Hooks() []Hook {
	return c.hooks.SideEffectExecutionData
}

// Interceptors returns the client interceptors.
func (c *SideEffectExecutionDataClient) Interceptors() []Interceptor {
	return c.inters.SideEffectExecutionData
}

func (c *SideEffectExecutionDataClient) mutate(ctx context.Context, m *SideEffectExecutionDataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SideEffectExecutionDataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SideEffectExecutionDataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SideEffectExecutionDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SideEffectExecutionDataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SideEffectExecutionData mutation op: %q", m.Op())
	}
}

// VersionClient is a client for the Version schema.
type VersionClient struct {
	config
}

// NewVersionClient returns a client for the Version from the given config.
func NewVersionClient(c config) *VersionClient {
	return &VersionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `version.Hooks(f(g(h())))`.
func (c *VersionClient) Use(hooks ...Hook) {
	c.hooks.Version = append(c.hooks.Version, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `version.Intercept(f(g(h())))`.
func (c *VersionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Version = append(c.inters.Version, interceptors...)
}

// Create returns a builder for creating a Version entity.
func (c *VersionClient) Create() *VersionCreate {
	mutation := newVersionMutation(c.config, OpCreate)
	return &VersionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Version entities.
func (c *VersionClient) CreateBulk(builders ...*VersionCreate) *VersionCreateBulk {
	return &VersionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VersionClient) MapCreateBulk(slice any, setFunc func(*VersionCreate, int)) *VersionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VersionCreateBulk{err: fmt.Errorf("calling to VersionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VersionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VersionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Version.
func (c *VersionClient) Update() *VersionUpdate {
	mutation := newVersionMutation(c.config, OpUpdate)
	return &VersionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VersionClient) UpdateOne(v *Version) *VersionUpdateOne {
	mutation := newVersionMutation(c.config, OpUpdateOne, withVersion(v))
	return &VersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VersionClient) UpdateOneID(id int) *VersionUpdateOne {
	mutation := newVersionMutation(c.config, OpUpdateOne, withVersionID(id))
	return &VersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Version.
func (c *VersionClient) Delete() *VersionDelete {
	mutation := newVersionMutation(c.config, OpDelete)
	return &VersionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VersionClient) DeleteOne(v *Version) *VersionDeleteOne {
	return c.DeleteOneID(v.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VersionClient) DeleteOneID(id int) *VersionDeleteOne {
	builder := c.Delete().Where(version.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VersionDeleteOne{builder}
}

// Query returns a query builder for Version.
func (c *VersionClient) Query() *VersionQuery {
	return &VersionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVersion},
		inters: c.Interceptors(),
	}
}

// Get returns a Version entity by its id.
func (c *VersionClient) Get(ctx context.Context, id int) (*Version, error) {
	return c.Query().Where(version.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VersionClient) GetX(ctx context.Context, id int) *Version {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEntity queries the entity edge of a Version.
func (c *VersionClient) QueryEntity(v *Version) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(version.Table, version.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, version.EntityTable, version.EntityColumn),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VersionClient) Hooks() []Hook {
	return c.hooks.Version
}

// Interceptors returns the client interceptors.
func (c *VersionClient) Interceptors() []Interceptor {
	return c.inters.Version
}

func (c *VersionClient) mutate(ctx context.Context, m *VersionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VersionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VersionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VersionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Version mutation op: %q", m.Op())
	}
}

// WorkflowDataClient is a client for the WorkflowData schema.
type WorkflowDataClient struct {
	config
}

// NewWorkflowDataClient returns a client for the WorkflowData from the given config.
func NewWorkflowDataClient(c config) *WorkflowDataClient {
	return &WorkflowDataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workflowdata.Hooks(f(g(h())))`.
func (c *WorkflowDataClient) Use(hooks ...Hook) {
	c.hooks.WorkflowData = append(c.hooks.WorkflowData, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `workflowdata.Intercept(f(g(h())))`.
func (c *WorkflowDataClient) Intercept(interceptors ...Interceptor) {
	c.inters.WorkflowData = append(c.inters.WorkflowData, interceptors...)
}

// Create returns a builder for creating a WorkflowData entity.
func (c *WorkflowDataClient) Create() *WorkflowDataCreate {
	mutation := newWorkflowDataMutation(c.config, OpCreate)
	return &WorkflowDataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WorkflowData entities.
func (c *WorkflowDataClient) CreateBulk(builders ...*WorkflowDataCreate) *WorkflowDataCreateBulk {
	return &WorkflowDataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WorkflowDataClient) MapCreateBulk(slice any, setFunc func(*WorkflowDataCreate, int)) *WorkflowDataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WorkflowDataCreateBulk{err: fmt.Errorf("calling to WorkflowDataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WorkflowDataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WorkflowDataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WorkflowData.
func (c *WorkflowDataClient) Update() *WorkflowDataUpdate {
	mutation := newWorkflowDataMutation(c.config, OpUpdate)
	return &WorkflowDataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkflowDataClient) UpdateOne(wd *WorkflowData) *WorkflowDataUpdateOne {
	mutation := newWorkflowDataMutation(c.config, OpUpdateOne, withWorkflowData(wd))
	return &WorkflowDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkflowDataClient) UpdateOneID(id int) *WorkflowDataUpdateOne {
	mutation := newWorkflowDataMutation(c.config, OpUpdateOne, withWorkflowDataID(id))
	return &WorkflowDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WorkflowData.
func (c *WorkflowDataClient) Delete() *WorkflowDataDelete {
	mutation := newWorkflowDataMutation(c.config, OpDelete)
	return &WorkflowDataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WorkflowDataClient) DeleteOne(wd *WorkflowData) *WorkflowDataDeleteOne {
	return c.DeleteOneID(wd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WorkflowDataClient) DeleteOneID(id int) *WorkflowDataDeleteOne {
	builder := c.Delete().Where(workflowdata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkflowDataDeleteOne{builder}
}

// Query returns a query builder for WorkflowData.
func (c *WorkflowDataClient) Query() *WorkflowDataQuery {
	return &WorkflowDataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWorkflowData},
		inters: c.Interceptors(),
	}
}

// Get returns a WorkflowData entity by its id.
func (c *WorkflowDataClient) Get(ctx context.Context, id int) (*WorkflowData, error) {
	return c.Query().Where(workflowdata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkflowDataClient) GetX(ctx context.Context, id int) *WorkflowData {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEntity queries the entity edge of a WorkflowData.
func (c *WorkflowDataClient) QueryEntity(wd *WorkflowData) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := wd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowdata.Table, workflowdata.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, workflowdata.EntityTable, workflowdata.EntityColumn),
		)
		fromV = sqlgraph.Neighbors(wd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorkflowDataClient) Hooks() []Hook {
	return c.hooks.WorkflowData
}

// Interceptors returns the client interceptors.
func (c *WorkflowDataClient) Interceptors() []Interceptor {
	return c.inters.WorkflowData
}

func (c *WorkflowDataClient) mutate(ctx context.Context, m *WorkflowDataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WorkflowDataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WorkflowDataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WorkflowDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WorkflowDataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WorkflowData mutation op: %q", m.Op())
	}
}

// WorkflowExecutionClient is a client for the WorkflowExecution schema.
type WorkflowExecutionClient struct {
	config
}

// NewWorkflowExecutionClient returns a client for the WorkflowExecution from the given config.
func NewWorkflowExecutionClient(c config) *WorkflowExecutionClient {
	return &WorkflowExecutionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workflowexecution.Hooks(f(g(h())))`.
func (c *WorkflowExecutionClient) Use(hooks ...Hook) {
	c.hooks.WorkflowExecution = append(c.hooks.WorkflowExecution, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `workflowexecution.Intercept(f(g(h())))`.
func (c *WorkflowExecutionClient) Intercept(interceptors ...Interceptor) {
	c.inters.WorkflowExecution = append(c.inters.WorkflowExecution, interceptors...)
}

// Create returns a builder for creating a WorkflowExecution entity.
func (c *WorkflowExecutionClient) Create() *WorkflowExecutionCreate {
	mutation := newWorkflowExecutionMutation(c.config, OpCreate)
	return &WorkflowExecutionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WorkflowExecution entities.
func (c *WorkflowExecutionClient) CreateBulk(builders ...*WorkflowExecutionCreate) *WorkflowExecutionCreateBulk {
	return &WorkflowExecutionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WorkflowExecutionClient) MapCreateBulk(slice any, setFunc func(*WorkflowExecutionCreate, int)) *WorkflowExecutionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WorkflowExecutionCreateBulk{err: fmt.Errorf("calling to WorkflowExecutionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WorkflowExecutionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WorkflowExecutionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WorkflowExecution.
func (c *WorkflowExecutionClient) Update() *WorkflowExecutionUpdate {
	mutation := newWorkflowExecutionMutation(c.config, OpUpdate)
	return &WorkflowExecutionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkflowExecutionClient) UpdateOne(we *WorkflowExecution) *WorkflowExecutionUpdateOne {
	mutation := newWorkflowExecutionMutation(c.config, OpUpdateOne, withWorkflowExecution(we))
	return &WorkflowExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkflowExecutionClient) UpdateOneID(id int) *WorkflowExecutionUpdateOne {
	mutation := newWorkflowExecutionMutation(c.config, OpUpdateOne, withWorkflowExecutionID(id))
	return &WorkflowExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WorkflowExecution.
func (c *WorkflowExecutionClient) Delete() *WorkflowExecutionDelete {
	mutation := newWorkflowExecutionMutation(c.config, OpDelete)
	return &WorkflowExecutionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WorkflowExecutionClient) DeleteOne(we *WorkflowExecution) *WorkflowExecutionDeleteOne {
	return c.DeleteOneID(we.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WorkflowExecutionClient) DeleteOneID(id int) *WorkflowExecutionDeleteOne {
	builder := c.Delete().Where(workflowexecution.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkflowExecutionDeleteOne{builder}
}

// Query returns a query builder for WorkflowExecution.
func (c *WorkflowExecutionClient) Query() *WorkflowExecutionQuery {
	return &WorkflowExecutionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWorkflowExecution},
		inters: c.Interceptors(),
	}
}

// Get returns a WorkflowExecution entity by its id.
func (c *WorkflowExecutionClient) Get(ctx context.Context, id int) (*WorkflowExecution, error) {
	return c.Query().Where(workflowexecution.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkflowExecutionClient) GetX(ctx context.Context, id int) *WorkflowExecution {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryExecution queries the execution edge of a WorkflowExecution.
func (c *WorkflowExecutionClient) QueryExecution(we *WorkflowExecution) *ExecutionQuery {
	query := (&ExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := we.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowexecution.Table, workflowexecution.FieldID, id),
			sqlgraph.To(execution.Table, execution.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, workflowexecution.ExecutionTable, workflowexecution.ExecutionColumn),
		)
		fromV = sqlgraph.Neighbors(we.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExecutionData queries the execution_data edge of a WorkflowExecution.
func (c *WorkflowExecutionClient) QueryExecutionData(we *WorkflowExecution) *WorkflowExecutionDataQuery {
	query := (&WorkflowExecutionDataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := we.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowexecution.Table, workflowexecution.FieldID, id),
			sqlgraph.To(workflowexecutiondata.Table, workflowexecutiondata.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, workflowexecution.ExecutionDataTable, workflowexecution.ExecutionDataColumn),
		)
		fromV = sqlgraph.Neighbors(we.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorkflowExecutionClient) Hooks() []Hook {
	return c.hooks.WorkflowExecution
}

// Interceptors returns the client interceptors.
func (c *WorkflowExecutionClient) Interceptors() []Interceptor {
	return c.inters.WorkflowExecution
}

func (c *WorkflowExecutionClient) mutate(ctx context.Context, m *WorkflowExecutionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WorkflowExecutionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WorkflowExecutionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WorkflowExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WorkflowExecutionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WorkflowExecution mutation op: %q", m.Op())
	}
}

// WorkflowExecutionDataClient is a client for the WorkflowExecutionData schema.
type WorkflowExecutionDataClient struct {
	config
}

// NewWorkflowExecutionDataClient returns a client for the WorkflowExecutionData from the given config.
func NewWorkflowExecutionDataClient(c config) *WorkflowExecutionDataClient {
	return &WorkflowExecutionDataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workflowexecutiondata.Hooks(f(g(h())))`.
func (c *WorkflowExecutionDataClient) Use(hooks ...Hook) {
	c.hooks.WorkflowExecutionData = append(c.hooks.WorkflowExecutionData, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `workflowexecutiondata.Intercept(f(g(h())))`.
func (c *WorkflowExecutionDataClient) Intercept(interceptors ...Interceptor) {
	c.inters.WorkflowExecutionData = append(c.inters.WorkflowExecutionData, interceptors...)
}

// Create returns a builder for creating a WorkflowExecutionData entity.
func (c *WorkflowExecutionDataClient) Create() *WorkflowExecutionDataCreate {
	mutation := newWorkflowExecutionDataMutation(c.config, OpCreate)
	return &WorkflowExecutionDataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WorkflowExecutionData entities.
func (c *WorkflowExecutionDataClient) CreateBulk(builders ...*WorkflowExecutionDataCreate) *WorkflowExecutionDataCreateBulk {
	return &WorkflowExecutionDataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WorkflowExecutionDataClient) MapCreateBulk(slice any, setFunc func(*WorkflowExecutionDataCreate, int)) *WorkflowExecutionDataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WorkflowExecutionDataCreateBulk{err: fmt.Errorf("calling to WorkflowExecutionDataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WorkflowExecutionDataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WorkflowExecutionDataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WorkflowExecutionData.
func (c *WorkflowExecutionDataClient) Update() *WorkflowExecutionDataUpdate {
	mutation := newWorkflowExecutionDataMutation(c.config, OpUpdate)
	return &WorkflowExecutionDataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkflowExecutionDataClient) UpdateOne(wed *WorkflowExecutionData) *WorkflowExecutionDataUpdateOne {
	mutation := newWorkflowExecutionDataMutation(c.config, OpUpdateOne, withWorkflowExecutionData(wed))
	return &WorkflowExecutionDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkflowExecutionDataClient) UpdateOneID(id int) *WorkflowExecutionDataUpdateOne {
	mutation := newWorkflowExecutionDataMutation(c.config, OpUpdateOne, withWorkflowExecutionDataID(id))
	return &WorkflowExecutionDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WorkflowExecutionData.
func (c *WorkflowExecutionDataClient) Delete() *WorkflowExecutionDataDelete {
	mutation := newWorkflowExecutionDataMutation(c.config, OpDelete)
	return &WorkflowExecutionDataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WorkflowExecutionDataClient) DeleteOne(wed *WorkflowExecutionData) *WorkflowExecutionDataDeleteOne {
	return c.DeleteOneID(wed.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WorkflowExecutionDataClient) DeleteOneID(id int) *WorkflowExecutionDataDeleteOne {
	builder := c.Delete().Where(workflowexecutiondata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkflowExecutionDataDeleteOne{builder}
}

// Query returns a query builder for WorkflowExecutionData.
func (c *WorkflowExecutionDataClient) Query() *WorkflowExecutionDataQuery {
	return &WorkflowExecutionDataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWorkflowExecutionData},
		inters: c.Interceptors(),
	}
}

// Get returns a WorkflowExecutionData entity by its id.
func (c *WorkflowExecutionDataClient) Get(ctx context.Context, id int) (*WorkflowExecutionData, error) {
	return c.Query().Where(workflowexecutiondata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkflowExecutionDataClient) GetX(ctx context.Context, id int) *WorkflowExecutionData {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryWorkflowExecution queries the workflow_execution edge of a WorkflowExecutionData.
func (c *WorkflowExecutionDataClient) QueryWorkflowExecution(wed *WorkflowExecutionData) *WorkflowExecutionQuery {
	query := (&WorkflowExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := wed.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowexecutiondata.Table, workflowexecutiondata.FieldID, id),
			sqlgraph.To(workflowexecution.Table, workflowexecution.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, workflowexecutiondata.WorkflowExecutionTable, workflowexecutiondata.WorkflowExecutionColumn),
		)
		fromV = sqlgraph.Neighbors(wed.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorkflowExecutionDataClient) Hooks() []Hook {
	return c.hooks.WorkflowExecutionData
}

// Interceptors returns the client interceptors.
func (c *WorkflowExecutionDataClient) Interceptors() []Interceptor {
	return c.inters.WorkflowExecutionData
}

func (c *WorkflowExecutionDataClient) mutate(ctx context.Context, m *WorkflowExecutionDataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WorkflowExecutionDataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WorkflowExecutionDataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WorkflowExecutionDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WorkflowExecutionDataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WorkflowExecutionData mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		ActivityData, ActivityExecution, ActivityExecutionData, Entity, Execution,
		Hierarchy, Queue, Run, SagaData, SagaExecution, SagaExecutionData,
		SideEffectData, SideEffectExecution, SideEffectExecutionData, Version,
		WorkflowData, WorkflowExecution, WorkflowExecutionData []ent.Hook
	}
	inters struct {
		ActivityData, ActivityExecution, ActivityExecutionData, Entity, Execution,
		Hierarchy, Queue, Run, SagaData, SagaExecution, SagaExecutionData,
		SideEffectData, SideEffectExecution, SideEffectExecutionData, Version,
		WorkflowData, WorkflowExecution, WorkflowExecutionData []ent.Interceptor
	}
)
