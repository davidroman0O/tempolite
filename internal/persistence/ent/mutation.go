// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/activitydata"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/activityexecution"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/activityexecutiondata"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/entity"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/execution"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/hierarchy"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/predicate"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/queue"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/run"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/sagadata"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/sagaexecution"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/sagaexecutiondata"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/schema"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/sideeffectdata"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/sideeffectexecution"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/sideeffectexecutiondata"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/version"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/workflowdata"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/workflowexecution"
	"github.com/davidroman0O/tempolite/internal/persistence/ent/workflowexecutiondata"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeActivityData            = "ActivityData"
	TypeActivityExecution       = "ActivityExecution"
	TypeActivityExecutionData   = "ActivityExecutionData"
	TypeEntity                  = "Entity"
	TypeExecution               = "Execution"
	TypeHierarchy               = "Hierarchy"
	TypeQueue                   = "Queue"
	TypeRun                     = "Run"
	TypeSagaData                = "SagaData"
	TypeSagaExecution           = "SagaExecution"
	TypeSagaExecutionData       = "SagaExecutionData"
	TypeSideEffectData          = "SideEffectData"
	TypeSideEffectExecution     = "SideEffectExecution"
	TypeSideEffectExecutionData = "SideEffectExecutionData"
	TypeVersion                 = "Version"
	TypeWorkflowData            = "WorkflowData"
	TypeWorkflowExecution       = "WorkflowExecution"
	TypeWorkflowExecutionData   = "WorkflowExecutionData"
)

// ActivityDataMutation represents an operation that mutates the ActivityData nodes in the graph.
type ActivityDataMutation struct {
	config
	op              Op
	typ             string
	id              *int
	timeout         *int64
	addtimeout      *int64
	max_attempts    *int
	addmax_attempts *int
	scheduled_for   *time.Time
	input           *[][]uint8
	appendinput     [][]uint8
	output          *[][]uint8
	appendoutput    [][]uint8
	attempt         *int
	addattempt      *int
	clearedFields   map[string]struct{}
	entity          *int
	clearedentity   bool
	done            bool
	oldValue        func(context.Context) (*ActivityData, error)
	predicates      []predicate.ActivityData
}

var _ ent.Mutation = (*ActivityDataMutation)(nil)

// activitydataOption allows management of the mutation configuration using functional options.
type activitydataOption func(*ActivityDataMutation)

// newActivityDataMutation creates new mutation for the ActivityData entity.
func newActivityDataMutation(c config, op Op, opts ...activitydataOption) *ActivityDataMutation {
	m := &ActivityDataMutation{
		config:        c,
		op:            op,
		typ:           TypeActivityData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActivityDataID sets the ID field of the mutation.
func withActivityDataID(id int) activitydataOption {
	return func(m *ActivityDataMutation) {
		var (
			err   error
			once  sync.Once
			value *ActivityData
		)
		m.oldValue = func(ctx context.Context) (*ActivityData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ActivityData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActivityData sets the old ActivityData of the mutation.
func withActivityData(node *ActivityData) activitydataOption {
	return func(m *ActivityDataMutation) {
		m.oldValue = func(context.Context) (*ActivityData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActivityDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActivityDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActivityDataMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActivityDataMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ActivityData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTimeout sets the "timeout" field.
func (m *ActivityDataMutation) SetTimeout(i int64) {
	m.timeout = &i
	m.addtimeout = nil
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *ActivityDataMutation) Timeout() (r int64, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the ActivityData entity.
// If the ActivityData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityDataMutation) OldTimeout(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// AddTimeout adds i to the "timeout" field.
func (m *ActivityDataMutation) AddTimeout(i int64) {
	if m.addtimeout != nil {
		*m.addtimeout += i
	} else {
		m.addtimeout = &i
	}
}

// AddedTimeout returns the value that was added to the "timeout" field in this mutation.
func (m *ActivityDataMutation) AddedTimeout() (r int64, exists bool) {
	v := m.addtimeout
	if v == nil {
		return
	}
	return *v, true
}

// ClearTimeout clears the value of the "timeout" field.
func (m *ActivityDataMutation) ClearTimeout() {
	m.timeout = nil
	m.addtimeout = nil
	m.clearedFields[activitydata.FieldTimeout] = struct{}{}
}

// TimeoutCleared returns if the "timeout" field was cleared in this mutation.
func (m *ActivityDataMutation) TimeoutCleared() bool {
	_, ok := m.clearedFields[activitydata.FieldTimeout]
	return ok
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *ActivityDataMutation) ResetTimeout() {
	m.timeout = nil
	m.addtimeout = nil
	delete(m.clearedFields, activitydata.FieldTimeout)
}

// SetMaxAttempts sets the "max_attempts" field.
func (m *ActivityDataMutation) SetMaxAttempts(i int) {
	m.max_attempts = &i
	m.addmax_attempts = nil
}

// MaxAttempts returns the value of the "max_attempts" field in the mutation.
func (m *ActivityDataMutation) MaxAttempts() (r int, exists bool) {
	v := m.max_attempts
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxAttempts returns the old "max_attempts" field's value of the ActivityData entity.
// If the ActivityData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityDataMutation) OldMaxAttempts(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxAttempts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxAttempts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxAttempts: %w", err)
	}
	return oldValue.MaxAttempts, nil
}

// AddMaxAttempts adds i to the "max_attempts" field.
func (m *ActivityDataMutation) AddMaxAttempts(i int) {
	if m.addmax_attempts != nil {
		*m.addmax_attempts += i
	} else {
		m.addmax_attempts = &i
	}
}

// AddedMaxAttempts returns the value that was added to the "max_attempts" field in this mutation.
func (m *ActivityDataMutation) AddedMaxAttempts() (r int, exists bool) {
	v := m.addmax_attempts
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxAttempts resets all changes to the "max_attempts" field.
func (m *ActivityDataMutation) ResetMaxAttempts() {
	m.max_attempts = nil
	m.addmax_attempts = nil
}

// SetScheduledFor sets the "scheduled_for" field.
func (m *ActivityDataMutation) SetScheduledFor(t time.Time) {
	m.scheduled_for = &t
}

// ScheduledFor returns the value of the "scheduled_for" field in the mutation.
func (m *ActivityDataMutation) ScheduledFor() (r time.Time, exists bool) {
	v := m.scheduled_for
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduledFor returns the old "scheduled_for" field's value of the ActivityData entity.
// If the ActivityData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityDataMutation) OldScheduledFor(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduledFor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduledFor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduledFor: %w", err)
	}
	return oldValue.ScheduledFor, nil
}

// ClearScheduledFor clears the value of the "scheduled_for" field.
func (m *ActivityDataMutation) ClearScheduledFor() {
	m.scheduled_for = nil
	m.clearedFields[activitydata.FieldScheduledFor] = struct{}{}
}

// ScheduledForCleared returns if the "scheduled_for" field was cleared in this mutation.
func (m *ActivityDataMutation) ScheduledForCleared() bool {
	_, ok := m.clearedFields[activitydata.FieldScheduledFor]
	return ok
}

// ResetScheduledFor resets all changes to the "scheduled_for" field.
func (m *ActivityDataMutation) ResetScheduledFor() {
	m.scheduled_for = nil
	delete(m.clearedFields, activitydata.FieldScheduledFor)
}

// SetInput sets the "input" field.
func (m *ActivityDataMutation) SetInput(u [][]uint8) {
	m.input = &u
	m.appendinput = nil
}

// Input returns the value of the "input" field in the mutation.
func (m *ActivityDataMutation) Input() (r [][]uint8, exists bool) {
	v := m.input
	if v == nil {
		return
	}
	return *v, true
}

// OldInput returns the old "input" field's value of the ActivityData entity.
// If the ActivityData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityDataMutation) OldInput(ctx context.Context) (v [][]uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInput: %w", err)
	}
	return oldValue.Input, nil
}

// AppendInput adds u to the "input" field.
func (m *ActivityDataMutation) AppendInput(u [][]uint8) {
	m.appendinput = append(m.appendinput, u...)
}

// AppendedInput returns the list of values that were appended to the "input" field in this mutation.
func (m *ActivityDataMutation) AppendedInput() ([][]uint8, bool) {
	if len(m.appendinput) == 0 {
		return nil, false
	}
	return m.appendinput, true
}

// ClearInput clears the value of the "input" field.
func (m *ActivityDataMutation) ClearInput() {
	m.input = nil
	m.appendinput = nil
	m.clearedFields[activitydata.FieldInput] = struct{}{}
}

// InputCleared returns if the "input" field was cleared in this mutation.
func (m *ActivityDataMutation) InputCleared() bool {
	_, ok := m.clearedFields[activitydata.FieldInput]
	return ok
}

// ResetInput resets all changes to the "input" field.
func (m *ActivityDataMutation) ResetInput() {
	m.input = nil
	m.appendinput = nil
	delete(m.clearedFields, activitydata.FieldInput)
}

// SetOutput sets the "output" field.
func (m *ActivityDataMutation) SetOutput(u [][]uint8) {
	m.output = &u
	m.appendoutput = nil
}

// Output returns the value of the "output" field in the mutation.
func (m *ActivityDataMutation) Output() (r [][]uint8, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the ActivityData entity.
// If the ActivityData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityDataMutation) OldOutput(ctx context.Context) (v [][]uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// AppendOutput adds u to the "output" field.
func (m *ActivityDataMutation) AppendOutput(u [][]uint8) {
	m.appendoutput = append(m.appendoutput, u...)
}

// AppendedOutput returns the list of values that were appended to the "output" field in this mutation.
func (m *ActivityDataMutation) AppendedOutput() ([][]uint8, bool) {
	if len(m.appendoutput) == 0 {
		return nil, false
	}
	return m.appendoutput, true
}

// ClearOutput clears the value of the "output" field.
func (m *ActivityDataMutation) ClearOutput() {
	m.output = nil
	m.appendoutput = nil
	m.clearedFields[activitydata.FieldOutput] = struct{}{}
}

// OutputCleared returns if the "output" field was cleared in this mutation.
func (m *ActivityDataMutation) OutputCleared() bool {
	_, ok := m.clearedFields[activitydata.FieldOutput]
	return ok
}

// ResetOutput resets all changes to the "output" field.
func (m *ActivityDataMutation) ResetOutput() {
	m.output = nil
	m.appendoutput = nil
	delete(m.clearedFields, activitydata.FieldOutput)
}

// SetAttempt sets the "attempt" field.
func (m *ActivityDataMutation) SetAttempt(i int) {
	m.attempt = &i
	m.addattempt = nil
}

// Attempt returns the value of the "attempt" field in the mutation.
func (m *ActivityDataMutation) Attempt() (r int, exists bool) {
	v := m.attempt
	if v == nil {
		return
	}
	return *v, true
}

// OldAttempt returns the old "attempt" field's value of the ActivityData entity.
// If the ActivityData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityDataMutation) OldAttempt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttempt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttempt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttempt: %w", err)
	}
	return oldValue.Attempt, nil
}

// AddAttempt adds i to the "attempt" field.
func (m *ActivityDataMutation) AddAttempt(i int) {
	if m.addattempt != nil {
		*m.addattempt += i
	} else {
		m.addattempt = &i
	}
}

// AddedAttempt returns the value that was added to the "attempt" field in this mutation.
func (m *ActivityDataMutation) AddedAttempt() (r int, exists bool) {
	v := m.addattempt
	if v == nil {
		return
	}
	return *v, true
}

// ResetAttempt resets all changes to the "attempt" field.
func (m *ActivityDataMutation) ResetAttempt() {
	m.attempt = nil
	m.addattempt = nil
}

// SetEntityID sets the "entity" edge to the Entity entity by id.
func (m *ActivityDataMutation) SetEntityID(id int) {
	m.entity = &id
}

// ClearEntity clears the "entity" edge to the Entity entity.
func (m *ActivityDataMutation) ClearEntity() {
	m.clearedentity = true
}

// EntityCleared reports if the "entity" edge to the Entity entity was cleared.
func (m *ActivityDataMutation) EntityCleared() bool {
	return m.clearedentity
}

// EntityID returns the "entity" edge ID in the mutation.
func (m *ActivityDataMutation) EntityID() (id int, exists bool) {
	if m.entity != nil {
		return *m.entity, true
	}
	return
}

// EntityIDs returns the "entity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntityID instead. It exists only for internal usage by the builders.
func (m *ActivityDataMutation) EntityIDs() (ids []int) {
	if id := m.entity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntity resets all changes to the "entity" edge.
func (m *ActivityDataMutation) ResetEntity() {
	m.entity = nil
	m.clearedentity = false
}

// Where appends a list predicates to the ActivityDataMutation builder.
func (m *ActivityDataMutation) Where(ps ...predicate.ActivityData) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ActivityDataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ActivityDataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ActivityData, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ActivityDataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ActivityDataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ActivityData).
func (m *ActivityDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActivityDataMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.timeout != nil {
		fields = append(fields, activitydata.FieldTimeout)
	}
	if m.max_attempts != nil {
		fields = append(fields, activitydata.FieldMaxAttempts)
	}
	if m.scheduled_for != nil {
		fields = append(fields, activitydata.FieldScheduledFor)
	}
	if m.input != nil {
		fields = append(fields, activitydata.FieldInput)
	}
	if m.output != nil {
		fields = append(fields, activitydata.FieldOutput)
	}
	if m.attempt != nil {
		fields = append(fields, activitydata.FieldAttempt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActivityDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case activitydata.FieldTimeout:
		return m.Timeout()
	case activitydata.FieldMaxAttempts:
		return m.MaxAttempts()
	case activitydata.FieldScheduledFor:
		return m.ScheduledFor()
	case activitydata.FieldInput:
		return m.Input()
	case activitydata.FieldOutput:
		return m.Output()
	case activitydata.FieldAttempt:
		return m.Attempt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActivityDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case activitydata.FieldTimeout:
		return m.OldTimeout(ctx)
	case activitydata.FieldMaxAttempts:
		return m.OldMaxAttempts(ctx)
	case activitydata.FieldScheduledFor:
		return m.OldScheduledFor(ctx)
	case activitydata.FieldInput:
		return m.OldInput(ctx)
	case activitydata.FieldOutput:
		return m.OldOutput(ctx)
	case activitydata.FieldAttempt:
		return m.OldAttempt(ctx)
	}
	return nil, fmt.Errorf("unknown ActivityData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case activitydata.FieldTimeout:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case activitydata.FieldMaxAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxAttempts(v)
		return nil
	case activitydata.FieldScheduledFor:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduledFor(v)
		return nil
	case activitydata.FieldInput:
		v, ok := value.([][]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInput(v)
		return nil
	case activitydata.FieldOutput:
		v, ok := value.([][]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case activitydata.FieldAttempt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttempt(v)
		return nil
	}
	return fmt.Errorf("unknown ActivityData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActivityDataMutation) AddedFields() []string {
	var fields []string
	if m.addtimeout != nil {
		fields = append(fields, activitydata.FieldTimeout)
	}
	if m.addmax_attempts != nil {
		fields = append(fields, activitydata.FieldMaxAttempts)
	}
	if m.addattempt != nil {
		fields = append(fields, activitydata.FieldAttempt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActivityDataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case activitydata.FieldTimeout:
		return m.AddedTimeout()
	case activitydata.FieldMaxAttempts:
		return m.AddedMaxAttempts()
	case activitydata.FieldAttempt:
		return m.AddedAttempt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	case activitydata.FieldTimeout:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeout(v)
		return nil
	case activitydata.FieldMaxAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxAttempts(v)
		return nil
	case activitydata.FieldAttempt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAttempt(v)
		return nil
	}
	return fmt.Errorf("unknown ActivityData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActivityDataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(activitydata.FieldTimeout) {
		fields = append(fields, activitydata.FieldTimeout)
	}
	if m.FieldCleared(activitydata.FieldScheduledFor) {
		fields = append(fields, activitydata.FieldScheduledFor)
	}
	if m.FieldCleared(activitydata.FieldInput) {
		fields = append(fields, activitydata.FieldInput)
	}
	if m.FieldCleared(activitydata.FieldOutput) {
		fields = append(fields, activitydata.FieldOutput)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActivityDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActivityDataMutation) ClearField(name string) error {
	switch name {
	case activitydata.FieldTimeout:
		m.ClearTimeout()
		return nil
	case activitydata.FieldScheduledFor:
		m.ClearScheduledFor()
		return nil
	case activitydata.FieldInput:
		m.ClearInput()
		return nil
	case activitydata.FieldOutput:
		m.ClearOutput()
		return nil
	}
	return fmt.Errorf("unknown ActivityData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActivityDataMutation) ResetField(name string) error {
	switch name {
	case activitydata.FieldTimeout:
		m.ResetTimeout()
		return nil
	case activitydata.FieldMaxAttempts:
		m.ResetMaxAttempts()
		return nil
	case activitydata.FieldScheduledFor:
		m.ResetScheduledFor()
		return nil
	case activitydata.FieldInput:
		m.ResetInput()
		return nil
	case activitydata.FieldOutput:
		m.ResetOutput()
		return nil
	case activitydata.FieldAttempt:
		m.ResetAttempt()
		return nil
	}
	return fmt.Errorf("unknown ActivityData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActivityDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.entity != nil {
		edges = append(edges, activitydata.EdgeEntity)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActivityDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case activitydata.EdgeEntity:
		if id := m.entity; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActivityDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActivityDataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActivityDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedentity {
		edges = append(edges, activitydata.EdgeEntity)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActivityDataMutation) EdgeCleared(name string) bool {
	switch name {
	case activitydata.EdgeEntity:
		return m.clearedentity
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActivityDataMutation) ClearEdge(name string) error {
	switch name {
	case activitydata.EdgeEntity:
		m.ClearEntity()
		return nil
	}
	return fmt.Errorf("unknown ActivityData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActivityDataMutation) ResetEdge(name string) error {
	switch name {
	case activitydata.EdgeEntity:
		m.ResetEntity()
		return nil
	}
	return fmt.Errorf("unknown ActivityData edge %s", name)
}

// ActivityExecutionMutation represents an operation that mutates the ActivityExecution nodes in the graph.
type ActivityExecutionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	inputs                *[][]uint8
	appendinputs          [][]uint8
	clearedFields         map[string]struct{}
	execution             *int
	clearedexecution      bool
	execution_data        *int
	clearedexecution_data bool
	done                  bool
	oldValue              func(context.Context) (*ActivityExecution, error)
	predicates            []predicate.ActivityExecution
}

var _ ent.Mutation = (*ActivityExecutionMutation)(nil)

// activityexecutionOption allows management of the mutation configuration using functional options.
type activityexecutionOption func(*ActivityExecutionMutation)

// newActivityExecutionMutation creates new mutation for the ActivityExecution entity.
func newActivityExecutionMutation(c config, op Op, opts ...activityexecutionOption) *ActivityExecutionMutation {
	m := &ActivityExecutionMutation{
		config:        c,
		op:            op,
		typ:           TypeActivityExecution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActivityExecutionID sets the ID field of the mutation.
func withActivityExecutionID(id int) activityexecutionOption {
	return func(m *ActivityExecutionMutation) {
		var (
			err   error
			once  sync.Once
			value *ActivityExecution
		)
		m.oldValue = func(ctx context.Context) (*ActivityExecution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ActivityExecution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActivityExecution sets the old ActivityExecution of the mutation.
func withActivityExecution(node *ActivityExecution) activityexecutionOption {
	return func(m *ActivityExecutionMutation) {
		m.oldValue = func(context.Context) (*ActivityExecution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActivityExecutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActivityExecutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActivityExecutionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActivityExecutionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ActivityExecution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInputs sets the "inputs" field.
func (m *ActivityExecutionMutation) SetInputs(u [][]uint8) {
	m.inputs = &u
	m.appendinputs = nil
}

// Inputs returns the value of the "inputs" field in the mutation.
func (m *ActivityExecutionMutation) Inputs() (r [][]uint8, exists bool) {
	v := m.inputs
	if v == nil {
		return
	}
	return *v, true
}

// OldInputs returns the old "inputs" field's value of the ActivityExecution entity.
// If the ActivityExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityExecutionMutation) OldInputs(ctx context.Context) (v [][]uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInputs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInputs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInputs: %w", err)
	}
	return oldValue.Inputs, nil
}

// AppendInputs adds u to the "inputs" field.
func (m *ActivityExecutionMutation) AppendInputs(u [][]uint8) {
	m.appendinputs = append(m.appendinputs, u...)
}

// AppendedInputs returns the list of values that were appended to the "inputs" field in this mutation.
func (m *ActivityExecutionMutation) AppendedInputs() ([][]uint8, bool) {
	if len(m.appendinputs) == 0 {
		return nil, false
	}
	return m.appendinputs, true
}

// ClearInputs clears the value of the "inputs" field.
func (m *ActivityExecutionMutation) ClearInputs() {
	m.inputs = nil
	m.appendinputs = nil
	m.clearedFields[activityexecution.FieldInputs] = struct{}{}
}

// InputsCleared returns if the "inputs" field was cleared in this mutation.
func (m *ActivityExecutionMutation) InputsCleared() bool {
	_, ok := m.clearedFields[activityexecution.FieldInputs]
	return ok
}

// ResetInputs resets all changes to the "inputs" field.
func (m *ActivityExecutionMutation) ResetInputs() {
	m.inputs = nil
	m.appendinputs = nil
	delete(m.clearedFields, activityexecution.FieldInputs)
}

// SetExecutionID sets the "execution" edge to the Execution entity by id.
func (m *ActivityExecutionMutation) SetExecutionID(id int) {
	m.execution = &id
}

// ClearExecution clears the "execution" edge to the Execution entity.
func (m *ActivityExecutionMutation) ClearExecution() {
	m.clearedexecution = true
}

// ExecutionCleared reports if the "execution" edge to the Execution entity was cleared.
func (m *ActivityExecutionMutation) ExecutionCleared() bool {
	return m.clearedexecution
}

// ExecutionID returns the "execution" edge ID in the mutation.
func (m *ActivityExecutionMutation) ExecutionID() (id int, exists bool) {
	if m.execution != nil {
		return *m.execution, true
	}
	return
}

// ExecutionIDs returns the "execution" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExecutionID instead. It exists only for internal usage by the builders.
func (m *ActivityExecutionMutation) ExecutionIDs() (ids []int) {
	if id := m.execution; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExecution resets all changes to the "execution" edge.
func (m *ActivityExecutionMutation) ResetExecution() {
	m.execution = nil
	m.clearedexecution = false
}

// SetExecutionDataID sets the "execution_data" edge to the ActivityExecutionData entity by id.
func (m *ActivityExecutionMutation) SetExecutionDataID(id int) {
	m.execution_data = &id
}

// ClearExecutionData clears the "execution_data" edge to the ActivityExecutionData entity.
func (m *ActivityExecutionMutation) ClearExecutionData() {
	m.clearedexecution_data = true
}

// ExecutionDataCleared reports if the "execution_data" edge to the ActivityExecutionData entity was cleared.
func (m *ActivityExecutionMutation) ExecutionDataCleared() bool {
	return m.clearedexecution_data
}

// ExecutionDataID returns the "execution_data" edge ID in the mutation.
func (m *ActivityExecutionMutation) ExecutionDataID() (id int, exists bool) {
	if m.execution_data != nil {
		return *m.execution_data, true
	}
	return
}

// ExecutionDataIDs returns the "execution_data" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExecutionDataID instead. It exists only for internal usage by the builders.
func (m *ActivityExecutionMutation) ExecutionDataIDs() (ids []int) {
	if id := m.execution_data; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExecutionData resets all changes to the "execution_data" edge.
func (m *ActivityExecutionMutation) ResetExecutionData() {
	m.execution_data = nil
	m.clearedexecution_data = false
}

// Where appends a list predicates to the ActivityExecutionMutation builder.
func (m *ActivityExecutionMutation) Where(ps ...predicate.ActivityExecution) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ActivityExecutionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ActivityExecutionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ActivityExecution, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ActivityExecutionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ActivityExecutionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ActivityExecution).
func (m *ActivityExecutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActivityExecutionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.inputs != nil {
		fields = append(fields, activityexecution.FieldInputs)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActivityExecutionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case activityexecution.FieldInputs:
		return m.Inputs()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActivityExecutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case activityexecution.FieldInputs:
		return m.OldInputs(ctx)
	}
	return nil, fmt.Errorf("unknown ActivityExecution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityExecutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case activityexecution.FieldInputs:
		v, ok := value.([][]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInputs(v)
		return nil
	}
	return fmt.Errorf("unknown ActivityExecution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActivityExecutionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActivityExecutionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityExecutionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ActivityExecution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActivityExecutionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(activityexecution.FieldInputs) {
		fields = append(fields, activityexecution.FieldInputs)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActivityExecutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActivityExecutionMutation) ClearField(name string) error {
	switch name {
	case activityexecution.FieldInputs:
		m.ClearInputs()
		return nil
	}
	return fmt.Errorf("unknown ActivityExecution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActivityExecutionMutation) ResetField(name string) error {
	switch name {
	case activityexecution.FieldInputs:
		m.ResetInputs()
		return nil
	}
	return fmt.Errorf("unknown ActivityExecution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActivityExecutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.execution != nil {
		edges = append(edges, activityexecution.EdgeExecution)
	}
	if m.execution_data != nil {
		edges = append(edges, activityexecution.EdgeExecutionData)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActivityExecutionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case activityexecution.EdgeExecution:
		if id := m.execution; id != nil {
			return []ent.Value{*id}
		}
	case activityexecution.EdgeExecutionData:
		if id := m.execution_data; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActivityExecutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActivityExecutionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActivityExecutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedexecution {
		edges = append(edges, activityexecution.EdgeExecution)
	}
	if m.clearedexecution_data {
		edges = append(edges, activityexecution.EdgeExecutionData)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActivityExecutionMutation) EdgeCleared(name string) bool {
	switch name {
	case activityexecution.EdgeExecution:
		return m.clearedexecution
	case activityexecution.EdgeExecutionData:
		return m.clearedexecution_data
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActivityExecutionMutation) ClearEdge(name string) error {
	switch name {
	case activityexecution.EdgeExecution:
		m.ClearExecution()
		return nil
	case activityexecution.EdgeExecutionData:
		m.ClearExecutionData()
		return nil
	}
	return fmt.Errorf("unknown ActivityExecution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActivityExecutionMutation) ResetEdge(name string) error {
	switch name {
	case activityexecution.EdgeExecution:
		m.ResetExecution()
		return nil
	case activityexecution.EdgeExecutionData:
		m.ResetExecutionData()
		return nil
	}
	return fmt.Errorf("unknown ActivityExecution edge %s", name)
}

// ActivityExecutionDataMutation represents an operation that mutates the ActivityExecutionData nodes in the graph.
type ActivityExecutionDataMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	last_heartbeat            *time.Time
	outputs                   *[][]uint8
	appendoutputs             [][]uint8
	clearedFields             map[string]struct{}
	activity_execution        *int
	clearedactivity_execution bool
	done                      bool
	oldValue                  func(context.Context) (*ActivityExecutionData, error)
	predicates                []predicate.ActivityExecutionData
}

var _ ent.Mutation = (*ActivityExecutionDataMutation)(nil)

// activityexecutiondataOption allows management of the mutation configuration using functional options.
type activityexecutiondataOption func(*ActivityExecutionDataMutation)

// newActivityExecutionDataMutation creates new mutation for the ActivityExecutionData entity.
func newActivityExecutionDataMutation(c config, op Op, opts ...activityexecutiondataOption) *ActivityExecutionDataMutation {
	m := &ActivityExecutionDataMutation{
		config:        c,
		op:            op,
		typ:           TypeActivityExecutionData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActivityExecutionDataID sets the ID field of the mutation.
func withActivityExecutionDataID(id int) activityexecutiondataOption {
	return func(m *ActivityExecutionDataMutation) {
		var (
			err   error
			once  sync.Once
			value *ActivityExecutionData
		)
		m.oldValue = func(ctx context.Context) (*ActivityExecutionData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ActivityExecutionData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActivityExecutionData sets the old ActivityExecutionData of the mutation.
func withActivityExecutionData(node *ActivityExecutionData) activityexecutiondataOption {
	return func(m *ActivityExecutionDataMutation) {
		m.oldValue = func(context.Context) (*ActivityExecutionData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActivityExecutionDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActivityExecutionDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActivityExecutionDataMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActivityExecutionDataMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ActivityExecutionData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLastHeartbeat sets the "last_heartbeat" field.
func (m *ActivityExecutionDataMutation) SetLastHeartbeat(t time.Time) {
	m.last_heartbeat = &t
}

// LastHeartbeat returns the value of the "last_heartbeat" field in the mutation.
func (m *ActivityExecutionDataMutation) LastHeartbeat() (r time.Time, exists bool) {
	v := m.last_heartbeat
	if v == nil {
		return
	}
	return *v, true
}

// OldLastHeartbeat returns the old "last_heartbeat" field's value of the ActivityExecutionData entity.
// If the ActivityExecutionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityExecutionDataMutation) OldLastHeartbeat(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastHeartbeat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastHeartbeat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastHeartbeat: %w", err)
	}
	return oldValue.LastHeartbeat, nil
}

// ClearLastHeartbeat clears the value of the "last_heartbeat" field.
func (m *ActivityExecutionDataMutation) ClearLastHeartbeat() {
	m.last_heartbeat = nil
	m.clearedFields[activityexecutiondata.FieldLastHeartbeat] = struct{}{}
}

// LastHeartbeatCleared returns if the "last_heartbeat" field was cleared in this mutation.
func (m *ActivityExecutionDataMutation) LastHeartbeatCleared() bool {
	_, ok := m.clearedFields[activityexecutiondata.FieldLastHeartbeat]
	return ok
}

// ResetLastHeartbeat resets all changes to the "last_heartbeat" field.
func (m *ActivityExecutionDataMutation) ResetLastHeartbeat() {
	m.last_heartbeat = nil
	delete(m.clearedFields, activityexecutiondata.FieldLastHeartbeat)
}

// SetOutputs sets the "outputs" field.
func (m *ActivityExecutionDataMutation) SetOutputs(u [][]uint8) {
	m.outputs = &u
	m.appendoutputs = nil
}

// Outputs returns the value of the "outputs" field in the mutation.
func (m *ActivityExecutionDataMutation) Outputs() (r [][]uint8, exists bool) {
	v := m.outputs
	if v == nil {
		return
	}
	return *v, true
}

// OldOutputs returns the old "outputs" field's value of the ActivityExecutionData entity.
// If the ActivityExecutionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityExecutionDataMutation) OldOutputs(ctx context.Context) (v [][]uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutputs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutputs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutputs: %w", err)
	}
	return oldValue.Outputs, nil
}

// AppendOutputs adds u to the "outputs" field.
func (m *ActivityExecutionDataMutation) AppendOutputs(u [][]uint8) {
	m.appendoutputs = append(m.appendoutputs, u...)
}

// AppendedOutputs returns the list of values that were appended to the "outputs" field in this mutation.
func (m *ActivityExecutionDataMutation) AppendedOutputs() ([][]uint8, bool) {
	if len(m.appendoutputs) == 0 {
		return nil, false
	}
	return m.appendoutputs, true
}

// ClearOutputs clears the value of the "outputs" field.
func (m *ActivityExecutionDataMutation) ClearOutputs() {
	m.outputs = nil
	m.appendoutputs = nil
	m.clearedFields[activityexecutiondata.FieldOutputs] = struct{}{}
}

// OutputsCleared returns if the "outputs" field was cleared in this mutation.
func (m *ActivityExecutionDataMutation) OutputsCleared() bool {
	_, ok := m.clearedFields[activityexecutiondata.FieldOutputs]
	return ok
}

// ResetOutputs resets all changes to the "outputs" field.
func (m *ActivityExecutionDataMutation) ResetOutputs() {
	m.outputs = nil
	m.appendoutputs = nil
	delete(m.clearedFields, activityexecutiondata.FieldOutputs)
}

// SetActivityExecutionID sets the "activity_execution" edge to the ActivityExecution entity by id.
func (m *ActivityExecutionDataMutation) SetActivityExecutionID(id int) {
	m.activity_execution = &id
}

// ClearActivityExecution clears the "activity_execution" edge to the ActivityExecution entity.
func (m *ActivityExecutionDataMutation) ClearActivityExecution() {
	m.clearedactivity_execution = true
}

// ActivityExecutionCleared reports if the "activity_execution" edge to the ActivityExecution entity was cleared.
func (m *ActivityExecutionDataMutation) ActivityExecutionCleared() bool {
	return m.clearedactivity_execution
}

// ActivityExecutionID returns the "activity_execution" edge ID in the mutation.
func (m *ActivityExecutionDataMutation) ActivityExecutionID() (id int, exists bool) {
	if m.activity_execution != nil {
		return *m.activity_execution, true
	}
	return
}

// ActivityExecutionIDs returns the "activity_execution" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActivityExecutionID instead. It exists only for internal usage by the builders.
func (m *ActivityExecutionDataMutation) ActivityExecutionIDs() (ids []int) {
	if id := m.activity_execution; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActivityExecution resets all changes to the "activity_execution" edge.
func (m *ActivityExecutionDataMutation) ResetActivityExecution() {
	m.activity_execution = nil
	m.clearedactivity_execution = false
}

// Where appends a list predicates to the ActivityExecutionDataMutation builder.
func (m *ActivityExecutionDataMutation) Where(ps ...predicate.ActivityExecutionData) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ActivityExecutionDataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ActivityExecutionDataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ActivityExecutionData, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ActivityExecutionDataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ActivityExecutionDataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ActivityExecutionData).
func (m *ActivityExecutionDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActivityExecutionDataMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.last_heartbeat != nil {
		fields = append(fields, activityexecutiondata.FieldLastHeartbeat)
	}
	if m.outputs != nil {
		fields = append(fields, activityexecutiondata.FieldOutputs)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActivityExecutionDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case activityexecutiondata.FieldLastHeartbeat:
		return m.LastHeartbeat()
	case activityexecutiondata.FieldOutputs:
		return m.Outputs()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActivityExecutionDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case activityexecutiondata.FieldLastHeartbeat:
		return m.OldLastHeartbeat(ctx)
	case activityexecutiondata.FieldOutputs:
		return m.OldOutputs(ctx)
	}
	return nil, fmt.Errorf("unknown ActivityExecutionData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityExecutionDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case activityexecutiondata.FieldLastHeartbeat:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastHeartbeat(v)
		return nil
	case activityexecutiondata.FieldOutputs:
		v, ok := value.([][]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutputs(v)
		return nil
	}
	return fmt.Errorf("unknown ActivityExecutionData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActivityExecutionDataMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActivityExecutionDataMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityExecutionDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ActivityExecutionData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActivityExecutionDataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(activityexecutiondata.FieldLastHeartbeat) {
		fields = append(fields, activityexecutiondata.FieldLastHeartbeat)
	}
	if m.FieldCleared(activityexecutiondata.FieldOutputs) {
		fields = append(fields, activityexecutiondata.FieldOutputs)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActivityExecutionDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActivityExecutionDataMutation) ClearField(name string) error {
	switch name {
	case activityexecutiondata.FieldLastHeartbeat:
		m.ClearLastHeartbeat()
		return nil
	case activityexecutiondata.FieldOutputs:
		m.ClearOutputs()
		return nil
	}
	return fmt.Errorf("unknown ActivityExecutionData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActivityExecutionDataMutation) ResetField(name string) error {
	switch name {
	case activityexecutiondata.FieldLastHeartbeat:
		m.ResetLastHeartbeat()
		return nil
	case activityexecutiondata.FieldOutputs:
		m.ResetOutputs()
		return nil
	}
	return fmt.Errorf("unknown ActivityExecutionData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActivityExecutionDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.activity_execution != nil {
		edges = append(edges, activityexecutiondata.EdgeActivityExecution)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActivityExecutionDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case activityexecutiondata.EdgeActivityExecution:
		if id := m.activity_execution; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActivityExecutionDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActivityExecutionDataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActivityExecutionDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedactivity_execution {
		edges = append(edges, activityexecutiondata.EdgeActivityExecution)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActivityExecutionDataMutation) EdgeCleared(name string) bool {
	switch name {
	case activityexecutiondata.EdgeActivityExecution:
		return m.clearedactivity_execution
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActivityExecutionDataMutation) ClearEdge(name string) error {
	switch name {
	case activityexecutiondata.EdgeActivityExecution:
		m.ClearActivityExecution()
		return nil
	}
	return fmt.Errorf("unknown ActivityExecutionData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActivityExecutionDataMutation) ResetEdge(name string) error {
	switch name {
	case activityexecutiondata.EdgeActivityExecution:
		m.ResetActivityExecution()
		return nil
	}
	return fmt.Errorf("unknown ActivityExecutionData edge %s", name)
}

// EntityMutation represents an operation that mutates the Entity nodes in the graph.
type EntityMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	created_at              *time.Time
	updated_at              *time.Time
	handler_name            *string
	_type                   *entity.Type
	retry_state             **schema.RetryState
	retry_policy            **schema.RetryPolicy
	status                  *entity.Status
	step_id                 *string
	clearedFields           map[string]struct{}
	run                     *int
	clearedrun              bool
	executions              map[int]struct{}
	removedexecutions       map[int]struct{}
	clearedexecutions       bool
	queue                   *int
	clearedqueue            bool
	versions                map[int]struct{}
	removedversions         map[int]struct{}
	clearedversions         bool
	workflow_data           *int
	clearedworkflow_data    bool
	activity_data           *int
	clearedactivity_data    bool
	saga_data               *int
	clearedsaga_data        bool
	side_effect_data        *int
	clearedside_effect_data bool
	done                    bool
	oldValue                func(context.Context) (*Entity, error)
	predicates              []predicate.Entity
}

var _ ent.Mutation = (*EntityMutation)(nil)

// entityOption allows management of the mutation configuration using functional options.
type entityOption func(*EntityMutation)

// newEntityMutation creates new mutation for the Entity entity.
func newEntityMutation(c config, op Op, opts ...entityOption) *EntityMutation {
	m := &EntityMutation{
		config:        c,
		op:            op,
		typ:           TypeEntity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntityID sets the ID field of the mutation.
func withEntityID(id int) entityOption {
	return func(m *EntityMutation) {
		var (
			err   error
			once  sync.Once
			value *Entity
		)
		m.oldValue = func(ctx context.Context) (*Entity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Entity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntity sets the old Entity of the mutation.
func withEntity(node *Entity) entityOption {
	return func(m *EntityMutation) {
		m.oldValue = func(context.Context) (*Entity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntityMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Entity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EntityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EntityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EntityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EntityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EntityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EntityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetHandlerName sets the "handler_name" field.
func (m *EntityMutation) SetHandlerName(s string) {
	m.handler_name = &s
}

// HandlerName returns the value of the "handler_name" field in the mutation.
func (m *EntityMutation) HandlerName() (r string, exists bool) {
	v := m.handler_name
	if v == nil {
		return
	}
	return *v, true
}

// OldHandlerName returns the old "handler_name" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldHandlerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandlerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandlerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandlerName: %w", err)
	}
	return oldValue.HandlerName, nil
}

// ResetHandlerName resets all changes to the "handler_name" field.
func (m *EntityMutation) ResetHandlerName() {
	m.handler_name = nil
}

// SetType sets the "type" field.
func (m *EntityMutation) SetType(e entity.Type) {
	m._type = &e
}

// GetType returns the value of the "type" field in the mutation.
func (m *EntityMutation) GetType() (r entity.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldType(ctx context.Context) (v entity.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *EntityMutation) ResetType() {
	m._type = nil
}

// SetRetryState sets the "retry_state" field.
func (m *EntityMutation) SetRetryState(ss *schema.RetryState) {
	m.retry_state = &ss
}

// RetryState returns the value of the "retry_state" field in the mutation.
func (m *EntityMutation) RetryState() (r *schema.RetryState, exists bool) {
	v := m.retry_state
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryState returns the old "retry_state" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldRetryState(ctx context.Context) (v *schema.RetryState, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryState: %w", err)
	}
	return oldValue.RetryState, nil
}

// ResetRetryState resets all changes to the "retry_state" field.
func (m *EntityMutation) ResetRetryState() {
	m.retry_state = nil
}

// SetRetryPolicy sets the "retry_policy" field.
func (m *EntityMutation) SetRetryPolicy(sp *schema.RetryPolicy) {
	m.retry_policy = &sp
}

// RetryPolicy returns the value of the "retry_policy" field in the mutation.
func (m *EntityMutation) RetryPolicy() (r *schema.RetryPolicy, exists bool) {
	v := m.retry_policy
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryPolicy returns the old "retry_policy" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldRetryPolicy(ctx context.Context) (v *schema.RetryPolicy, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryPolicy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryPolicy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryPolicy: %w", err)
	}
	return oldValue.RetryPolicy, nil
}

// ResetRetryPolicy resets all changes to the "retry_policy" field.
func (m *EntityMutation) ResetRetryPolicy() {
	m.retry_policy = nil
}

// SetStatus sets the "status" field.
func (m *EntityMutation) SetStatus(e entity.Status) {
	m.status = &e
}

// Status returns the value of the "status" field in the mutation.
func (m *EntityMutation) Status() (r entity.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldStatus(ctx context.Context) (v entity.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *EntityMutation) ResetStatus() {
	m.status = nil
}

// SetStepID sets the "step_id" field.
func (m *EntityMutation) SetStepID(s string) {
	m.step_id = &s
}

// StepID returns the value of the "step_id" field in the mutation.
func (m *EntityMutation) StepID() (r string, exists bool) {
	v := m.step_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStepID returns the old "step_id" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldStepID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStepID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStepID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStepID: %w", err)
	}
	return oldValue.StepID, nil
}

// ResetStepID resets all changes to the "step_id" field.
func (m *EntityMutation) ResetStepID() {
	m.step_id = nil
}

// SetRunID sets the "run" edge to the Run entity by id.
func (m *EntityMutation) SetRunID(id int) {
	m.run = &id
}

// ClearRun clears the "run" edge to the Run entity.
func (m *EntityMutation) ClearRun() {
	m.clearedrun = true
}

// RunCleared reports if the "run" edge to the Run entity was cleared.
func (m *EntityMutation) RunCleared() bool {
	return m.clearedrun
}

// RunID returns the "run" edge ID in the mutation.
func (m *EntityMutation) RunID() (id int, exists bool) {
	if m.run != nil {
		return *m.run, true
	}
	return
}

// RunIDs returns the "run" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RunID instead. It exists only for internal usage by the builders.
func (m *EntityMutation) RunIDs() (ids []int) {
	if id := m.run; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRun resets all changes to the "run" edge.
func (m *EntityMutation) ResetRun() {
	m.run = nil
	m.clearedrun = false
}

// AddExecutionIDs adds the "executions" edge to the Execution entity by ids.
func (m *EntityMutation) AddExecutionIDs(ids ...int) {
	if m.executions == nil {
		m.executions = make(map[int]struct{})
	}
	for i := range ids {
		m.executions[ids[i]] = struct{}{}
	}
}

// ClearExecutions clears the "executions" edge to the Execution entity.
func (m *EntityMutation) ClearExecutions() {
	m.clearedexecutions = true
}

// ExecutionsCleared reports if the "executions" edge to the Execution entity was cleared.
func (m *EntityMutation) ExecutionsCleared() bool {
	return m.clearedexecutions
}

// RemoveExecutionIDs removes the "executions" edge to the Execution entity by IDs.
func (m *EntityMutation) RemoveExecutionIDs(ids ...int) {
	if m.removedexecutions == nil {
		m.removedexecutions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.executions, ids[i])
		m.removedexecutions[ids[i]] = struct{}{}
	}
}

// RemovedExecutions returns the removed IDs of the "executions" edge to the Execution entity.
func (m *EntityMutation) RemovedExecutionsIDs() (ids []int) {
	for id := range m.removedexecutions {
		ids = append(ids, id)
	}
	return
}

// ExecutionsIDs returns the "executions" edge IDs in the mutation.
func (m *EntityMutation) ExecutionsIDs() (ids []int) {
	for id := range m.executions {
		ids = append(ids, id)
	}
	return
}

// ResetExecutions resets all changes to the "executions" edge.
func (m *EntityMutation) ResetExecutions() {
	m.executions = nil
	m.clearedexecutions = false
	m.removedexecutions = nil
}

// SetQueueID sets the "queue" edge to the Queue entity by id.
func (m *EntityMutation) SetQueueID(id int) {
	m.queue = &id
}

// ClearQueue clears the "queue" edge to the Queue entity.
func (m *EntityMutation) ClearQueue() {
	m.clearedqueue = true
}

// QueueCleared reports if the "queue" edge to the Queue entity was cleared.
func (m *EntityMutation) QueueCleared() bool {
	return m.clearedqueue
}

// QueueID returns the "queue" edge ID in the mutation.
func (m *EntityMutation) QueueID() (id int, exists bool) {
	if m.queue != nil {
		return *m.queue, true
	}
	return
}

// QueueIDs returns the "queue" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// QueueID instead. It exists only for internal usage by the builders.
func (m *EntityMutation) QueueIDs() (ids []int) {
	if id := m.queue; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetQueue resets all changes to the "queue" edge.
func (m *EntityMutation) ResetQueue() {
	m.queue = nil
	m.clearedqueue = false
}

// AddVersionIDs adds the "versions" edge to the Version entity by ids.
func (m *EntityMutation) AddVersionIDs(ids ...int) {
	if m.versions == nil {
		m.versions = make(map[int]struct{})
	}
	for i := range ids {
		m.versions[ids[i]] = struct{}{}
	}
}

// ClearVersions clears the "versions" edge to the Version entity.
func (m *EntityMutation) ClearVersions() {
	m.clearedversions = true
}

// VersionsCleared reports if the "versions" edge to the Version entity was cleared.
func (m *EntityMutation) VersionsCleared() bool {
	return m.clearedversions
}

// RemoveVersionIDs removes the "versions" edge to the Version entity by IDs.
func (m *EntityMutation) RemoveVersionIDs(ids ...int) {
	if m.removedversions == nil {
		m.removedversions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.versions, ids[i])
		m.removedversions[ids[i]] = struct{}{}
	}
}

// RemovedVersions returns the removed IDs of the "versions" edge to the Version entity.
func (m *EntityMutation) RemovedVersionsIDs() (ids []int) {
	for id := range m.removedversions {
		ids = append(ids, id)
	}
	return
}

// VersionsIDs returns the "versions" edge IDs in the mutation.
func (m *EntityMutation) VersionsIDs() (ids []int) {
	for id := range m.versions {
		ids = append(ids, id)
	}
	return
}

// ResetVersions resets all changes to the "versions" edge.
func (m *EntityMutation) ResetVersions() {
	m.versions = nil
	m.clearedversions = false
	m.removedversions = nil
}

// SetWorkflowDataID sets the "workflow_data" edge to the WorkflowData entity by id.
func (m *EntityMutation) SetWorkflowDataID(id int) {
	m.workflow_data = &id
}

// ClearWorkflowData clears the "workflow_data" edge to the WorkflowData entity.
func (m *EntityMutation) ClearWorkflowData() {
	m.clearedworkflow_data = true
}

// WorkflowDataCleared reports if the "workflow_data" edge to the WorkflowData entity was cleared.
func (m *EntityMutation) WorkflowDataCleared() bool {
	return m.clearedworkflow_data
}

// WorkflowDataID returns the "workflow_data" edge ID in the mutation.
func (m *EntityMutation) WorkflowDataID() (id int, exists bool) {
	if m.workflow_data != nil {
		return *m.workflow_data, true
	}
	return
}

// WorkflowDataIDs returns the "workflow_data" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowDataID instead. It exists only for internal usage by the builders.
func (m *EntityMutation) WorkflowDataIDs() (ids []int) {
	if id := m.workflow_data; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflowData resets all changes to the "workflow_data" edge.
func (m *EntityMutation) ResetWorkflowData() {
	m.workflow_data = nil
	m.clearedworkflow_data = false
}

// SetActivityDataID sets the "activity_data" edge to the ActivityData entity by id.
func (m *EntityMutation) SetActivityDataID(id int) {
	m.activity_data = &id
}

// ClearActivityData clears the "activity_data" edge to the ActivityData entity.
func (m *EntityMutation) ClearActivityData() {
	m.clearedactivity_data = true
}

// ActivityDataCleared reports if the "activity_data" edge to the ActivityData entity was cleared.
func (m *EntityMutation) ActivityDataCleared() bool {
	return m.clearedactivity_data
}

// ActivityDataID returns the "activity_data" edge ID in the mutation.
func (m *EntityMutation) ActivityDataID() (id int, exists bool) {
	if m.activity_data != nil {
		return *m.activity_data, true
	}
	return
}

// ActivityDataIDs returns the "activity_data" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActivityDataID instead. It exists only for internal usage by the builders.
func (m *EntityMutation) ActivityDataIDs() (ids []int) {
	if id := m.activity_data; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActivityData resets all changes to the "activity_data" edge.
func (m *EntityMutation) ResetActivityData() {
	m.activity_data = nil
	m.clearedactivity_data = false
}

// SetSagaDataID sets the "saga_data" edge to the SagaData entity by id.
func (m *EntityMutation) SetSagaDataID(id int) {
	m.saga_data = &id
}

// ClearSagaData clears the "saga_data" edge to the SagaData entity.
func (m *EntityMutation) ClearSagaData() {
	m.clearedsaga_data = true
}

// SagaDataCleared reports if the "saga_data" edge to the SagaData entity was cleared.
func (m *EntityMutation) SagaDataCleared() bool {
	return m.clearedsaga_data
}

// SagaDataID returns the "saga_data" edge ID in the mutation.
func (m *EntityMutation) SagaDataID() (id int, exists bool) {
	if m.saga_data != nil {
		return *m.saga_data, true
	}
	return
}

// SagaDataIDs returns the "saga_data" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SagaDataID instead. It exists only for internal usage by the builders.
func (m *EntityMutation) SagaDataIDs() (ids []int) {
	if id := m.saga_data; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSagaData resets all changes to the "saga_data" edge.
func (m *EntityMutation) ResetSagaData() {
	m.saga_data = nil
	m.clearedsaga_data = false
}

// SetSideEffectDataID sets the "side_effect_data" edge to the SideEffectData entity by id.
func (m *EntityMutation) SetSideEffectDataID(id int) {
	m.side_effect_data = &id
}

// ClearSideEffectData clears the "side_effect_data" edge to the SideEffectData entity.
func (m *EntityMutation) ClearSideEffectData() {
	m.clearedside_effect_data = true
}

// SideEffectDataCleared reports if the "side_effect_data" edge to the SideEffectData entity was cleared.
func (m *EntityMutation) SideEffectDataCleared() bool {
	return m.clearedside_effect_data
}

// SideEffectDataID returns the "side_effect_data" edge ID in the mutation.
func (m *EntityMutation) SideEffectDataID() (id int, exists bool) {
	if m.side_effect_data != nil {
		return *m.side_effect_data, true
	}
	return
}

// SideEffectDataIDs returns the "side_effect_data" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SideEffectDataID instead. It exists only for internal usage by the builders.
func (m *EntityMutation) SideEffectDataIDs() (ids []int) {
	if id := m.side_effect_data; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSideEffectData resets all changes to the "side_effect_data" edge.
func (m *EntityMutation) ResetSideEffectData() {
	m.side_effect_data = nil
	m.clearedside_effect_data = false
}

// Where appends a list predicates to the EntityMutation builder.
func (m *EntityMutation) Where(ps ...predicate.Entity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EntityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EntityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Entity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EntityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EntityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Entity).
func (m *EntityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntityMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, entity.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, entity.FieldUpdatedAt)
	}
	if m.handler_name != nil {
		fields = append(fields, entity.FieldHandlerName)
	}
	if m._type != nil {
		fields = append(fields, entity.FieldType)
	}
	if m.retry_state != nil {
		fields = append(fields, entity.FieldRetryState)
	}
	if m.retry_policy != nil {
		fields = append(fields, entity.FieldRetryPolicy)
	}
	if m.status != nil {
		fields = append(fields, entity.FieldStatus)
	}
	if m.step_id != nil {
		fields = append(fields, entity.FieldStepID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entity.FieldCreatedAt:
		return m.CreatedAt()
	case entity.FieldUpdatedAt:
		return m.UpdatedAt()
	case entity.FieldHandlerName:
		return m.HandlerName()
	case entity.FieldType:
		return m.GetType()
	case entity.FieldRetryState:
		return m.RetryState()
	case entity.FieldRetryPolicy:
		return m.RetryPolicy()
	case entity.FieldStatus:
		return m.Status()
	case entity.FieldStepID:
		return m.StepID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case entity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case entity.FieldHandlerName:
		return m.OldHandlerName(ctx)
	case entity.FieldType:
		return m.OldType(ctx)
	case entity.FieldRetryState:
		return m.OldRetryState(ctx)
	case entity.FieldRetryPolicy:
		return m.OldRetryPolicy(ctx)
	case entity.FieldStatus:
		return m.OldStatus(ctx)
	case entity.FieldStepID:
		return m.OldStepID(ctx)
	}
	return nil, fmt.Errorf("unknown Entity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case entity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case entity.FieldHandlerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandlerName(v)
		return nil
	case entity.FieldType:
		v, ok := value.(entity.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case entity.FieldRetryState:
		v, ok := value.(*schema.RetryState)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryState(v)
		return nil
	case entity.FieldRetryPolicy:
		v, ok := value.(*schema.RetryPolicy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryPolicy(v)
		return nil
	case entity.FieldStatus:
		v, ok := value.(entity.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case entity.FieldStepID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStepID(v)
		return nil
	}
	return fmt.Errorf("unknown Entity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Entity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Entity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntityMutation) ResetField(name string) error {
	switch name {
	case entity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case entity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case entity.FieldHandlerName:
		m.ResetHandlerName()
		return nil
	case entity.FieldType:
		m.ResetType()
		return nil
	case entity.FieldRetryState:
		m.ResetRetryState()
		return nil
	case entity.FieldRetryPolicy:
		m.ResetRetryPolicy()
		return nil
	case entity.FieldStatus:
		m.ResetStatus()
		return nil
	case entity.FieldStepID:
		m.ResetStepID()
		return nil
	}
	return fmt.Errorf("unknown Entity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntityMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.run != nil {
		edges = append(edges, entity.EdgeRun)
	}
	if m.executions != nil {
		edges = append(edges, entity.EdgeExecutions)
	}
	if m.queue != nil {
		edges = append(edges, entity.EdgeQueue)
	}
	if m.versions != nil {
		edges = append(edges, entity.EdgeVersions)
	}
	if m.workflow_data != nil {
		edges = append(edges, entity.EdgeWorkflowData)
	}
	if m.activity_data != nil {
		edges = append(edges, entity.EdgeActivityData)
	}
	if m.saga_data != nil {
		edges = append(edges, entity.EdgeSagaData)
	}
	if m.side_effect_data != nil {
		edges = append(edges, entity.EdgeSideEffectData)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entity.EdgeRun:
		if id := m.run; id != nil {
			return []ent.Value{*id}
		}
	case entity.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.executions))
		for id := range m.executions {
			ids = append(ids, id)
		}
		return ids
	case entity.EdgeQueue:
		if id := m.queue; id != nil {
			return []ent.Value{*id}
		}
	case entity.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.versions))
		for id := range m.versions {
			ids = append(ids, id)
		}
		return ids
	case entity.EdgeWorkflowData:
		if id := m.workflow_data; id != nil {
			return []ent.Value{*id}
		}
	case entity.EdgeActivityData:
		if id := m.activity_data; id != nil {
			return []ent.Value{*id}
		}
	case entity.EdgeSagaData:
		if id := m.saga_data; id != nil {
			return []ent.Value{*id}
		}
	case entity.EdgeSideEffectData:
		if id := m.side_effect_data; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedexecutions != nil {
		edges = append(edges, entity.EdgeExecutions)
	}
	if m.removedversions != nil {
		edges = append(edges, entity.EdgeVersions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case entity.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.removedexecutions))
		for id := range m.removedexecutions {
			ids = append(ids, id)
		}
		return ids
	case entity.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.removedversions))
		for id := range m.removedversions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedrun {
		edges = append(edges, entity.EdgeRun)
	}
	if m.clearedexecutions {
		edges = append(edges, entity.EdgeExecutions)
	}
	if m.clearedqueue {
		edges = append(edges, entity.EdgeQueue)
	}
	if m.clearedversions {
		edges = append(edges, entity.EdgeVersions)
	}
	if m.clearedworkflow_data {
		edges = append(edges, entity.EdgeWorkflowData)
	}
	if m.clearedactivity_data {
		edges = append(edges, entity.EdgeActivityData)
	}
	if m.clearedsaga_data {
		edges = append(edges, entity.EdgeSagaData)
	}
	if m.clearedside_effect_data {
		edges = append(edges, entity.EdgeSideEffectData)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntityMutation) EdgeCleared(name string) bool {
	switch name {
	case entity.EdgeRun:
		return m.clearedrun
	case entity.EdgeExecutions:
		return m.clearedexecutions
	case entity.EdgeQueue:
		return m.clearedqueue
	case entity.EdgeVersions:
		return m.clearedversions
	case entity.EdgeWorkflowData:
		return m.clearedworkflow_data
	case entity.EdgeActivityData:
		return m.clearedactivity_data
	case entity.EdgeSagaData:
		return m.clearedsaga_data
	case entity.EdgeSideEffectData:
		return m.clearedside_effect_data
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntityMutation) ClearEdge(name string) error {
	switch name {
	case entity.EdgeRun:
		m.ClearRun()
		return nil
	case entity.EdgeQueue:
		m.ClearQueue()
		return nil
	case entity.EdgeWorkflowData:
		m.ClearWorkflowData()
		return nil
	case entity.EdgeActivityData:
		m.ClearActivityData()
		return nil
	case entity.EdgeSagaData:
		m.ClearSagaData()
		return nil
	case entity.EdgeSideEffectData:
		m.ClearSideEffectData()
		return nil
	}
	return fmt.Errorf("unknown Entity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntityMutation) ResetEdge(name string) error {
	switch name {
	case entity.EdgeRun:
		m.ResetRun()
		return nil
	case entity.EdgeExecutions:
		m.ResetExecutions()
		return nil
	case entity.EdgeQueue:
		m.ResetQueue()
		return nil
	case entity.EdgeVersions:
		m.ResetVersions()
		return nil
	case entity.EdgeWorkflowData:
		m.ResetWorkflowData()
		return nil
	case entity.EdgeActivityData:
		m.ResetActivityData()
		return nil
	case entity.EdgeSagaData:
		m.ResetSagaData()
		return nil
	case entity.EdgeSideEffectData:
		m.ResetSideEffectData()
		return nil
	}
	return fmt.Errorf("unknown Entity edge %s", name)
}

// ExecutionMutation represents an operation that mutates the Execution nodes in the graph.
type ExecutionMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	created_at                   *time.Time
	updated_at                   *time.Time
	started_at                   *time.Time
	completed_at                 *time.Time
	status                       *execution.Status
	error                        *string
	clearedFields                map[string]struct{}
	entity                       *int
	clearedentity                bool
	workflow_execution           *int
	clearedworkflow_execution    bool
	activity_execution           *int
	clearedactivity_execution    bool
	saga_execution               *int
	clearedsaga_execution        bool
	side_effect_execution        *int
	clearedside_effect_execution bool
	done                         bool
	oldValue                     func(context.Context) (*Execution, error)
	predicates                   []predicate.Execution
}

var _ ent.Mutation = (*ExecutionMutation)(nil)

// executionOption allows management of the mutation configuration using functional options.
type executionOption func(*ExecutionMutation)

// newExecutionMutation creates new mutation for the Execution entity.
func newExecutionMutation(c config, op Op, opts ...executionOption) *ExecutionMutation {
	m := &ExecutionMutation{
		config:        c,
		op:            op,
		typ:           TypeExecution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExecutionID sets the ID field of the mutation.
func withExecutionID(id int) executionOption {
	return func(m *ExecutionMutation) {
		var (
			err   error
			once  sync.Once
			value *Execution
		)
		m.oldValue = func(ctx context.Context) (*Execution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Execution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExecution sets the old Execution of the mutation.
func withExecution(node *Execution) executionOption {
	return func(m *ExecutionMutation) {
		m.oldValue = func(context.Context) (*Execution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExecutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExecutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExecutionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExecutionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Execution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ExecutionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ExecutionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Execution entity.
// If the Execution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ExecutionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ExecutionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ExecutionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Execution entity.
// If the Execution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ExecutionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStartedAt sets the "started_at" field.
func (m *ExecutionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *ExecutionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Execution entity.
// If the Execution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *ExecutionMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetCompletedAt sets the "completed_at" field.
func (m *ExecutionMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *ExecutionMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the Execution entity.
// If the Execution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *ExecutionMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[execution.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *ExecutionMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[execution.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *ExecutionMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, execution.FieldCompletedAt)
}

// SetStatus sets the "status" field.
func (m *ExecutionMutation) SetStatus(e execution.Status) {
	m.status = &e
}

// Status returns the value of the "status" field in the mutation.
func (m *ExecutionMutation) Status() (r execution.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Execution entity.
// If the Execution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionMutation) OldStatus(ctx context.Context) (v execution.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ExecutionMutation) ResetStatus() {
	m.status = nil
}

// SetError sets the "error" field.
func (m *ExecutionMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *ExecutionMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the Execution entity.
// If the Execution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *ExecutionMutation) ClearError() {
	m.error = nil
	m.clearedFields[execution.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *ExecutionMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[execution.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *ExecutionMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, execution.FieldError)
}

// SetEntityID sets the "entity" edge to the Entity entity by id.
func (m *ExecutionMutation) SetEntityID(id int) {
	m.entity = &id
}

// ClearEntity clears the "entity" edge to the Entity entity.
func (m *ExecutionMutation) ClearEntity() {
	m.clearedentity = true
}

// EntityCleared reports if the "entity" edge to the Entity entity was cleared.
func (m *ExecutionMutation) EntityCleared() bool {
	return m.clearedentity
}

// EntityID returns the "entity" edge ID in the mutation.
func (m *ExecutionMutation) EntityID() (id int, exists bool) {
	if m.entity != nil {
		return *m.entity, true
	}
	return
}

// EntityIDs returns the "entity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntityID instead. It exists only for internal usage by the builders.
func (m *ExecutionMutation) EntityIDs() (ids []int) {
	if id := m.entity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntity resets all changes to the "entity" edge.
func (m *ExecutionMutation) ResetEntity() {
	m.entity = nil
	m.clearedentity = false
}

// SetWorkflowExecutionID sets the "workflow_execution" edge to the WorkflowExecution entity by id.
func (m *ExecutionMutation) SetWorkflowExecutionID(id int) {
	m.workflow_execution = &id
}

// ClearWorkflowExecution clears the "workflow_execution" edge to the WorkflowExecution entity.
func (m *ExecutionMutation) ClearWorkflowExecution() {
	m.clearedworkflow_execution = true
}

// WorkflowExecutionCleared reports if the "workflow_execution" edge to the WorkflowExecution entity was cleared.
func (m *ExecutionMutation) WorkflowExecutionCleared() bool {
	return m.clearedworkflow_execution
}

// WorkflowExecutionID returns the "workflow_execution" edge ID in the mutation.
func (m *ExecutionMutation) WorkflowExecutionID() (id int, exists bool) {
	if m.workflow_execution != nil {
		return *m.workflow_execution, true
	}
	return
}

// WorkflowExecutionIDs returns the "workflow_execution" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowExecutionID instead. It exists only for internal usage by the builders.
func (m *ExecutionMutation) WorkflowExecutionIDs() (ids []int) {
	if id := m.workflow_execution; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflowExecution resets all changes to the "workflow_execution" edge.
func (m *ExecutionMutation) ResetWorkflowExecution() {
	m.workflow_execution = nil
	m.clearedworkflow_execution = false
}

// SetActivityExecutionID sets the "activity_execution" edge to the ActivityExecution entity by id.
func (m *ExecutionMutation) SetActivityExecutionID(id int) {
	m.activity_execution = &id
}

// ClearActivityExecution clears the "activity_execution" edge to the ActivityExecution entity.
func (m *ExecutionMutation) ClearActivityExecution() {
	m.clearedactivity_execution = true
}

// ActivityExecutionCleared reports if the "activity_execution" edge to the ActivityExecution entity was cleared.
func (m *ExecutionMutation) ActivityExecutionCleared() bool {
	return m.clearedactivity_execution
}

// ActivityExecutionID returns the "activity_execution" edge ID in the mutation.
func (m *ExecutionMutation) ActivityExecutionID() (id int, exists bool) {
	if m.activity_execution != nil {
		return *m.activity_execution, true
	}
	return
}

// ActivityExecutionIDs returns the "activity_execution" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActivityExecutionID instead. It exists only for internal usage by the builders.
func (m *ExecutionMutation) ActivityExecutionIDs() (ids []int) {
	if id := m.activity_execution; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActivityExecution resets all changes to the "activity_execution" edge.
func (m *ExecutionMutation) ResetActivityExecution() {
	m.activity_execution = nil
	m.clearedactivity_execution = false
}

// SetSagaExecutionID sets the "saga_execution" edge to the SagaExecution entity by id.
func (m *ExecutionMutation) SetSagaExecutionID(id int) {
	m.saga_execution = &id
}

// ClearSagaExecution clears the "saga_execution" edge to the SagaExecution entity.
func (m *ExecutionMutation) ClearSagaExecution() {
	m.clearedsaga_execution = true
}

// SagaExecutionCleared reports if the "saga_execution" edge to the SagaExecution entity was cleared.
func (m *ExecutionMutation) SagaExecutionCleared() bool {
	return m.clearedsaga_execution
}

// SagaExecutionID returns the "saga_execution" edge ID in the mutation.
func (m *ExecutionMutation) SagaExecutionID() (id int, exists bool) {
	if m.saga_execution != nil {
		return *m.saga_execution, true
	}
	return
}

// SagaExecutionIDs returns the "saga_execution" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SagaExecutionID instead. It exists only for internal usage by the builders.
func (m *ExecutionMutation) SagaExecutionIDs() (ids []int) {
	if id := m.saga_execution; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSagaExecution resets all changes to the "saga_execution" edge.
func (m *ExecutionMutation) ResetSagaExecution() {
	m.saga_execution = nil
	m.clearedsaga_execution = false
}

// SetSideEffectExecutionID sets the "side_effect_execution" edge to the SideEffectExecution entity by id.
func (m *ExecutionMutation) SetSideEffectExecutionID(id int) {
	m.side_effect_execution = &id
}

// ClearSideEffectExecution clears the "side_effect_execution" edge to the SideEffectExecution entity.
func (m *ExecutionMutation) ClearSideEffectExecution() {
	m.clearedside_effect_execution = true
}

// SideEffectExecutionCleared reports if the "side_effect_execution" edge to the SideEffectExecution entity was cleared.
func (m *ExecutionMutation) SideEffectExecutionCleared() bool {
	return m.clearedside_effect_execution
}

// SideEffectExecutionID returns the "side_effect_execution" edge ID in the mutation.
func (m *ExecutionMutation) SideEffectExecutionID() (id int, exists bool) {
	if m.side_effect_execution != nil {
		return *m.side_effect_execution, true
	}
	return
}

// SideEffectExecutionIDs returns the "side_effect_execution" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SideEffectExecutionID instead. It exists only for internal usage by the builders.
func (m *ExecutionMutation) SideEffectExecutionIDs() (ids []int) {
	if id := m.side_effect_execution; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSideEffectExecution resets all changes to the "side_effect_execution" edge.
func (m *ExecutionMutation) ResetSideEffectExecution() {
	m.side_effect_execution = nil
	m.clearedside_effect_execution = false
}

// Where appends a list predicates to the ExecutionMutation builder.
func (m *ExecutionMutation) Where(ps ...predicate.Execution) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExecutionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExecutionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Execution, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExecutionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExecutionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Execution).
func (m *ExecutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExecutionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, execution.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, execution.FieldUpdatedAt)
	}
	if m.started_at != nil {
		fields = append(fields, execution.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, execution.FieldCompletedAt)
	}
	if m.status != nil {
		fields = append(fields, execution.FieldStatus)
	}
	if m.error != nil {
		fields = append(fields, execution.FieldError)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExecutionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case execution.FieldCreatedAt:
		return m.CreatedAt()
	case execution.FieldUpdatedAt:
		return m.UpdatedAt()
	case execution.FieldStartedAt:
		return m.StartedAt()
	case execution.FieldCompletedAt:
		return m.CompletedAt()
	case execution.FieldStatus:
		return m.Status()
	case execution.FieldError:
		return m.Error()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExecutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case execution.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case execution.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case execution.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case execution.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case execution.FieldStatus:
		return m.OldStatus(ctx)
	case execution.FieldError:
		return m.OldError(ctx)
	}
	return nil, fmt.Errorf("unknown Execution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExecutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case execution.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case execution.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case execution.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case execution.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case execution.FieldStatus:
		v, ok := value.(execution.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case execution.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	}
	return fmt.Errorf("unknown Execution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExecutionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExecutionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExecutionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Execution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExecutionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(execution.FieldCompletedAt) {
		fields = append(fields, execution.FieldCompletedAt)
	}
	if m.FieldCleared(execution.FieldError) {
		fields = append(fields, execution.FieldError)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExecutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExecutionMutation) ClearField(name string) error {
	switch name {
	case execution.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	case execution.FieldError:
		m.ClearError()
		return nil
	}
	return fmt.Errorf("unknown Execution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExecutionMutation) ResetField(name string) error {
	switch name {
	case execution.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case execution.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case execution.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case execution.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case execution.FieldStatus:
		m.ResetStatus()
		return nil
	case execution.FieldError:
		m.ResetError()
		return nil
	}
	return fmt.Errorf("unknown Execution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExecutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.entity != nil {
		edges = append(edges, execution.EdgeEntity)
	}
	if m.workflow_execution != nil {
		edges = append(edges, execution.EdgeWorkflowExecution)
	}
	if m.activity_execution != nil {
		edges = append(edges, execution.EdgeActivityExecution)
	}
	if m.saga_execution != nil {
		edges = append(edges, execution.EdgeSagaExecution)
	}
	if m.side_effect_execution != nil {
		edges = append(edges, execution.EdgeSideEffectExecution)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExecutionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case execution.EdgeEntity:
		if id := m.entity; id != nil {
			return []ent.Value{*id}
		}
	case execution.EdgeWorkflowExecution:
		if id := m.workflow_execution; id != nil {
			return []ent.Value{*id}
		}
	case execution.EdgeActivityExecution:
		if id := m.activity_execution; id != nil {
			return []ent.Value{*id}
		}
	case execution.EdgeSagaExecution:
		if id := m.saga_execution; id != nil {
			return []ent.Value{*id}
		}
	case execution.EdgeSideEffectExecution:
		if id := m.side_effect_execution; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExecutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExecutionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExecutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedentity {
		edges = append(edges, execution.EdgeEntity)
	}
	if m.clearedworkflow_execution {
		edges = append(edges, execution.EdgeWorkflowExecution)
	}
	if m.clearedactivity_execution {
		edges = append(edges, execution.EdgeActivityExecution)
	}
	if m.clearedsaga_execution {
		edges = append(edges, execution.EdgeSagaExecution)
	}
	if m.clearedside_effect_execution {
		edges = append(edges, execution.EdgeSideEffectExecution)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExecutionMutation) EdgeCleared(name string) bool {
	switch name {
	case execution.EdgeEntity:
		return m.clearedentity
	case execution.EdgeWorkflowExecution:
		return m.clearedworkflow_execution
	case execution.EdgeActivityExecution:
		return m.clearedactivity_execution
	case execution.EdgeSagaExecution:
		return m.clearedsaga_execution
	case execution.EdgeSideEffectExecution:
		return m.clearedside_effect_execution
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExecutionMutation) ClearEdge(name string) error {
	switch name {
	case execution.EdgeEntity:
		m.ClearEntity()
		return nil
	case execution.EdgeWorkflowExecution:
		m.ClearWorkflowExecution()
		return nil
	case execution.EdgeActivityExecution:
		m.ClearActivityExecution()
		return nil
	case execution.EdgeSagaExecution:
		m.ClearSagaExecution()
		return nil
	case execution.EdgeSideEffectExecution:
		m.ClearSideEffectExecution()
		return nil
	}
	return fmt.Errorf("unknown Execution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExecutionMutation) ResetEdge(name string) error {
	switch name {
	case execution.EdgeEntity:
		m.ResetEntity()
		return nil
	case execution.EdgeWorkflowExecution:
		m.ResetWorkflowExecution()
		return nil
	case execution.EdgeActivityExecution:
		m.ResetActivityExecution()
		return nil
	case execution.EdgeSagaExecution:
		m.ResetSagaExecution()
		return nil
	case execution.EdgeSideEffectExecution:
		m.ResetSideEffectExecution()
		return nil
	}
	return fmt.Errorf("unknown Execution edge %s", name)
}

// HierarchyMutation represents an operation that mutates the Hierarchy nodes in the graph.
type HierarchyMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	parent_execution_id    *int
	addparent_execution_id *int
	child_execution_id     *int
	addchild_execution_id  *int
	parent_step_id         *string
	child_step_id          *string
	childType              *hierarchy.ChildType
	parentType             *hierarchy.ParentType
	clearedFields          map[string]struct{}
	run                    *int
	clearedrun             bool
	parent_entity          *int
	clearedparent_entity   bool
	child_entity           *int
	clearedchild_entity    bool
	done                   bool
	oldValue               func(context.Context) (*Hierarchy, error)
	predicates             []predicate.Hierarchy
}

var _ ent.Mutation = (*HierarchyMutation)(nil)

// hierarchyOption allows management of the mutation configuration using functional options.
type hierarchyOption func(*HierarchyMutation)

// newHierarchyMutation creates new mutation for the Hierarchy entity.
func newHierarchyMutation(c config, op Op, opts ...hierarchyOption) *HierarchyMutation {
	m := &HierarchyMutation{
		config:        c,
		op:            op,
		typ:           TypeHierarchy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHierarchyID sets the ID field of the mutation.
func withHierarchyID(id int) hierarchyOption {
	return func(m *HierarchyMutation) {
		var (
			err   error
			once  sync.Once
			value *Hierarchy
		)
		m.oldValue = func(ctx context.Context) (*Hierarchy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Hierarchy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHierarchy sets the old Hierarchy of the mutation.
func withHierarchy(node *Hierarchy) hierarchyOption {
	return func(m *HierarchyMutation) {
		m.oldValue = func(context.Context) (*Hierarchy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HierarchyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HierarchyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HierarchyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HierarchyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Hierarchy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRunID sets the "run_id" field.
func (m *HierarchyMutation) SetRunID(i int) {
	m.run = &i
}

// RunID returns the value of the "run_id" field in the mutation.
func (m *HierarchyMutation) RunID() (r int, exists bool) {
	v := m.run
	if v == nil {
		return
	}
	return *v, true
}

// OldRunID returns the old "run_id" field's value of the Hierarchy entity.
// If the Hierarchy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HierarchyMutation) OldRunID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunID: %w", err)
	}
	return oldValue.RunID, nil
}

// ResetRunID resets all changes to the "run_id" field.
func (m *HierarchyMutation) ResetRunID() {
	m.run = nil
}

// SetParentEntityID sets the "parent_entity_id" field.
func (m *HierarchyMutation) SetParentEntityID(i int) {
	m.parent_entity = &i
}

// ParentEntityID returns the value of the "parent_entity_id" field in the mutation.
func (m *HierarchyMutation) ParentEntityID() (r int, exists bool) {
	v := m.parent_entity
	if v == nil {
		return
	}
	return *v, true
}

// OldParentEntityID returns the old "parent_entity_id" field's value of the Hierarchy entity.
// If the Hierarchy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HierarchyMutation) OldParentEntityID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentEntityID: %w", err)
	}
	return oldValue.ParentEntityID, nil
}

// ResetParentEntityID resets all changes to the "parent_entity_id" field.
func (m *HierarchyMutation) ResetParentEntityID() {
	m.parent_entity = nil
}

// SetChildEntityID sets the "child_entity_id" field.
func (m *HierarchyMutation) SetChildEntityID(i int) {
	m.child_entity = &i
}

// ChildEntityID returns the value of the "child_entity_id" field in the mutation.
func (m *HierarchyMutation) ChildEntityID() (r int, exists bool) {
	v := m.child_entity
	if v == nil {
		return
	}
	return *v, true
}

// OldChildEntityID returns the old "child_entity_id" field's value of the Hierarchy entity.
// If the Hierarchy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HierarchyMutation) OldChildEntityID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChildEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChildEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChildEntityID: %w", err)
	}
	return oldValue.ChildEntityID, nil
}

// ResetChildEntityID resets all changes to the "child_entity_id" field.
func (m *HierarchyMutation) ResetChildEntityID() {
	m.child_entity = nil
}

// SetParentExecutionID sets the "parent_execution_id" field.
func (m *HierarchyMutation) SetParentExecutionID(i int) {
	m.parent_execution_id = &i
	m.addparent_execution_id = nil
}

// ParentExecutionID returns the value of the "parent_execution_id" field in the mutation.
func (m *HierarchyMutation) ParentExecutionID() (r int, exists bool) {
	v := m.parent_execution_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentExecutionID returns the old "parent_execution_id" field's value of the Hierarchy entity.
// If the Hierarchy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HierarchyMutation) OldParentExecutionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentExecutionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentExecutionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentExecutionID: %w", err)
	}
	return oldValue.ParentExecutionID, nil
}

// AddParentExecutionID adds i to the "parent_execution_id" field.
func (m *HierarchyMutation) AddParentExecutionID(i int) {
	if m.addparent_execution_id != nil {
		*m.addparent_execution_id += i
	} else {
		m.addparent_execution_id = &i
	}
}

// AddedParentExecutionID returns the value that was added to the "parent_execution_id" field in this mutation.
func (m *HierarchyMutation) AddedParentExecutionID() (r int, exists bool) {
	v := m.addparent_execution_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetParentExecutionID resets all changes to the "parent_execution_id" field.
func (m *HierarchyMutation) ResetParentExecutionID() {
	m.parent_execution_id = nil
	m.addparent_execution_id = nil
}

// SetChildExecutionID sets the "child_execution_id" field.
func (m *HierarchyMutation) SetChildExecutionID(i int) {
	m.child_execution_id = &i
	m.addchild_execution_id = nil
}

// ChildExecutionID returns the value of the "child_execution_id" field in the mutation.
func (m *HierarchyMutation) ChildExecutionID() (r int, exists bool) {
	v := m.child_execution_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChildExecutionID returns the old "child_execution_id" field's value of the Hierarchy entity.
// If the Hierarchy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HierarchyMutation) OldChildExecutionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChildExecutionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChildExecutionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChildExecutionID: %w", err)
	}
	return oldValue.ChildExecutionID, nil
}

// AddChildExecutionID adds i to the "child_execution_id" field.
func (m *HierarchyMutation) AddChildExecutionID(i int) {
	if m.addchild_execution_id != nil {
		*m.addchild_execution_id += i
	} else {
		m.addchild_execution_id = &i
	}
}

// AddedChildExecutionID returns the value that was added to the "child_execution_id" field in this mutation.
func (m *HierarchyMutation) AddedChildExecutionID() (r int, exists bool) {
	v := m.addchild_execution_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetChildExecutionID resets all changes to the "child_execution_id" field.
func (m *HierarchyMutation) ResetChildExecutionID() {
	m.child_execution_id = nil
	m.addchild_execution_id = nil
}

// SetParentStepID sets the "parent_step_id" field.
func (m *HierarchyMutation) SetParentStepID(s string) {
	m.parent_step_id = &s
}

// ParentStepID returns the value of the "parent_step_id" field in the mutation.
func (m *HierarchyMutation) ParentStepID() (r string, exists bool) {
	v := m.parent_step_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentStepID returns the old "parent_step_id" field's value of the Hierarchy entity.
// If the Hierarchy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HierarchyMutation) OldParentStepID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentStepID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentStepID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentStepID: %w", err)
	}
	return oldValue.ParentStepID, nil
}

// ResetParentStepID resets all changes to the "parent_step_id" field.
func (m *HierarchyMutation) ResetParentStepID() {
	m.parent_step_id = nil
}

// SetChildStepID sets the "child_step_id" field.
func (m *HierarchyMutation) SetChildStepID(s string) {
	m.child_step_id = &s
}

// ChildStepID returns the value of the "child_step_id" field in the mutation.
func (m *HierarchyMutation) ChildStepID() (r string, exists bool) {
	v := m.child_step_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChildStepID returns the old "child_step_id" field's value of the Hierarchy entity.
// If the Hierarchy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HierarchyMutation) OldChildStepID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChildStepID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChildStepID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChildStepID: %w", err)
	}
	return oldValue.ChildStepID, nil
}

// ResetChildStepID resets all changes to the "child_step_id" field.
func (m *HierarchyMutation) ResetChildStepID() {
	m.child_step_id = nil
}

// SetChildType sets the "childType" field.
func (m *HierarchyMutation) SetChildType(ht hierarchy.ChildType) {
	m.childType = &ht
}

// ChildType returns the value of the "childType" field in the mutation.
func (m *HierarchyMutation) ChildType() (r hierarchy.ChildType, exists bool) {
	v := m.childType
	if v == nil {
		return
	}
	return *v, true
}

// OldChildType returns the old "childType" field's value of the Hierarchy entity.
// If the Hierarchy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HierarchyMutation) OldChildType(ctx context.Context) (v hierarchy.ChildType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChildType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChildType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChildType: %w", err)
	}
	return oldValue.ChildType, nil
}

// ResetChildType resets all changes to the "childType" field.
func (m *HierarchyMutation) ResetChildType() {
	m.childType = nil
}

// SetParentType sets the "parentType" field.
func (m *HierarchyMutation) SetParentType(ht hierarchy.ParentType) {
	m.parentType = &ht
}

// ParentType returns the value of the "parentType" field in the mutation.
func (m *HierarchyMutation) ParentType() (r hierarchy.ParentType, exists bool) {
	v := m.parentType
	if v == nil {
		return
	}
	return *v, true
}

// OldParentType returns the old "parentType" field's value of the Hierarchy entity.
// If the Hierarchy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HierarchyMutation) OldParentType(ctx context.Context) (v hierarchy.ParentType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentType: %w", err)
	}
	return oldValue.ParentType, nil
}

// ResetParentType resets all changes to the "parentType" field.
func (m *HierarchyMutation) ResetParentType() {
	m.parentType = nil
}

// ClearRun clears the "run" edge to the Run entity.
func (m *HierarchyMutation) ClearRun() {
	m.clearedrun = true
	m.clearedFields[hierarchy.FieldRunID] = struct{}{}
}

// RunCleared reports if the "run" edge to the Run entity was cleared.
func (m *HierarchyMutation) RunCleared() bool {
	return m.clearedrun
}

// RunIDs returns the "run" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RunID instead. It exists only for internal usage by the builders.
func (m *HierarchyMutation) RunIDs() (ids []int) {
	if id := m.run; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRun resets all changes to the "run" edge.
func (m *HierarchyMutation) ResetRun() {
	m.run = nil
	m.clearedrun = false
}

// ClearParentEntity clears the "parent_entity" edge to the Entity entity.
func (m *HierarchyMutation) ClearParentEntity() {
	m.clearedparent_entity = true
	m.clearedFields[hierarchy.FieldParentEntityID] = struct{}{}
}

// ParentEntityCleared reports if the "parent_entity" edge to the Entity entity was cleared.
func (m *HierarchyMutation) ParentEntityCleared() bool {
	return m.clearedparent_entity
}

// ParentEntityIDs returns the "parent_entity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentEntityID instead. It exists only for internal usage by the builders.
func (m *HierarchyMutation) ParentEntityIDs() (ids []int) {
	if id := m.parent_entity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentEntity resets all changes to the "parent_entity" edge.
func (m *HierarchyMutation) ResetParentEntity() {
	m.parent_entity = nil
	m.clearedparent_entity = false
}

// ClearChildEntity clears the "child_entity" edge to the Entity entity.
func (m *HierarchyMutation) ClearChildEntity() {
	m.clearedchild_entity = true
	m.clearedFields[hierarchy.FieldChildEntityID] = struct{}{}
}

// ChildEntityCleared reports if the "child_entity" edge to the Entity entity was cleared.
func (m *HierarchyMutation) ChildEntityCleared() bool {
	return m.clearedchild_entity
}

// ChildEntityIDs returns the "child_entity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChildEntityID instead. It exists only for internal usage by the builders.
func (m *HierarchyMutation) ChildEntityIDs() (ids []int) {
	if id := m.child_entity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChildEntity resets all changes to the "child_entity" edge.
func (m *HierarchyMutation) ResetChildEntity() {
	m.child_entity = nil
	m.clearedchild_entity = false
}

// Where appends a list predicates to the HierarchyMutation builder.
func (m *HierarchyMutation) Where(ps ...predicate.Hierarchy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HierarchyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HierarchyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Hierarchy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HierarchyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HierarchyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Hierarchy).
func (m *HierarchyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HierarchyMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.run != nil {
		fields = append(fields, hierarchy.FieldRunID)
	}
	if m.parent_entity != nil {
		fields = append(fields, hierarchy.FieldParentEntityID)
	}
	if m.child_entity != nil {
		fields = append(fields, hierarchy.FieldChildEntityID)
	}
	if m.parent_execution_id != nil {
		fields = append(fields, hierarchy.FieldParentExecutionID)
	}
	if m.child_execution_id != nil {
		fields = append(fields, hierarchy.FieldChildExecutionID)
	}
	if m.parent_step_id != nil {
		fields = append(fields, hierarchy.FieldParentStepID)
	}
	if m.child_step_id != nil {
		fields = append(fields, hierarchy.FieldChildStepID)
	}
	if m.childType != nil {
		fields = append(fields, hierarchy.FieldChildType)
	}
	if m.parentType != nil {
		fields = append(fields, hierarchy.FieldParentType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HierarchyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hierarchy.FieldRunID:
		return m.RunID()
	case hierarchy.FieldParentEntityID:
		return m.ParentEntityID()
	case hierarchy.FieldChildEntityID:
		return m.ChildEntityID()
	case hierarchy.FieldParentExecutionID:
		return m.ParentExecutionID()
	case hierarchy.FieldChildExecutionID:
		return m.ChildExecutionID()
	case hierarchy.FieldParentStepID:
		return m.ParentStepID()
	case hierarchy.FieldChildStepID:
		return m.ChildStepID()
	case hierarchy.FieldChildType:
		return m.ChildType()
	case hierarchy.FieldParentType:
		return m.ParentType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HierarchyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hierarchy.FieldRunID:
		return m.OldRunID(ctx)
	case hierarchy.FieldParentEntityID:
		return m.OldParentEntityID(ctx)
	case hierarchy.FieldChildEntityID:
		return m.OldChildEntityID(ctx)
	case hierarchy.FieldParentExecutionID:
		return m.OldParentExecutionID(ctx)
	case hierarchy.FieldChildExecutionID:
		return m.OldChildExecutionID(ctx)
	case hierarchy.FieldParentStepID:
		return m.OldParentStepID(ctx)
	case hierarchy.FieldChildStepID:
		return m.OldChildStepID(ctx)
	case hierarchy.FieldChildType:
		return m.OldChildType(ctx)
	case hierarchy.FieldParentType:
		return m.OldParentType(ctx)
	}
	return nil, fmt.Errorf("unknown Hierarchy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HierarchyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hierarchy.FieldRunID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunID(v)
		return nil
	case hierarchy.FieldParentEntityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentEntityID(v)
		return nil
	case hierarchy.FieldChildEntityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChildEntityID(v)
		return nil
	case hierarchy.FieldParentExecutionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentExecutionID(v)
		return nil
	case hierarchy.FieldChildExecutionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChildExecutionID(v)
		return nil
	case hierarchy.FieldParentStepID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentStepID(v)
		return nil
	case hierarchy.FieldChildStepID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChildStepID(v)
		return nil
	case hierarchy.FieldChildType:
		v, ok := value.(hierarchy.ChildType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChildType(v)
		return nil
	case hierarchy.FieldParentType:
		v, ok := value.(hierarchy.ParentType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentType(v)
		return nil
	}
	return fmt.Errorf("unknown Hierarchy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HierarchyMutation) AddedFields() []string {
	var fields []string
	if m.addparent_execution_id != nil {
		fields = append(fields, hierarchy.FieldParentExecutionID)
	}
	if m.addchild_execution_id != nil {
		fields = append(fields, hierarchy.FieldChildExecutionID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HierarchyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hierarchy.FieldParentExecutionID:
		return m.AddedParentExecutionID()
	case hierarchy.FieldChildExecutionID:
		return m.AddedChildExecutionID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HierarchyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hierarchy.FieldParentExecutionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParentExecutionID(v)
		return nil
	case hierarchy.FieldChildExecutionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChildExecutionID(v)
		return nil
	}
	return fmt.Errorf("unknown Hierarchy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HierarchyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HierarchyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HierarchyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Hierarchy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HierarchyMutation) ResetField(name string) error {
	switch name {
	case hierarchy.FieldRunID:
		m.ResetRunID()
		return nil
	case hierarchy.FieldParentEntityID:
		m.ResetParentEntityID()
		return nil
	case hierarchy.FieldChildEntityID:
		m.ResetChildEntityID()
		return nil
	case hierarchy.FieldParentExecutionID:
		m.ResetParentExecutionID()
		return nil
	case hierarchy.FieldChildExecutionID:
		m.ResetChildExecutionID()
		return nil
	case hierarchy.FieldParentStepID:
		m.ResetParentStepID()
		return nil
	case hierarchy.FieldChildStepID:
		m.ResetChildStepID()
		return nil
	case hierarchy.FieldChildType:
		m.ResetChildType()
		return nil
	case hierarchy.FieldParentType:
		m.ResetParentType()
		return nil
	}
	return fmt.Errorf("unknown Hierarchy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HierarchyMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.run != nil {
		edges = append(edges, hierarchy.EdgeRun)
	}
	if m.parent_entity != nil {
		edges = append(edges, hierarchy.EdgeParentEntity)
	}
	if m.child_entity != nil {
		edges = append(edges, hierarchy.EdgeChildEntity)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HierarchyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hierarchy.EdgeRun:
		if id := m.run; id != nil {
			return []ent.Value{*id}
		}
	case hierarchy.EdgeParentEntity:
		if id := m.parent_entity; id != nil {
			return []ent.Value{*id}
		}
	case hierarchy.EdgeChildEntity:
		if id := m.child_entity; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HierarchyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HierarchyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HierarchyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedrun {
		edges = append(edges, hierarchy.EdgeRun)
	}
	if m.clearedparent_entity {
		edges = append(edges, hierarchy.EdgeParentEntity)
	}
	if m.clearedchild_entity {
		edges = append(edges, hierarchy.EdgeChildEntity)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HierarchyMutation) EdgeCleared(name string) bool {
	switch name {
	case hierarchy.EdgeRun:
		return m.clearedrun
	case hierarchy.EdgeParentEntity:
		return m.clearedparent_entity
	case hierarchy.EdgeChildEntity:
		return m.clearedchild_entity
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HierarchyMutation) ClearEdge(name string) error {
	switch name {
	case hierarchy.EdgeRun:
		m.ClearRun()
		return nil
	case hierarchy.EdgeParentEntity:
		m.ClearParentEntity()
		return nil
	case hierarchy.EdgeChildEntity:
		m.ClearChildEntity()
		return nil
	}
	return fmt.Errorf("unknown Hierarchy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HierarchyMutation) ResetEdge(name string) error {
	switch name {
	case hierarchy.EdgeRun:
		m.ResetRun()
		return nil
	case hierarchy.EdgeParentEntity:
		m.ResetParentEntity()
		return nil
	case hierarchy.EdgeChildEntity:
		m.ResetChildEntity()
		return nil
	}
	return fmt.Errorf("unknown Hierarchy edge %s", name)
}

// QueueMutation represents an operation that mutates the Queue nodes in the graph.
type QueueMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	name            *string
	clearedFields   map[string]struct{}
	entities        map[int]struct{}
	removedentities map[int]struct{}
	clearedentities bool
	done            bool
	oldValue        func(context.Context) (*Queue, error)
	predicates      []predicate.Queue
}

var _ ent.Mutation = (*QueueMutation)(nil)

// queueOption allows management of the mutation configuration using functional options.
type queueOption func(*QueueMutation)

// newQueueMutation creates new mutation for the Queue entity.
func newQueueMutation(c config, op Op, opts ...queueOption) *QueueMutation {
	m := &QueueMutation{
		config:        c,
		op:            op,
		typ:           TypeQueue,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withQueueID sets the ID field of the mutation.
func withQueueID(id int) queueOption {
	return func(m *QueueMutation) {
		var (
			err   error
			once  sync.Once
			value *Queue
		)
		m.oldValue = func(ctx context.Context) (*Queue, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Queue.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withQueue sets the old Queue of the mutation.
func withQueue(node *Queue) queueOption {
	return func(m *QueueMutation) {
		m.oldValue = func(context.Context) (*Queue, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m QueueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m QueueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *QueueMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *QueueMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Queue.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *QueueMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *QueueMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Queue entity.
// If the Queue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QueueMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *QueueMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *QueueMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *QueueMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Queue entity.
// If the Queue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QueueMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *QueueMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *QueueMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *QueueMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Queue entity.
// If the Queue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QueueMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *QueueMutation) ResetName() {
	m.name = nil
}

// AddEntityIDs adds the "entities" edge to the Entity entity by ids.
func (m *QueueMutation) AddEntityIDs(ids ...int) {
	if m.entities == nil {
		m.entities = make(map[int]struct{})
	}
	for i := range ids {
		m.entities[ids[i]] = struct{}{}
	}
}

// ClearEntities clears the "entities" edge to the Entity entity.
func (m *QueueMutation) ClearEntities() {
	m.clearedentities = true
}

// EntitiesCleared reports if the "entities" edge to the Entity entity was cleared.
func (m *QueueMutation) EntitiesCleared() bool {
	return m.clearedentities
}

// RemoveEntityIDs removes the "entities" edge to the Entity entity by IDs.
func (m *QueueMutation) RemoveEntityIDs(ids ...int) {
	if m.removedentities == nil {
		m.removedentities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.entities, ids[i])
		m.removedentities[ids[i]] = struct{}{}
	}
}

// RemovedEntities returns the removed IDs of the "entities" edge to the Entity entity.
func (m *QueueMutation) RemovedEntitiesIDs() (ids []int) {
	for id := range m.removedentities {
		ids = append(ids, id)
	}
	return
}

// EntitiesIDs returns the "entities" edge IDs in the mutation.
func (m *QueueMutation) EntitiesIDs() (ids []int) {
	for id := range m.entities {
		ids = append(ids, id)
	}
	return
}

// ResetEntities resets all changes to the "entities" edge.
func (m *QueueMutation) ResetEntities() {
	m.entities = nil
	m.clearedentities = false
	m.removedentities = nil
}

// Where appends a list predicates to the QueueMutation builder.
func (m *QueueMutation) Where(ps ...predicate.Queue) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the QueueMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *QueueMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Queue, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *QueueMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *QueueMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Queue).
func (m *QueueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *QueueMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, queue.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, queue.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, queue.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *QueueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case queue.FieldCreatedAt:
		return m.CreatedAt()
	case queue.FieldUpdatedAt:
		return m.UpdatedAt()
	case queue.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *QueueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case queue.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case queue.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case queue.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Queue field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QueueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case queue.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case queue.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case queue.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Queue field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *QueueMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *QueueMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QueueMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Queue numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *QueueMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *QueueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *QueueMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Queue nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *QueueMutation) ResetField(name string) error {
	switch name {
	case queue.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case queue.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case queue.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Queue field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *QueueMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.entities != nil {
		edges = append(edges, queue.EdgeEntities)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *QueueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case queue.EdgeEntities:
		ids := make([]ent.Value, 0, len(m.entities))
		for id := range m.entities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *QueueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedentities != nil {
		edges = append(edges, queue.EdgeEntities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *QueueMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case queue.EdgeEntities:
		ids := make([]ent.Value, 0, len(m.removedentities))
		for id := range m.removedentities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *QueueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedentities {
		edges = append(edges, queue.EdgeEntities)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *QueueMutation) EdgeCleared(name string) bool {
	switch name {
	case queue.EdgeEntities:
		return m.clearedentities
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *QueueMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Queue unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *QueueMutation) ResetEdge(name string) error {
	switch name {
	case queue.EdgeEntities:
		m.ResetEntities()
		return nil
	}
	return fmt.Errorf("unknown Queue edge %s", name)
}

// RunMutation represents an operation that mutates the Run nodes in the graph.
type RunMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	status             *run.Status
	clearedFields      map[string]struct{}
	entities           map[int]struct{}
	removedentities    map[int]struct{}
	clearedentities    bool
	hierarchies        map[int]struct{}
	removedhierarchies map[int]struct{}
	clearedhierarchies bool
	done               bool
	oldValue           func(context.Context) (*Run, error)
	predicates         []predicate.Run
}

var _ ent.Mutation = (*RunMutation)(nil)

// runOption allows management of the mutation configuration using functional options.
type runOption func(*RunMutation)

// newRunMutation creates new mutation for the Run entity.
func newRunMutation(c config, op Op, opts ...runOption) *RunMutation {
	m := &RunMutation{
		config:        c,
		op:            op,
		typ:           TypeRun,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRunID sets the ID field of the mutation.
func withRunID(id int) runOption {
	return func(m *RunMutation) {
		var (
			err   error
			once  sync.Once
			value *Run
		)
		m.oldValue = func(ctx context.Context) (*Run, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Run.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRun sets the old Run of the mutation.
func withRun(node *Run) runOption {
	return func(m *RunMutation) {
		m.oldValue = func(context.Context) (*Run, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RunMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RunMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RunMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RunMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Run.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RunMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RunMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Run entity.
// If the Run object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RunMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RunMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RunMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Run entity.
// If the Run object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RunMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *RunMutation) SetStatus(r run.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *RunMutation) Status() (r run.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Run entity.
// If the Run object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunMutation) OldStatus(ctx context.Context) (v run.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RunMutation) ResetStatus() {
	m.status = nil
}

// AddEntityIDs adds the "entities" edge to the Entity entity by ids.
func (m *RunMutation) AddEntityIDs(ids ...int) {
	if m.entities == nil {
		m.entities = make(map[int]struct{})
	}
	for i := range ids {
		m.entities[ids[i]] = struct{}{}
	}
}

// ClearEntities clears the "entities" edge to the Entity entity.
func (m *RunMutation) ClearEntities() {
	m.clearedentities = true
}

// EntitiesCleared reports if the "entities" edge to the Entity entity was cleared.
func (m *RunMutation) EntitiesCleared() bool {
	return m.clearedentities
}

// RemoveEntityIDs removes the "entities" edge to the Entity entity by IDs.
func (m *RunMutation) RemoveEntityIDs(ids ...int) {
	if m.removedentities == nil {
		m.removedentities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.entities, ids[i])
		m.removedentities[ids[i]] = struct{}{}
	}
}

// RemovedEntities returns the removed IDs of the "entities" edge to the Entity entity.
func (m *RunMutation) RemovedEntitiesIDs() (ids []int) {
	for id := range m.removedentities {
		ids = append(ids, id)
	}
	return
}

// EntitiesIDs returns the "entities" edge IDs in the mutation.
func (m *RunMutation) EntitiesIDs() (ids []int) {
	for id := range m.entities {
		ids = append(ids, id)
	}
	return
}

// ResetEntities resets all changes to the "entities" edge.
func (m *RunMutation) ResetEntities() {
	m.entities = nil
	m.clearedentities = false
	m.removedentities = nil
}

// AddHierarchyIDs adds the "hierarchies" edge to the Hierarchy entity by ids.
func (m *RunMutation) AddHierarchyIDs(ids ...int) {
	if m.hierarchies == nil {
		m.hierarchies = make(map[int]struct{})
	}
	for i := range ids {
		m.hierarchies[ids[i]] = struct{}{}
	}
}

// ClearHierarchies clears the "hierarchies" edge to the Hierarchy entity.
func (m *RunMutation) ClearHierarchies() {
	m.clearedhierarchies = true
}

// HierarchiesCleared reports if the "hierarchies" edge to the Hierarchy entity was cleared.
func (m *RunMutation) HierarchiesCleared() bool {
	return m.clearedhierarchies
}

// RemoveHierarchyIDs removes the "hierarchies" edge to the Hierarchy entity by IDs.
func (m *RunMutation) RemoveHierarchyIDs(ids ...int) {
	if m.removedhierarchies == nil {
		m.removedhierarchies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.hierarchies, ids[i])
		m.removedhierarchies[ids[i]] = struct{}{}
	}
}

// RemovedHierarchies returns the removed IDs of the "hierarchies" edge to the Hierarchy entity.
func (m *RunMutation) RemovedHierarchiesIDs() (ids []int) {
	for id := range m.removedhierarchies {
		ids = append(ids, id)
	}
	return
}

// HierarchiesIDs returns the "hierarchies" edge IDs in the mutation.
func (m *RunMutation) HierarchiesIDs() (ids []int) {
	for id := range m.hierarchies {
		ids = append(ids, id)
	}
	return
}

// ResetHierarchies resets all changes to the "hierarchies" edge.
func (m *RunMutation) ResetHierarchies() {
	m.hierarchies = nil
	m.clearedhierarchies = false
	m.removedhierarchies = nil
}

// Where appends a list predicates to the RunMutation builder.
func (m *RunMutation) Where(ps ...predicate.Run) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RunMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RunMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Run, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RunMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RunMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Run).
func (m *RunMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RunMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, run.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, run.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, run.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RunMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case run.FieldCreatedAt:
		return m.CreatedAt()
	case run.FieldUpdatedAt:
		return m.UpdatedAt()
	case run.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RunMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case run.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case run.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case run.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Run field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RunMutation) SetField(name string, value ent.Value) error {
	switch name {
	case run.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case run.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case run.FieldStatus:
		v, ok := value.(run.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Run field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RunMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RunMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RunMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Run numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RunMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RunMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RunMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Run nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RunMutation) ResetField(name string) error {
	switch name {
	case run.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case run.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case run.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Run field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RunMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.entities != nil {
		edges = append(edges, run.EdgeEntities)
	}
	if m.hierarchies != nil {
		edges = append(edges, run.EdgeHierarchies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RunMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case run.EdgeEntities:
		ids := make([]ent.Value, 0, len(m.entities))
		for id := range m.entities {
			ids = append(ids, id)
		}
		return ids
	case run.EdgeHierarchies:
		ids := make([]ent.Value, 0, len(m.hierarchies))
		for id := range m.hierarchies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RunMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedentities != nil {
		edges = append(edges, run.EdgeEntities)
	}
	if m.removedhierarchies != nil {
		edges = append(edges, run.EdgeHierarchies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RunMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case run.EdgeEntities:
		ids := make([]ent.Value, 0, len(m.removedentities))
		for id := range m.removedentities {
			ids = append(ids, id)
		}
		return ids
	case run.EdgeHierarchies:
		ids := make([]ent.Value, 0, len(m.removedhierarchies))
		for id := range m.removedhierarchies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RunMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedentities {
		edges = append(edges, run.EdgeEntities)
	}
	if m.clearedhierarchies {
		edges = append(edges, run.EdgeHierarchies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RunMutation) EdgeCleared(name string) bool {
	switch name {
	case run.EdgeEntities:
		return m.clearedentities
	case run.EdgeHierarchies:
		return m.clearedhierarchies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RunMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Run unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RunMutation) ResetEdge(name string) error {
	switch name {
	case run.EdgeEntities:
		m.ResetEntities()
		return nil
	case run.EdgeHierarchies:
		m.ResetHierarchies()
		return nil
	}
	return fmt.Errorf("unknown Run edge %s", name)
}

// SagaDataMutation represents an operation that mutates the SagaData nodes in the graph.
type SagaDataMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	compensating            *bool
	compensation_data       *[][]uint8
	appendcompensation_data [][]uint8
	clearedFields           map[string]struct{}
	entity                  *int
	clearedentity           bool
	done                    bool
	oldValue                func(context.Context) (*SagaData, error)
	predicates              []predicate.SagaData
}

var _ ent.Mutation = (*SagaDataMutation)(nil)

// sagadataOption allows management of the mutation configuration using functional options.
type sagadataOption func(*SagaDataMutation)

// newSagaDataMutation creates new mutation for the SagaData entity.
func newSagaDataMutation(c config, op Op, opts ...sagadataOption) *SagaDataMutation {
	m := &SagaDataMutation{
		config:        c,
		op:            op,
		typ:           TypeSagaData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSagaDataID sets the ID field of the mutation.
func withSagaDataID(id int) sagadataOption {
	return func(m *SagaDataMutation) {
		var (
			err   error
			once  sync.Once
			value *SagaData
		)
		m.oldValue = func(ctx context.Context) (*SagaData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SagaData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSagaData sets the old SagaData of the mutation.
func withSagaData(node *SagaData) sagadataOption {
	return func(m *SagaDataMutation) {
		m.oldValue = func(context.Context) (*SagaData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SagaDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SagaDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SagaDataMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SagaDataMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SagaData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCompensating sets the "compensating" field.
func (m *SagaDataMutation) SetCompensating(b bool) {
	m.compensating = &b
}

// Compensating returns the value of the "compensating" field in the mutation.
func (m *SagaDataMutation) Compensating() (r bool, exists bool) {
	v := m.compensating
	if v == nil {
		return
	}
	return *v, true
}

// OldCompensating returns the old "compensating" field's value of the SagaData entity.
// If the SagaData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaDataMutation) OldCompensating(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompensating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompensating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompensating: %w", err)
	}
	return oldValue.Compensating, nil
}

// ResetCompensating resets all changes to the "compensating" field.
func (m *SagaDataMutation) ResetCompensating() {
	m.compensating = nil
}

// SetCompensationData sets the "compensation_data" field.
func (m *SagaDataMutation) SetCompensationData(u [][]uint8) {
	m.compensation_data = &u
	m.appendcompensation_data = nil
}

// CompensationData returns the value of the "compensation_data" field in the mutation.
func (m *SagaDataMutation) CompensationData() (r [][]uint8, exists bool) {
	v := m.compensation_data
	if v == nil {
		return
	}
	return *v, true
}

// OldCompensationData returns the old "compensation_data" field's value of the SagaData entity.
// If the SagaData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaDataMutation) OldCompensationData(ctx context.Context) (v [][]uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompensationData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompensationData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompensationData: %w", err)
	}
	return oldValue.CompensationData, nil
}

// AppendCompensationData adds u to the "compensation_data" field.
func (m *SagaDataMutation) AppendCompensationData(u [][]uint8) {
	m.appendcompensation_data = append(m.appendcompensation_data, u...)
}

// AppendedCompensationData returns the list of values that were appended to the "compensation_data" field in this mutation.
func (m *SagaDataMutation) AppendedCompensationData() ([][]uint8, bool) {
	if len(m.appendcompensation_data) == 0 {
		return nil, false
	}
	return m.appendcompensation_data, true
}

// ClearCompensationData clears the value of the "compensation_data" field.
func (m *SagaDataMutation) ClearCompensationData() {
	m.compensation_data = nil
	m.appendcompensation_data = nil
	m.clearedFields[sagadata.FieldCompensationData] = struct{}{}
}

// CompensationDataCleared returns if the "compensation_data" field was cleared in this mutation.
func (m *SagaDataMutation) CompensationDataCleared() bool {
	_, ok := m.clearedFields[sagadata.FieldCompensationData]
	return ok
}

// ResetCompensationData resets all changes to the "compensation_data" field.
func (m *SagaDataMutation) ResetCompensationData() {
	m.compensation_data = nil
	m.appendcompensation_data = nil
	delete(m.clearedFields, sagadata.FieldCompensationData)
}

// SetEntityID sets the "entity" edge to the Entity entity by id.
func (m *SagaDataMutation) SetEntityID(id int) {
	m.entity = &id
}

// ClearEntity clears the "entity" edge to the Entity entity.
func (m *SagaDataMutation) ClearEntity() {
	m.clearedentity = true
}

// EntityCleared reports if the "entity" edge to the Entity entity was cleared.
func (m *SagaDataMutation) EntityCleared() bool {
	return m.clearedentity
}

// EntityID returns the "entity" edge ID in the mutation.
func (m *SagaDataMutation) EntityID() (id int, exists bool) {
	if m.entity != nil {
		return *m.entity, true
	}
	return
}

// EntityIDs returns the "entity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntityID instead. It exists only for internal usage by the builders.
func (m *SagaDataMutation) EntityIDs() (ids []int) {
	if id := m.entity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntity resets all changes to the "entity" edge.
func (m *SagaDataMutation) ResetEntity() {
	m.entity = nil
	m.clearedentity = false
}

// Where appends a list predicates to the SagaDataMutation builder.
func (m *SagaDataMutation) Where(ps ...predicate.SagaData) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SagaDataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SagaDataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SagaData, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SagaDataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SagaDataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SagaData).
func (m *SagaDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SagaDataMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.compensating != nil {
		fields = append(fields, sagadata.FieldCompensating)
	}
	if m.compensation_data != nil {
		fields = append(fields, sagadata.FieldCompensationData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SagaDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sagadata.FieldCompensating:
		return m.Compensating()
	case sagadata.FieldCompensationData:
		return m.CompensationData()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SagaDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sagadata.FieldCompensating:
		return m.OldCompensating(ctx)
	case sagadata.FieldCompensationData:
		return m.OldCompensationData(ctx)
	}
	return nil, fmt.Errorf("unknown SagaData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SagaDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sagadata.FieldCompensating:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompensating(v)
		return nil
	case sagadata.FieldCompensationData:
		v, ok := value.([][]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompensationData(v)
		return nil
	}
	return fmt.Errorf("unknown SagaData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SagaDataMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SagaDataMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SagaDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SagaData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SagaDataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sagadata.FieldCompensationData) {
		fields = append(fields, sagadata.FieldCompensationData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SagaDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SagaDataMutation) ClearField(name string) error {
	switch name {
	case sagadata.FieldCompensationData:
		m.ClearCompensationData()
		return nil
	}
	return fmt.Errorf("unknown SagaData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SagaDataMutation) ResetField(name string) error {
	switch name {
	case sagadata.FieldCompensating:
		m.ResetCompensating()
		return nil
	case sagadata.FieldCompensationData:
		m.ResetCompensationData()
		return nil
	}
	return fmt.Errorf("unknown SagaData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SagaDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.entity != nil {
		edges = append(edges, sagadata.EdgeEntity)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SagaDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sagadata.EdgeEntity:
		if id := m.entity; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SagaDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SagaDataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SagaDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedentity {
		edges = append(edges, sagadata.EdgeEntity)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SagaDataMutation) EdgeCleared(name string) bool {
	switch name {
	case sagadata.EdgeEntity:
		return m.clearedentity
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SagaDataMutation) ClearEdge(name string) error {
	switch name {
	case sagadata.EdgeEntity:
		m.ClearEntity()
		return nil
	}
	return fmt.Errorf("unknown SagaData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SagaDataMutation) ResetEdge(name string) error {
	switch name {
	case sagadata.EdgeEntity:
		m.ResetEntity()
		return nil
	}
	return fmt.Errorf("unknown SagaData edge %s", name)
}

// SagaExecutionMutation represents an operation that mutates the SagaExecution nodes in the graph.
type SagaExecutionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	step_type             *sagaexecution.StepType
	clearedFields         map[string]struct{}
	execution             *int
	clearedexecution      bool
	execution_data        *int
	clearedexecution_data bool
	done                  bool
	oldValue              func(context.Context) (*SagaExecution, error)
	predicates            []predicate.SagaExecution
}

var _ ent.Mutation = (*SagaExecutionMutation)(nil)

// sagaexecutionOption allows management of the mutation configuration using functional options.
type sagaexecutionOption func(*SagaExecutionMutation)

// newSagaExecutionMutation creates new mutation for the SagaExecution entity.
func newSagaExecutionMutation(c config, op Op, opts ...sagaexecutionOption) *SagaExecutionMutation {
	m := &SagaExecutionMutation{
		config:        c,
		op:            op,
		typ:           TypeSagaExecution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSagaExecutionID sets the ID field of the mutation.
func withSagaExecutionID(id int) sagaexecutionOption {
	return func(m *SagaExecutionMutation) {
		var (
			err   error
			once  sync.Once
			value *SagaExecution
		)
		m.oldValue = func(ctx context.Context) (*SagaExecution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SagaExecution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSagaExecution sets the old SagaExecution of the mutation.
func withSagaExecution(node *SagaExecution) sagaexecutionOption {
	return func(m *SagaExecutionMutation) {
		m.oldValue = func(context.Context) (*SagaExecution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SagaExecutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SagaExecutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SagaExecutionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SagaExecutionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SagaExecution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStepType sets the "step_type" field.
func (m *SagaExecutionMutation) SetStepType(st sagaexecution.StepType) {
	m.step_type = &st
}

// StepType returns the value of the "step_type" field in the mutation.
func (m *SagaExecutionMutation) StepType() (r sagaexecution.StepType, exists bool) {
	v := m.step_type
	if v == nil {
		return
	}
	return *v, true
}

// OldStepType returns the old "step_type" field's value of the SagaExecution entity.
// If the SagaExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaExecutionMutation) OldStepType(ctx context.Context) (v sagaexecution.StepType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStepType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStepType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStepType: %w", err)
	}
	return oldValue.StepType, nil
}

// ResetStepType resets all changes to the "step_type" field.
func (m *SagaExecutionMutation) ResetStepType() {
	m.step_type = nil
}

// SetExecutionID sets the "execution" edge to the Execution entity by id.
func (m *SagaExecutionMutation) SetExecutionID(id int) {
	m.execution = &id
}

// ClearExecution clears the "execution" edge to the Execution entity.
func (m *SagaExecutionMutation) ClearExecution() {
	m.clearedexecution = true
}

// ExecutionCleared reports if the "execution" edge to the Execution entity was cleared.
func (m *SagaExecutionMutation) ExecutionCleared() bool {
	return m.clearedexecution
}

// ExecutionID returns the "execution" edge ID in the mutation.
func (m *SagaExecutionMutation) ExecutionID() (id int, exists bool) {
	if m.execution != nil {
		return *m.execution, true
	}
	return
}

// ExecutionIDs returns the "execution" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExecutionID instead. It exists only for internal usage by the builders.
func (m *SagaExecutionMutation) ExecutionIDs() (ids []int) {
	if id := m.execution; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExecution resets all changes to the "execution" edge.
func (m *SagaExecutionMutation) ResetExecution() {
	m.execution = nil
	m.clearedexecution = false
}

// SetExecutionDataID sets the "execution_data" edge to the SagaExecutionData entity by id.
func (m *SagaExecutionMutation) SetExecutionDataID(id int) {
	m.execution_data = &id
}

// ClearExecutionData clears the "execution_data" edge to the SagaExecutionData entity.
func (m *SagaExecutionMutation) ClearExecutionData() {
	m.clearedexecution_data = true
}

// ExecutionDataCleared reports if the "execution_data" edge to the SagaExecutionData entity was cleared.
func (m *SagaExecutionMutation) ExecutionDataCleared() bool {
	return m.clearedexecution_data
}

// ExecutionDataID returns the "execution_data" edge ID in the mutation.
func (m *SagaExecutionMutation) ExecutionDataID() (id int, exists bool) {
	if m.execution_data != nil {
		return *m.execution_data, true
	}
	return
}

// ExecutionDataIDs returns the "execution_data" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExecutionDataID instead. It exists only for internal usage by the builders.
func (m *SagaExecutionMutation) ExecutionDataIDs() (ids []int) {
	if id := m.execution_data; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExecutionData resets all changes to the "execution_data" edge.
func (m *SagaExecutionMutation) ResetExecutionData() {
	m.execution_data = nil
	m.clearedexecution_data = false
}

// Where appends a list predicates to the SagaExecutionMutation builder.
func (m *SagaExecutionMutation) Where(ps ...predicate.SagaExecution) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SagaExecutionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SagaExecutionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SagaExecution, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SagaExecutionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SagaExecutionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SagaExecution).
func (m *SagaExecutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SagaExecutionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.step_type != nil {
		fields = append(fields, sagaexecution.FieldStepType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SagaExecutionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sagaexecution.FieldStepType:
		return m.StepType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SagaExecutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sagaexecution.FieldStepType:
		return m.OldStepType(ctx)
	}
	return nil, fmt.Errorf("unknown SagaExecution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SagaExecutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sagaexecution.FieldStepType:
		v, ok := value.(sagaexecution.StepType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStepType(v)
		return nil
	}
	return fmt.Errorf("unknown SagaExecution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SagaExecutionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SagaExecutionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SagaExecutionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SagaExecution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SagaExecutionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SagaExecutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SagaExecutionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SagaExecution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SagaExecutionMutation) ResetField(name string) error {
	switch name {
	case sagaexecution.FieldStepType:
		m.ResetStepType()
		return nil
	}
	return fmt.Errorf("unknown SagaExecution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SagaExecutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.execution != nil {
		edges = append(edges, sagaexecution.EdgeExecution)
	}
	if m.execution_data != nil {
		edges = append(edges, sagaexecution.EdgeExecutionData)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SagaExecutionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sagaexecution.EdgeExecution:
		if id := m.execution; id != nil {
			return []ent.Value{*id}
		}
	case sagaexecution.EdgeExecutionData:
		if id := m.execution_data; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SagaExecutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SagaExecutionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SagaExecutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedexecution {
		edges = append(edges, sagaexecution.EdgeExecution)
	}
	if m.clearedexecution_data {
		edges = append(edges, sagaexecution.EdgeExecutionData)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SagaExecutionMutation) EdgeCleared(name string) bool {
	switch name {
	case sagaexecution.EdgeExecution:
		return m.clearedexecution
	case sagaexecution.EdgeExecutionData:
		return m.clearedexecution_data
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SagaExecutionMutation) ClearEdge(name string) error {
	switch name {
	case sagaexecution.EdgeExecution:
		m.ClearExecution()
		return nil
	case sagaexecution.EdgeExecutionData:
		m.ClearExecutionData()
		return nil
	}
	return fmt.Errorf("unknown SagaExecution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SagaExecutionMutation) ResetEdge(name string) error {
	switch name {
	case sagaexecution.EdgeExecution:
		m.ResetExecution()
		return nil
	case sagaexecution.EdgeExecutionData:
		m.ResetExecutionData()
		return nil
	}
	return fmt.Errorf("unknown SagaExecution edge %s", name)
}

// SagaExecutionDataMutation represents an operation that mutates the SagaExecutionData nodes in the graph.
type SagaExecutionDataMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	last_heartbeat        *time.Time
	output                *[][]uint8
	appendoutput          [][]uint8
	hasOutput             *bool
	clearedFields         map[string]struct{}
	saga_execution        *int
	clearedsaga_execution bool
	done                  bool
	oldValue              func(context.Context) (*SagaExecutionData, error)
	predicates            []predicate.SagaExecutionData
}

var _ ent.Mutation = (*SagaExecutionDataMutation)(nil)

// sagaexecutiondataOption allows management of the mutation configuration using functional options.
type sagaexecutiondataOption func(*SagaExecutionDataMutation)

// newSagaExecutionDataMutation creates new mutation for the SagaExecutionData entity.
func newSagaExecutionDataMutation(c config, op Op, opts ...sagaexecutiondataOption) *SagaExecutionDataMutation {
	m := &SagaExecutionDataMutation{
		config:        c,
		op:            op,
		typ:           TypeSagaExecutionData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSagaExecutionDataID sets the ID field of the mutation.
func withSagaExecutionDataID(id int) sagaexecutiondataOption {
	return func(m *SagaExecutionDataMutation) {
		var (
			err   error
			once  sync.Once
			value *SagaExecutionData
		)
		m.oldValue = func(ctx context.Context) (*SagaExecutionData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SagaExecutionData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSagaExecutionData sets the old SagaExecutionData of the mutation.
func withSagaExecutionData(node *SagaExecutionData) sagaexecutiondataOption {
	return func(m *SagaExecutionDataMutation) {
		m.oldValue = func(context.Context) (*SagaExecutionData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SagaExecutionDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SagaExecutionDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SagaExecutionDataMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SagaExecutionDataMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SagaExecutionData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLastHeartbeat sets the "last_heartbeat" field.
func (m *SagaExecutionDataMutation) SetLastHeartbeat(t time.Time) {
	m.last_heartbeat = &t
}

// LastHeartbeat returns the value of the "last_heartbeat" field in the mutation.
func (m *SagaExecutionDataMutation) LastHeartbeat() (r time.Time, exists bool) {
	v := m.last_heartbeat
	if v == nil {
		return
	}
	return *v, true
}

// OldLastHeartbeat returns the old "last_heartbeat" field's value of the SagaExecutionData entity.
// If the SagaExecutionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaExecutionDataMutation) OldLastHeartbeat(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastHeartbeat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastHeartbeat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastHeartbeat: %w", err)
	}
	return oldValue.LastHeartbeat, nil
}

// ClearLastHeartbeat clears the value of the "last_heartbeat" field.
func (m *SagaExecutionDataMutation) ClearLastHeartbeat() {
	m.last_heartbeat = nil
	m.clearedFields[sagaexecutiondata.FieldLastHeartbeat] = struct{}{}
}

// LastHeartbeatCleared returns if the "last_heartbeat" field was cleared in this mutation.
func (m *SagaExecutionDataMutation) LastHeartbeatCleared() bool {
	_, ok := m.clearedFields[sagaexecutiondata.FieldLastHeartbeat]
	return ok
}

// ResetLastHeartbeat resets all changes to the "last_heartbeat" field.
func (m *SagaExecutionDataMutation) ResetLastHeartbeat() {
	m.last_heartbeat = nil
	delete(m.clearedFields, sagaexecutiondata.FieldLastHeartbeat)
}

// SetOutput sets the "output" field.
func (m *SagaExecutionDataMutation) SetOutput(u [][]uint8) {
	m.output = &u
	m.appendoutput = nil
}

// Output returns the value of the "output" field in the mutation.
func (m *SagaExecutionDataMutation) Output() (r [][]uint8, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the SagaExecutionData entity.
// If the SagaExecutionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaExecutionDataMutation) OldOutput(ctx context.Context) (v [][]uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// AppendOutput adds u to the "output" field.
func (m *SagaExecutionDataMutation) AppendOutput(u [][]uint8) {
	m.appendoutput = append(m.appendoutput, u...)
}

// AppendedOutput returns the list of values that were appended to the "output" field in this mutation.
func (m *SagaExecutionDataMutation) AppendedOutput() ([][]uint8, bool) {
	if len(m.appendoutput) == 0 {
		return nil, false
	}
	return m.appendoutput, true
}

// ClearOutput clears the value of the "output" field.
func (m *SagaExecutionDataMutation) ClearOutput() {
	m.output = nil
	m.appendoutput = nil
	m.clearedFields[sagaexecutiondata.FieldOutput] = struct{}{}
}

// OutputCleared returns if the "output" field was cleared in this mutation.
func (m *SagaExecutionDataMutation) OutputCleared() bool {
	_, ok := m.clearedFields[sagaexecutiondata.FieldOutput]
	return ok
}

// ResetOutput resets all changes to the "output" field.
func (m *SagaExecutionDataMutation) ResetOutput() {
	m.output = nil
	m.appendoutput = nil
	delete(m.clearedFields, sagaexecutiondata.FieldOutput)
}

// SetHasOutput sets the "hasOutput" field.
func (m *SagaExecutionDataMutation) SetHasOutput(b bool) {
	m.hasOutput = &b
}

// HasOutput returns the value of the "hasOutput" field in the mutation.
func (m *SagaExecutionDataMutation) HasOutput() (r bool, exists bool) {
	v := m.hasOutput
	if v == nil {
		return
	}
	return *v, true
}

// OldHasOutput returns the old "hasOutput" field's value of the SagaExecutionData entity.
// If the SagaExecutionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaExecutionDataMutation) OldHasOutput(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasOutput: %w", err)
	}
	return oldValue.HasOutput, nil
}

// ResetHasOutput resets all changes to the "hasOutput" field.
func (m *SagaExecutionDataMutation) ResetHasOutput() {
	m.hasOutput = nil
}

// SetSagaExecutionID sets the "saga_execution" edge to the SagaExecution entity by id.
func (m *SagaExecutionDataMutation) SetSagaExecutionID(id int) {
	m.saga_execution = &id
}

// ClearSagaExecution clears the "saga_execution" edge to the SagaExecution entity.
func (m *SagaExecutionDataMutation) ClearSagaExecution() {
	m.clearedsaga_execution = true
}

// SagaExecutionCleared reports if the "saga_execution" edge to the SagaExecution entity was cleared.
func (m *SagaExecutionDataMutation) SagaExecutionCleared() bool {
	return m.clearedsaga_execution
}

// SagaExecutionID returns the "saga_execution" edge ID in the mutation.
func (m *SagaExecutionDataMutation) SagaExecutionID() (id int, exists bool) {
	if m.saga_execution != nil {
		return *m.saga_execution, true
	}
	return
}

// SagaExecutionIDs returns the "saga_execution" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SagaExecutionID instead. It exists only for internal usage by the builders.
func (m *SagaExecutionDataMutation) SagaExecutionIDs() (ids []int) {
	if id := m.saga_execution; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSagaExecution resets all changes to the "saga_execution" edge.
func (m *SagaExecutionDataMutation) ResetSagaExecution() {
	m.saga_execution = nil
	m.clearedsaga_execution = false
}

// Where appends a list predicates to the SagaExecutionDataMutation builder.
func (m *SagaExecutionDataMutation) Where(ps ...predicate.SagaExecutionData) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SagaExecutionDataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SagaExecutionDataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SagaExecutionData, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SagaExecutionDataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SagaExecutionDataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SagaExecutionData).
func (m *SagaExecutionDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SagaExecutionDataMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.last_heartbeat != nil {
		fields = append(fields, sagaexecutiondata.FieldLastHeartbeat)
	}
	if m.output != nil {
		fields = append(fields, sagaexecutiondata.FieldOutput)
	}
	if m.hasOutput != nil {
		fields = append(fields, sagaexecutiondata.FieldHasOutput)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SagaExecutionDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sagaexecutiondata.FieldLastHeartbeat:
		return m.LastHeartbeat()
	case sagaexecutiondata.FieldOutput:
		return m.Output()
	case sagaexecutiondata.FieldHasOutput:
		return m.HasOutput()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SagaExecutionDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sagaexecutiondata.FieldLastHeartbeat:
		return m.OldLastHeartbeat(ctx)
	case sagaexecutiondata.FieldOutput:
		return m.OldOutput(ctx)
	case sagaexecutiondata.FieldHasOutput:
		return m.OldHasOutput(ctx)
	}
	return nil, fmt.Errorf("unknown SagaExecutionData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SagaExecutionDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sagaexecutiondata.FieldLastHeartbeat:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastHeartbeat(v)
		return nil
	case sagaexecutiondata.FieldOutput:
		v, ok := value.([][]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case sagaexecutiondata.FieldHasOutput:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasOutput(v)
		return nil
	}
	return fmt.Errorf("unknown SagaExecutionData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SagaExecutionDataMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SagaExecutionDataMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SagaExecutionDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SagaExecutionData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SagaExecutionDataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sagaexecutiondata.FieldLastHeartbeat) {
		fields = append(fields, sagaexecutiondata.FieldLastHeartbeat)
	}
	if m.FieldCleared(sagaexecutiondata.FieldOutput) {
		fields = append(fields, sagaexecutiondata.FieldOutput)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SagaExecutionDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SagaExecutionDataMutation) ClearField(name string) error {
	switch name {
	case sagaexecutiondata.FieldLastHeartbeat:
		m.ClearLastHeartbeat()
		return nil
	case sagaexecutiondata.FieldOutput:
		m.ClearOutput()
		return nil
	}
	return fmt.Errorf("unknown SagaExecutionData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SagaExecutionDataMutation) ResetField(name string) error {
	switch name {
	case sagaexecutiondata.FieldLastHeartbeat:
		m.ResetLastHeartbeat()
		return nil
	case sagaexecutiondata.FieldOutput:
		m.ResetOutput()
		return nil
	case sagaexecutiondata.FieldHasOutput:
		m.ResetHasOutput()
		return nil
	}
	return fmt.Errorf("unknown SagaExecutionData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SagaExecutionDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.saga_execution != nil {
		edges = append(edges, sagaexecutiondata.EdgeSagaExecution)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SagaExecutionDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sagaexecutiondata.EdgeSagaExecution:
		if id := m.saga_execution; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SagaExecutionDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SagaExecutionDataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SagaExecutionDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsaga_execution {
		edges = append(edges, sagaexecutiondata.EdgeSagaExecution)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SagaExecutionDataMutation) EdgeCleared(name string) bool {
	switch name {
	case sagaexecutiondata.EdgeSagaExecution:
		return m.clearedsaga_execution
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SagaExecutionDataMutation) ClearEdge(name string) error {
	switch name {
	case sagaexecutiondata.EdgeSagaExecution:
		m.ClearSagaExecution()
		return nil
	}
	return fmt.Errorf("unknown SagaExecutionData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SagaExecutionDataMutation) ResetEdge(name string) error {
	switch name {
	case sagaexecutiondata.EdgeSagaExecution:
		m.ResetSagaExecution()
		return nil
	}
	return fmt.Errorf("unknown SagaExecutionData edge %s", name)
}

// SideEffectDataMutation represents an operation that mutates the SideEffectData nodes in the graph.
type SideEffectDataMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	entity        *int
	clearedentity bool
	done          bool
	oldValue      func(context.Context) (*SideEffectData, error)
	predicates    []predicate.SideEffectData
}

var _ ent.Mutation = (*SideEffectDataMutation)(nil)

// sideeffectdataOption allows management of the mutation configuration using functional options.
type sideeffectdataOption func(*SideEffectDataMutation)

// newSideEffectDataMutation creates new mutation for the SideEffectData entity.
func newSideEffectDataMutation(c config, op Op, opts ...sideeffectdataOption) *SideEffectDataMutation {
	m := &SideEffectDataMutation{
		config:        c,
		op:            op,
		typ:           TypeSideEffectData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSideEffectDataID sets the ID field of the mutation.
func withSideEffectDataID(id int) sideeffectdataOption {
	return func(m *SideEffectDataMutation) {
		var (
			err   error
			once  sync.Once
			value *SideEffectData
		)
		m.oldValue = func(ctx context.Context) (*SideEffectData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SideEffectData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSideEffectData sets the old SideEffectData of the mutation.
func withSideEffectData(node *SideEffectData) sideeffectdataOption {
	return func(m *SideEffectDataMutation) {
		m.oldValue = func(context.Context) (*SideEffectData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SideEffectDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SideEffectDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SideEffectDataMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SideEffectDataMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SideEffectData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntityID sets the "entity" edge to the Entity entity by id.
func (m *SideEffectDataMutation) SetEntityID(id int) {
	m.entity = &id
}

// ClearEntity clears the "entity" edge to the Entity entity.
func (m *SideEffectDataMutation) ClearEntity() {
	m.clearedentity = true
}

// EntityCleared reports if the "entity" edge to the Entity entity was cleared.
func (m *SideEffectDataMutation) EntityCleared() bool {
	return m.clearedentity
}

// EntityID returns the "entity" edge ID in the mutation.
func (m *SideEffectDataMutation) EntityID() (id int, exists bool) {
	if m.entity != nil {
		return *m.entity, true
	}
	return
}

// EntityIDs returns the "entity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntityID instead. It exists only for internal usage by the builders.
func (m *SideEffectDataMutation) EntityIDs() (ids []int) {
	if id := m.entity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntity resets all changes to the "entity" edge.
func (m *SideEffectDataMutation) ResetEntity() {
	m.entity = nil
	m.clearedentity = false
}

// Where appends a list predicates to the SideEffectDataMutation builder.
func (m *SideEffectDataMutation) Where(ps ...predicate.SideEffectData) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SideEffectDataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SideEffectDataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SideEffectData, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SideEffectDataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SideEffectDataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SideEffectData).
func (m *SideEffectDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SideEffectDataMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SideEffectDataMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SideEffectDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown SideEffectData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SideEffectDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SideEffectData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SideEffectDataMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SideEffectDataMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SideEffectDataMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown SideEffectData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SideEffectDataMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SideEffectDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SideEffectDataMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SideEffectData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SideEffectDataMutation) ResetField(name string) error {
	return fmt.Errorf("unknown SideEffectData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SideEffectDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.entity != nil {
		edges = append(edges, sideeffectdata.EdgeEntity)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SideEffectDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sideeffectdata.EdgeEntity:
		if id := m.entity; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SideEffectDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SideEffectDataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SideEffectDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedentity {
		edges = append(edges, sideeffectdata.EdgeEntity)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SideEffectDataMutation) EdgeCleared(name string) bool {
	switch name {
	case sideeffectdata.EdgeEntity:
		return m.clearedentity
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SideEffectDataMutation) ClearEdge(name string) error {
	switch name {
	case sideeffectdata.EdgeEntity:
		m.ClearEntity()
		return nil
	}
	return fmt.Errorf("unknown SideEffectData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SideEffectDataMutation) ResetEdge(name string) error {
	switch name {
	case sideeffectdata.EdgeEntity:
		m.ResetEntity()
		return nil
	}
	return fmt.Errorf("unknown SideEffectData edge %s", name)
}

// SideEffectExecutionMutation represents an operation that mutates the SideEffectExecution nodes in the graph.
type SideEffectExecutionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	clearedFields         map[string]struct{}
	execution             *int
	clearedexecution      bool
	execution_data        *int
	clearedexecution_data bool
	done                  bool
	oldValue              func(context.Context) (*SideEffectExecution, error)
	predicates            []predicate.SideEffectExecution
}

var _ ent.Mutation = (*SideEffectExecutionMutation)(nil)

// sideeffectexecutionOption allows management of the mutation configuration using functional options.
type sideeffectexecutionOption func(*SideEffectExecutionMutation)

// newSideEffectExecutionMutation creates new mutation for the SideEffectExecution entity.
func newSideEffectExecutionMutation(c config, op Op, opts ...sideeffectexecutionOption) *SideEffectExecutionMutation {
	m := &SideEffectExecutionMutation{
		config:        c,
		op:            op,
		typ:           TypeSideEffectExecution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSideEffectExecutionID sets the ID field of the mutation.
func withSideEffectExecutionID(id int) sideeffectexecutionOption {
	return func(m *SideEffectExecutionMutation) {
		var (
			err   error
			once  sync.Once
			value *SideEffectExecution
		)
		m.oldValue = func(ctx context.Context) (*SideEffectExecution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SideEffectExecution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSideEffectExecution sets the old SideEffectExecution of the mutation.
func withSideEffectExecution(node *SideEffectExecution) sideeffectexecutionOption {
	return func(m *SideEffectExecutionMutation) {
		m.oldValue = func(context.Context) (*SideEffectExecution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SideEffectExecutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SideEffectExecutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SideEffectExecutionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SideEffectExecutionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SideEffectExecution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExecutionID sets the "execution" edge to the Execution entity by id.
func (m *SideEffectExecutionMutation) SetExecutionID(id int) {
	m.execution = &id
}

// ClearExecution clears the "execution" edge to the Execution entity.
func (m *SideEffectExecutionMutation) ClearExecution() {
	m.clearedexecution = true
}

// ExecutionCleared reports if the "execution" edge to the Execution entity was cleared.
func (m *SideEffectExecutionMutation) ExecutionCleared() bool {
	return m.clearedexecution
}

// ExecutionID returns the "execution" edge ID in the mutation.
func (m *SideEffectExecutionMutation) ExecutionID() (id int, exists bool) {
	if m.execution != nil {
		return *m.execution, true
	}
	return
}

// ExecutionIDs returns the "execution" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExecutionID instead. It exists only for internal usage by the builders.
func (m *SideEffectExecutionMutation) ExecutionIDs() (ids []int) {
	if id := m.execution; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExecution resets all changes to the "execution" edge.
func (m *SideEffectExecutionMutation) ResetExecution() {
	m.execution = nil
	m.clearedexecution = false
}

// SetExecutionDataID sets the "execution_data" edge to the SideEffectExecutionData entity by id.
func (m *SideEffectExecutionMutation) SetExecutionDataID(id int) {
	m.execution_data = &id
}

// ClearExecutionData clears the "execution_data" edge to the SideEffectExecutionData entity.
func (m *SideEffectExecutionMutation) ClearExecutionData() {
	m.clearedexecution_data = true
}

// ExecutionDataCleared reports if the "execution_data" edge to the SideEffectExecutionData entity was cleared.
func (m *SideEffectExecutionMutation) ExecutionDataCleared() bool {
	return m.clearedexecution_data
}

// ExecutionDataID returns the "execution_data" edge ID in the mutation.
func (m *SideEffectExecutionMutation) ExecutionDataID() (id int, exists bool) {
	if m.execution_data != nil {
		return *m.execution_data, true
	}
	return
}

// ExecutionDataIDs returns the "execution_data" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExecutionDataID instead. It exists only for internal usage by the builders.
func (m *SideEffectExecutionMutation) ExecutionDataIDs() (ids []int) {
	if id := m.execution_data; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExecutionData resets all changes to the "execution_data" edge.
func (m *SideEffectExecutionMutation) ResetExecutionData() {
	m.execution_data = nil
	m.clearedexecution_data = false
}

// Where appends a list predicates to the SideEffectExecutionMutation builder.
func (m *SideEffectExecutionMutation) Where(ps ...predicate.SideEffectExecution) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SideEffectExecutionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SideEffectExecutionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SideEffectExecution, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SideEffectExecutionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SideEffectExecutionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SideEffectExecution).
func (m *SideEffectExecutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SideEffectExecutionMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SideEffectExecutionMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SideEffectExecutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown SideEffectExecution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SideEffectExecutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SideEffectExecution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SideEffectExecutionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SideEffectExecutionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SideEffectExecutionMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown SideEffectExecution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SideEffectExecutionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SideEffectExecutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SideEffectExecutionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SideEffectExecution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SideEffectExecutionMutation) ResetField(name string) error {
	return fmt.Errorf("unknown SideEffectExecution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SideEffectExecutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.execution != nil {
		edges = append(edges, sideeffectexecution.EdgeExecution)
	}
	if m.execution_data != nil {
		edges = append(edges, sideeffectexecution.EdgeExecutionData)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SideEffectExecutionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sideeffectexecution.EdgeExecution:
		if id := m.execution; id != nil {
			return []ent.Value{*id}
		}
	case sideeffectexecution.EdgeExecutionData:
		if id := m.execution_data; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SideEffectExecutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SideEffectExecutionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SideEffectExecutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedexecution {
		edges = append(edges, sideeffectexecution.EdgeExecution)
	}
	if m.clearedexecution_data {
		edges = append(edges, sideeffectexecution.EdgeExecutionData)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SideEffectExecutionMutation) EdgeCleared(name string) bool {
	switch name {
	case sideeffectexecution.EdgeExecution:
		return m.clearedexecution
	case sideeffectexecution.EdgeExecutionData:
		return m.clearedexecution_data
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SideEffectExecutionMutation) ClearEdge(name string) error {
	switch name {
	case sideeffectexecution.EdgeExecution:
		m.ClearExecution()
		return nil
	case sideeffectexecution.EdgeExecutionData:
		m.ClearExecutionData()
		return nil
	}
	return fmt.Errorf("unknown SideEffectExecution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SideEffectExecutionMutation) ResetEdge(name string) error {
	switch name {
	case sideeffectexecution.EdgeExecution:
		m.ResetExecution()
		return nil
	case sideeffectexecution.EdgeExecutionData:
		m.ResetExecutionData()
		return nil
	}
	return fmt.Errorf("unknown SideEffectExecution edge %s", name)
}

// SideEffectExecutionDataMutation represents an operation that mutates the SideEffectExecutionData nodes in the graph.
type SideEffectExecutionDataMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	outputs                      *[][]uint8
	appendoutputs                [][]uint8
	clearedFields                map[string]struct{}
	side_effect_execution        *int
	clearedside_effect_execution bool
	done                         bool
	oldValue                     func(context.Context) (*SideEffectExecutionData, error)
	predicates                   []predicate.SideEffectExecutionData
}

var _ ent.Mutation = (*SideEffectExecutionDataMutation)(nil)

// sideeffectexecutiondataOption allows management of the mutation configuration using functional options.
type sideeffectexecutiondataOption func(*SideEffectExecutionDataMutation)

// newSideEffectExecutionDataMutation creates new mutation for the SideEffectExecutionData entity.
func newSideEffectExecutionDataMutation(c config, op Op, opts ...sideeffectexecutiondataOption) *SideEffectExecutionDataMutation {
	m := &SideEffectExecutionDataMutation{
		config:        c,
		op:            op,
		typ:           TypeSideEffectExecutionData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSideEffectExecutionDataID sets the ID field of the mutation.
func withSideEffectExecutionDataID(id int) sideeffectexecutiondataOption {
	return func(m *SideEffectExecutionDataMutation) {
		var (
			err   error
			once  sync.Once
			value *SideEffectExecutionData
		)
		m.oldValue = func(ctx context.Context) (*SideEffectExecutionData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SideEffectExecutionData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSideEffectExecutionData sets the old SideEffectExecutionData of the mutation.
func withSideEffectExecutionData(node *SideEffectExecutionData) sideeffectexecutiondataOption {
	return func(m *SideEffectExecutionDataMutation) {
		m.oldValue = func(context.Context) (*SideEffectExecutionData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SideEffectExecutionDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SideEffectExecutionDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SideEffectExecutionDataMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SideEffectExecutionDataMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SideEffectExecutionData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOutputs sets the "outputs" field.
func (m *SideEffectExecutionDataMutation) SetOutputs(u [][]uint8) {
	m.outputs = &u
	m.appendoutputs = nil
}

// Outputs returns the value of the "outputs" field in the mutation.
func (m *SideEffectExecutionDataMutation) Outputs() (r [][]uint8, exists bool) {
	v := m.outputs
	if v == nil {
		return
	}
	return *v, true
}

// OldOutputs returns the old "outputs" field's value of the SideEffectExecutionData entity.
// If the SideEffectExecutionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectExecutionDataMutation) OldOutputs(ctx context.Context) (v [][]uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutputs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutputs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutputs: %w", err)
	}
	return oldValue.Outputs, nil
}

// AppendOutputs adds u to the "outputs" field.
func (m *SideEffectExecutionDataMutation) AppendOutputs(u [][]uint8) {
	m.appendoutputs = append(m.appendoutputs, u...)
}

// AppendedOutputs returns the list of values that were appended to the "outputs" field in this mutation.
func (m *SideEffectExecutionDataMutation) AppendedOutputs() ([][]uint8, bool) {
	if len(m.appendoutputs) == 0 {
		return nil, false
	}
	return m.appendoutputs, true
}

// ClearOutputs clears the value of the "outputs" field.
func (m *SideEffectExecutionDataMutation) ClearOutputs() {
	m.outputs = nil
	m.appendoutputs = nil
	m.clearedFields[sideeffectexecutiondata.FieldOutputs] = struct{}{}
}

// OutputsCleared returns if the "outputs" field was cleared in this mutation.
func (m *SideEffectExecutionDataMutation) OutputsCleared() bool {
	_, ok := m.clearedFields[sideeffectexecutiondata.FieldOutputs]
	return ok
}

// ResetOutputs resets all changes to the "outputs" field.
func (m *SideEffectExecutionDataMutation) ResetOutputs() {
	m.outputs = nil
	m.appendoutputs = nil
	delete(m.clearedFields, sideeffectexecutiondata.FieldOutputs)
}

// SetSideEffectExecutionID sets the "side_effect_execution" edge to the SideEffectExecution entity by id.
func (m *SideEffectExecutionDataMutation) SetSideEffectExecutionID(id int) {
	m.side_effect_execution = &id
}

// ClearSideEffectExecution clears the "side_effect_execution" edge to the SideEffectExecution entity.
func (m *SideEffectExecutionDataMutation) ClearSideEffectExecution() {
	m.clearedside_effect_execution = true
}

// SideEffectExecutionCleared reports if the "side_effect_execution" edge to the SideEffectExecution entity was cleared.
func (m *SideEffectExecutionDataMutation) SideEffectExecutionCleared() bool {
	return m.clearedside_effect_execution
}

// SideEffectExecutionID returns the "side_effect_execution" edge ID in the mutation.
func (m *SideEffectExecutionDataMutation) SideEffectExecutionID() (id int, exists bool) {
	if m.side_effect_execution != nil {
		return *m.side_effect_execution, true
	}
	return
}

// SideEffectExecutionIDs returns the "side_effect_execution" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SideEffectExecutionID instead. It exists only for internal usage by the builders.
func (m *SideEffectExecutionDataMutation) SideEffectExecutionIDs() (ids []int) {
	if id := m.side_effect_execution; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSideEffectExecution resets all changes to the "side_effect_execution" edge.
func (m *SideEffectExecutionDataMutation) ResetSideEffectExecution() {
	m.side_effect_execution = nil
	m.clearedside_effect_execution = false
}

// Where appends a list predicates to the SideEffectExecutionDataMutation builder.
func (m *SideEffectExecutionDataMutation) Where(ps ...predicate.SideEffectExecutionData) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SideEffectExecutionDataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SideEffectExecutionDataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SideEffectExecutionData, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SideEffectExecutionDataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SideEffectExecutionDataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SideEffectExecutionData).
func (m *SideEffectExecutionDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SideEffectExecutionDataMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.outputs != nil {
		fields = append(fields, sideeffectexecutiondata.FieldOutputs)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SideEffectExecutionDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sideeffectexecutiondata.FieldOutputs:
		return m.Outputs()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SideEffectExecutionDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sideeffectexecutiondata.FieldOutputs:
		return m.OldOutputs(ctx)
	}
	return nil, fmt.Errorf("unknown SideEffectExecutionData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SideEffectExecutionDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sideeffectexecutiondata.FieldOutputs:
		v, ok := value.([][]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutputs(v)
		return nil
	}
	return fmt.Errorf("unknown SideEffectExecutionData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SideEffectExecutionDataMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SideEffectExecutionDataMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SideEffectExecutionDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SideEffectExecutionData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SideEffectExecutionDataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sideeffectexecutiondata.FieldOutputs) {
		fields = append(fields, sideeffectexecutiondata.FieldOutputs)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SideEffectExecutionDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SideEffectExecutionDataMutation) ClearField(name string) error {
	switch name {
	case sideeffectexecutiondata.FieldOutputs:
		m.ClearOutputs()
		return nil
	}
	return fmt.Errorf("unknown SideEffectExecutionData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SideEffectExecutionDataMutation) ResetField(name string) error {
	switch name {
	case sideeffectexecutiondata.FieldOutputs:
		m.ResetOutputs()
		return nil
	}
	return fmt.Errorf("unknown SideEffectExecutionData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SideEffectExecutionDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.side_effect_execution != nil {
		edges = append(edges, sideeffectexecutiondata.EdgeSideEffectExecution)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SideEffectExecutionDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sideeffectexecutiondata.EdgeSideEffectExecution:
		if id := m.side_effect_execution; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SideEffectExecutionDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SideEffectExecutionDataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SideEffectExecutionDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedside_effect_execution {
		edges = append(edges, sideeffectexecutiondata.EdgeSideEffectExecution)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SideEffectExecutionDataMutation) EdgeCleared(name string) bool {
	switch name {
	case sideeffectexecutiondata.EdgeSideEffectExecution:
		return m.clearedside_effect_execution
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SideEffectExecutionDataMutation) ClearEdge(name string) error {
	switch name {
	case sideeffectexecutiondata.EdgeSideEffectExecution:
		m.ClearSideEffectExecution()
		return nil
	}
	return fmt.Errorf("unknown SideEffectExecutionData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SideEffectExecutionDataMutation) ResetEdge(name string) error {
	switch name {
	case sideeffectexecutiondata.EdgeSideEffectExecution:
		m.ResetSideEffectExecution()
		return nil
	}
	return fmt.Errorf("unknown SideEffectExecutionData edge %s", name)
}

// VersionMutation represents an operation that mutates the Version nodes in the graph.
type VersionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	changeID      *string
	version       *int
	addversion    *int
	data          *map[string]interface{}
	clearedFields map[string]struct{}
	entity        *int
	clearedentity bool
	done          bool
	oldValue      func(context.Context) (*Version, error)
	predicates    []predicate.Version
}

var _ ent.Mutation = (*VersionMutation)(nil)

// versionOption allows management of the mutation configuration using functional options.
type versionOption func(*VersionMutation)

// newVersionMutation creates new mutation for the Version entity.
func newVersionMutation(c config, op Op, opts ...versionOption) *VersionMutation {
	m := &VersionMutation{
		config:        c,
		op:            op,
		typ:           TypeVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVersionID sets the ID field of the mutation.
func withVersionID(id int) versionOption {
	return func(m *VersionMutation) {
		var (
			err   error
			once  sync.Once
			value *Version
		)
		m.oldValue = func(ctx context.Context) (*Version, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Version.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVersion sets the old Version of the mutation.
func withVersion(node *Version) versionOption {
	return func(m *VersionMutation) {
		m.oldValue = func(context.Context) (*Version, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VersionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VersionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Version.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetChangeID sets the "changeID" field.
func (m *VersionMutation) SetChangeID(s string) {
	m.changeID = &s
}

// ChangeID returns the value of the "changeID" field in the mutation.
func (m *VersionMutation) ChangeID() (r string, exists bool) {
	v := m.changeID
	if v == nil {
		return
	}
	return *v, true
}

// OldChangeID returns the old "changeID" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldChangeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChangeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChangeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChangeID: %w", err)
	}
	return oldValue.ChangeID, nil
}

// ResetChangeID resets all changes to the "changeID" field.
func (m *VersionMutation) ResetChangeID() {
	m.changeID = nil
}

// SetVersion sets the "version" field.
func (m *VersionMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *VersionMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *VersionMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *VersionMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *VersionMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetData sets the "data" field.
func (m *VersionMutation) SetData(value map[string]interface{}) {
	m.data = &value
}

// Data returns the value of the "data" field in the mutation.
func (m *VersionMutation) Data() (r map[string]interface{}, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *VersionMutation) ResetData() {
	m.data = nil
}

// SetEntityID sets the "entity" edge to the Entity entity by id.
func (m *VersionMutation) SetEntityID(id int) {
	m.entity = &id
}

// ClearEntity clears the "entity" edge to the Entity entity.
func (m *VersionMutation) ClearEntity() {
	m.clearedentity = true
}

// EntityCleared reports if the "entity" edge to the Entity entity was cleared.
func (m *VersionMutation) EntityCleared() bool {
	return m.clearedentity
}

// EntityID returns the "entity" edge ID in the mutation.
func (m *VersionMutation) EntityID() (id int, exists bool) {
	if m.entity != nil {
		return *m.entity, true
	}
	return
}

// EntityIDs returns the "entity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntityID instead. It exists only for internal usage by the builders.
func (m *VersionMutation) EntityIDs() (ids []int) {
	if id := m.entity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntity resets all changes to the "entity" edge.
func (m *VersionMutation) ResetEntity() {
	m.entity = nil
	m.clearedentity = false
}

// Where appends a list predicates to the VersionMutation builder.
func (m *VersionMutation) Where(ps ...predicate.Version) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Version, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Version).
func (m *VersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VersionMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.changeID != nil {
		fields = append(fields, version.FieldChangeID)
	}
	if m.version != nil {
		fields = append(fields, version.FieldVersion)
	}
	if m.data != nil {
		fields = append(fields, version.FieldData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case version.FieldChangeID:
		return m.ChangeID()
	case version.FieldVersion:
		return m.Version()
	case version.FieldData:
		return m.Data()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case version.FieldChangeID:
		return m.OldChangeID(ctx)
	case version.FieldVersion:
		return m.OldVersion(ctx)
	case version.FieldData:
		return m.OldData(ctx)
	}
	return nil, fmt.Errorf("unknown Version field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case version.FieldChangeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChangeID(v)
		return nil
	case version.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case version.FieldData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	}
	return fmt.Errorf("unknown Version field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VersionMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, version.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VersionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case version.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case version.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Version numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VersionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VersionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Version nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VersionMutation) ResetField(name string) error {
	switch name {
	case version.FieldChangeID:
		m.ResetChangeID()
		return nil
	case version.FieldVersion:
		m.ResetVersion()
		return nil
	case version.FieldData:
		m.ResetData()
		return nil
	}
	return fmt.Errorf("unknown Version field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.entity != nil {
		edges = append(edges, version.EdgeEntity)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VersionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case version.EdgeEntity:
		if id := m.entity; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VersionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedentity {
		edges = append(edges, version.EdgeEntity)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VersionMutation) EdgeCleared(name string) bool {
	switch name {
	case version.EdgeEntity:
		return m.clearedentity
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VersionMutation) ClearEdge(name string) error {
	switch name {
	case version.EdgeEntity:
		m.ClearEntity()
		return nil
	}
	return fmt.Errorf("unknown Version unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VersionMutation) ResetEdge(name string) error {
	switch name {
	case version.EdgeEntity:
		m.ResetEntity()
		return nil
	}
	return fmt.Errorf("unknown Version edge %s", name)
}

// WorkflowDataMutation represents an operation that mutates the WorkflowData nodes in the graph.
type WorkflowDataMutation struct {
	config
	op            Op
	typ           string
	id            *int
	duration      *string
	paused        *bool
	resumable     *bool
	input         *[][]uint8
	appendinput   [][]uint8
	attempt       *int
	addattempt    *int
	clearedFields map[string]struct{}
	entity        *int
	clearedentity bool
	done          bool
	oldValue      func(context.Context) (*WorkflowData, error)
	predicates    []predicate.WorkflowData
}

var _ ent.Mutation = (*WorkflowDataMutation)(nil)

// workflowdataOption allows management of the mutation configuration using functional options.
type workflowdataOption func(*WorkflowDataMutation)

// newWorkflowDataMutation creates new mutation for the WorkflowData entity.
func newWorkflowDataMutation(c config, op Op, opts ...workflowdataOption) *WorkflowDataMutation {
	m := &WorkflowDataMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflowData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowDataID sets the ID field of the mutation.
func withWorkflowDataID(id int) workflowdataOption {
	return func(m *WorkflowDataMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkflowData
		)
		m.oldValue = func(ctx context.Context) (*WorkflowData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkflowData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflowData sets the old WorkflowData of the mutation.
func withWorkflowData(node *WorkflowData) workflowdataOption {
	return func(m *WorkflowDataMutation) {
		m.oldValue = func(context.Context) (*WorkflowData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowDataMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowDataMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkflowData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDuration sets the "duration" field.
func (m *WorkflowDataMutation) SetDuration(s string) {
	m.duration = &s
}

// Duration returns the value of the "duration" field in the mutation.
func (m *WorkflowDataMutation) Duration() (r string, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the WorkflowData entity.
// If the WorkflowData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDataMutation) OldDuration(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// ClearDuration clears the value of the "duration" field.
func (m *WorkflowDataMutation) ClearDuration() {
	m.duration = nil
	m.clearedFields[workflowdata.FieldDuration] = struct{}{}
}

// DurationCleared returns if the "duration" field was cleared in this mutation.
func (m *WorkflowDataMutation) DurationCleared() bool {
	_, ok := m.clearedFields[workflowdata.FieldDuration]
	return ok
}

// ResetDuration resets all changes to the "duration" field.
func (m *WorkflowDataMutation) ResetDuration() {
	m.duration = nil
	delete(m.clearedFields, workflowdata.FieldDuration)
}

// SetPaused sets the "paused" field.
func (m *WorkflowDataMutation) SetPaused(b bool) {
	m.paused = &b
}

// Paused returns the value of the "paused" field in the mutation.
func (m *WorkflowDataMutation) Paused() (r bool, exists bool) {
	v := m.paused
	if v == nil {
		return
	}
	return *v, true
}

// OldPaused returns the old "paused" field's value of the WorkflowData entity.
// If the WorkflowData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDataMutation) OldPaused(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaused is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaused requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaused: %w", err)
	}
	return oldValue.Paused, nil
}

// ResetPaused resets all changes to the "paused" field.
func (m *WorkflowDataMutation) ResetPaused() {
	m.paused = nil
}

// SetResumable sets the "resumable" field.
func (m *WorkflowDataMutation) SetResumable(b bool) {
	m.resumable = &b
}

// Resumable returns the value of the "resumable" field in the mutation.
func (m *WorkflowDataMutation) Resumable() (r bool, exists bool) {
	v := m.resumable
	if v == nil {
		return
	}
	return *v, true
}

// OldResumable returns the old "resumable" field's value of the WorkflowData entity.
// If the WorkflowData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDataMutation) OldResumable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResumable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResumable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResumable: %w", err)
	}
	return oldValue.Resumable, nil
}

// ResetResumable resets all changes to the "resumable" field.
func (m *WorkflowDataMutation) ResetResumable() {
	m.resumable = nil
}

// SetInput sets the "input" field.
func (m *WorkflowDataMutation) SetInput(u [][]uint8) {
	m.input = &u
	m.appendinput = nil
}

// Input returns the value of the "input" field in the mutation.
func (m *WorkflowDataMutation) Input() (r [][]uint8, exists bool) {
	v := m.input
	if v == nil {
		return
	}
	return *v, true
}

// OldInput returns the old "input" field's value of the WorkflowData entity.
// If the WorkflowData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDataMutation) OldInput(ctx context.Context) (v [][]uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInput: %w", err)
	}
	return oldValue.Input, nil
}

// AppendInput adds u to the "input" field.
func (m *WorkflowDataMutation) AppendInput(u [][]uint8) {
	m.appendinput = append(m.appendinput, u...)
}

// AppendedInput returns the list of values that were appended to the "input" field in this mutation.
func (m *WorkflowDataMutation) AppendedInput() ([][]uint8, bool) {
	if len(m.appendinput) == 0 {
		return nil, false
	}
	return m.appendinput, true
}

// ClearInput clears the value of the "input" field.
func (m *WorkflowDataMutation) ClearInput() {
	m.input = nil
	m.appendinput = nil
	m.clearedFields[workflowdata.FieldInput] = struct{}{}
}

// InputCleared returns if the "input" field was cleared in this mutation.
func (m *WorkflowDataMutation) InputCleared() bool {
	_, ok := m.clearedFields[workflowdata.FieldInput]
	return ok
}

// ResetInput resets all changes to the "input" field.
func (m *WorkflowDataMutation) ResetInput() {
	m.input = nil
	m.appendinput = nil
	delete(m.clearedFields, workflowdata.FieldInput)
}

// SetAttempt sets the "attempt" field.
func (m *WorkflowDataMutation) SetAttempt(i int) {
	m.attempt = &i
	m.addattempt = nil
}

// Attempt returns the value of the "attempt" field in the mutation.
func (m *WorkflowDataMutation) Attempt() (r int, exists bool) {
	v := m.attempt
	if v == nil {
		return
	}
	return *v, true
}

// OldAttempt returns the old "attempt" field's value of the WorkflowData entity.
// If the WorkflowData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDataMutation) OldAttempt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttempt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttempt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttempt: %w", err)
	}
	return oldValue.Attempt, nil
}

// AddAttempt adds i to the "attempt" field.
func (m *WorkflowDataMutation) AddAttempt(i int) {
	if m.addattempt != nil {
		*m.addattempt += i
	} else {
		m.addattempt = &i
	}
}

// AddedAttempt returns the value that was added to the "attempt" field in this mutation.
func (m *WorkflowDataMutation) AddedAttempt() (r int, exists bool) {
	v := m.addattempt
	if v == nil {
		return
	}
	return *v, true
}

// ResetAttempt resets all changes to the "attempt" field.
func (m *WorkflowDataMutation) ResetAttempt() {
	m.attempt = nil
	m.addattempt = nil
}

// SetEntityID sets the "entity" edge to the Entity entity by id.
func (m *WorkflowDataMutation) SetEntityID(id int) {
	m.entity = &id
}

// ClearEntity clears the "entity" edge to the Entity entity.
func (m *WorkflowDataMutation) ClearEntity() {
	m.clearedentity = true
}

// EntityCleared reports if the "entity" edge to the Entity entity was cleared.
func (m *WorkflowDataMutation) EntityCleared() bool {
	return m.clearedentity
}

// EntityID returns the "entity" edge ID in the mutation.
func (m *WorkflowDataMutation) EntityID() (id int, exists bool) {
	if m.entity != nil {
		return *m.entity, true
	}
	return
}

// EntityIDs returns the "entity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntityID instead. It exists only for internal usage by the builders.
func (m *WorkflowDataMutation) EntityIDs() (ids []int) {
	if id := m.entity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntity resets all changes to the "entity" edge.
func (m *WorkflowDataMutation) ResetEntity() {
	m.entity = nil
	m.clearedentity = false
}

// Where appends a list predicates to the WorkflowDataMutation builder.
func (m *WorkflowDataMutation) Where(ps ...predicate.WorkflowData) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowDataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowDataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkflowData, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowDataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowDataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkflowData).
func (m *WorkflowDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowDataMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.duration != nil {
		fields = append(fields, workflowdata.FieldDuration)
	}
	if m.paused != nil {
		fields = append(fields, workflowdata.FieldPaused)
	}
	if m.resumable != nil {
		fields = append(fields, workflowdata.FieldResumable)
	}
	if m.input != nil {
		fields = append(fields, workflowdata.FieldInput)
	}
	if m.attempt != nil {
		fields = append(fields, workflowdata.FieldAttempt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflowdata.FieldDuration:
		return m.Duration()
	case workflowdata.FieldPaused:
		return m.Paused()
	case workflowdata.FieldResumable:
		return m.Resumable()
	case workflowdata.FieldInput:
		return m.Input()
	case workflowdata.FieldAttempt:
		return m.Attempt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflowdata.FieldDuration:
		return m.OldDuration(ctx)
	case workflowdata.FieldPaused:
		return m.OldPaused(ctx)
	case workflowdata.FieldResumable:
		return m.OldResumable(ctx)
	case workflowdata.FieldInput:
		return m.OldInput(ctx)
	case workflowdata.FieldAttempt:
		return m.OldAttempt(ctx)
	}
	return nil, fmt.Errorf("unknown WorkflowData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflowdata.FieldDuration:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case workflowdata.FieldPaused:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaused(v)
		return nil
	case workflowdata.FieldResumable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResumable(v)
		return nil
	case workflowdata.FieldInput:
		v, ok := value.([][]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInput(v)
		return nil
	case workflowdata.FieldAttempt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttempt(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowDataMutation) AddedFields() []string {
	var fields []string
	if m.addattempt != nil {
		fields = append(fields, workflowdata.FieldAttempt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowDataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workflowdata.FieldAttempt:
		return m.AddedAttempt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workflowdata.FieldAttempt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAttempt(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowDataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflowdata.FieldDuration) {
		fields = append(fields, workflowdata.FieldDuration)
	}
	if m.FieldCleared(workflowdata.FieldInput) {
		fields = append(fields, workflowdata.FieldInput)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowDataMutation) ClearField(name string) error {
	switch name {
	case workflowdata.FieldDuration:
		m.ClearDuration()
		return nil
	case workflowdata.FieldInput:
		m.ClearInput()
		return nil
	}
	return fmt.Errorf("unknown WorkflowData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowDataMutation) ResetField(name string) error {
	switch name {
	case workflowdata.FieldDuration:
		m.ResetDuration()
		return nil
	case workflowdata.FieldPaused:
		m.ResetPaused()
		return nil
	case workflowdata.FieldResumable:
		m.ResetResumable()
		return nil
	case workflowdata.FieldInput:
		m.ResetInput()
		return nil
	case workflowdata.FieldAttempt:
		m.ResetAttempt()
		return nil
	}
	return fmt.Errorf("unknown WorkflowData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.entity != nil {
		edges = append(edges, workflowdata.EdgeEntity)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workflowdata.EdgeEntity:
		if id := m.entity; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowDataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedentity {
		edges = append(edges, workflowdata.EdgeEntity)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowDataMutation) EdgeCleared(name string) bool {
	switch name {
	case workflowdata.EdgeEntity:
		return m.clearedentity
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowDataMutation) ClearEdge(name string) error {
	switch name {
	case workflowdata.EdgeEntity:
		m.ClearEntity()
		return nil
	}
	return fmt.Errorf("unknown WorkflowData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowDataMutation) ResetEdge(name string) error {
	switch name {
	case workflowdata.EdgeEntity:
		m.ResetEntity()
		return nil
	}
	return fmt.Errorf("unknown WorkflowData edge %s", name)
}

// WorkflowExecutionMutation represents an operation that mutates the WorkflowExecution nodes in the graph.
type WorkflowExecutionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	inputs                *[][]uint8
	appendinputs          [][]uint8
	clearedFields         map[string]struct{}
	execution             *int
	clearedexecution      bool
	execution_data        *int
	clearedexecution_data bool
	done                  bool
	oldValue              func(context.Context) (*WorkflowExecution, error)
	predicates            []predicate.WorkflowExecution
}

var _ ent.Mutation = (*WorkflowExecutionMutation)(nil)

// workflowexecutionOption allows management of the mutation configuration using functional options.
type workflowexecutionOption func(*WorkflowExecutionMutation)

// newWorkflowExecutionMutation creates new mutation for the WorkflowExecution entity.
func newWorkflowExecutionMutation(c config, op Op, opts ...workflowexecutionOption) *WorkflowExecutionMutation {
	m := &WorkflowExecutionMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflowExecution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowExecutionID sets the ID field of the mutation.
func withWorkflowExecutionID(id int) workflowexecutionOption {
	return func(m *WorkflowExecutionMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkflowExecution
		)
		m.oldValue = func(ctx context.Context) (*WorkflowExecution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkflowExecution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflowExecution sets the old WorkflowExecution of the mutation.
func withWorkflowExecution(node *WorkflowExecution) workflowexecutionOption {
	return func(m *WorkflowExecutionMutation) {
		m.oldValue = func(context.Context) (*WorkflowExecution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowExecutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowExecutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowExecutionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowExecutionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkflowExecution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInputs sets the "inputs" field.
func (m *WorkflowExecutionMutation) SetInputs(u [][]uint8) {
	m.inputs = &u
	m.appendinputs = nil
}

// Inputs returns the value of the "inputs" field in the mutation.
func (m *WorkflowExecutionMutation) Inputs() (r [][]uint8, exists bool) {
	v := m.inputs
	if v == nil {
		return
	}
	return *v, true
}

// OldInputs returns the old "inputs" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldInputs(ctx context.Context) (v [][]uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInputs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInputs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInputs: %w", err)
	}
	return oldValue.Inputs, nil
}

// AppendInputs adds u to the "inputs" field.
func (m *WorkflowExecutionMutation) AppendInputs(u [][]uint8) {
	m.appendinputs = append(m.appendinputs, u...)
}

// AppendedInputs returns the list of values that were appended to the "inputs" field in this mutation.
func (m *WorkflowExecutionMutation) AppendedInputs() ([][]uint8, bool) {
	if len(m.appendinputs) == 0 {
		return nil, false
	}
	return m.appendinputs, true
}

// ClearInputs clears the value of the "inputs" field.
func (m *WorkflowExecutionMutation) ClearInputs() {
	m.inputs = nil
	m.appendinputs = nil
	m.clearedFields[workflowexecution.FieldInputs] = struct{}{}
}

// InputsCleared returns if the "inputs" field was cleared in this mutation.
func (m *WorkflowExecutionMutation) InputsCleared() bool {
	_, ok := m.clearedFields[workflowexecution.FieldInputs]
	return ok
}

// ResetInputs resets all changes to the "inputs" field.
func (m *WorkflowExecutionMutation) ResetInputs() {
	m.inputs = nil
	m.appendinputs = nil
	delete(m.clearedFields, workflowexecution.FieldInputs)
}

// SetExecutionID sets the "execution" edge to the Execution entity by id.
func (m *WorkflowExecutionMutation) SetExecutionID(id int) {
	m.execution = &id
}

// ClearExecution clears the "execution" edge to the Execution entity.
func (m *WorkflowExecutionMutation) ClearExecution() {
	m.clearedexecution = true
}

// ExecutionCleared reports if the "execution" edge to the Execution entity was cleared.
func (m *WorkflowExecutionMutation) ExecutionCleared() bool {
	return m.clearedexecution
}

// ExecutionID returns the "execution" edge ID in the mutation.
func (m *WorkflowExecutionMutation) ExecutionID() (id int, exists bool) {
	if m.execution != nil {
		return *m.execution, true
	}
	return
}

// ExecutionIDs returns the "execution" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExecutionID instead. It exists only for internal usage by the builders.
func (m *WorkflowExecutionMutation) ExecutionIDs() (ids []int) {
	if id := m.execution; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExecution resets all changes to the "execution" edge.
func (m *WorkflowExecutionMutation) ResetExecution() {
	m.execution = nil
	m.clearedexecution = false
}

// SetExecutionDataID sets the "execution_data" edge to the WorkflowExecutionData entity by id.
func (m *WorkflowExecutionMutation) SetExecutionDataID(id int) {
	m.execution_data = &id
}

// ClearExecutionData clears the "execution_data" edge to the WorkflowExecutionData entity.
func (m *WorkflowExecutionMutation) ClearExecutionData() {
	m.clearedexecution_data = true
}

// ExecutionDataCleared reports if the "execution_data" edge to the WorkflowExecutionData entity was cleared.
func (m *WorkflowExecutionMutation) ExecutionDataCleared() bool {
	return m.clearedexecution_data
}

// ExecutionDataID returns the "execution_data" edge ID in the mutation.
func (m *WorkflowExecutionMutation) ExecutionDataID() (id int, exists bool) {
	if m.execution_data != nil {
		return *m.execution_data, true
	}
	return
}

// ExecutionDataIDs returns the "execution_data" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExecutionDataID instead. It exists only for internal usage by the builders.
func (m *WorkflowExecutionMutation) ExecutionDataIDs() (ids []int) {
	if id := m.execution_data; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExecutionData resets all changes to the "execution_data" edge.
func (m *WorkflowExecutionMutation) ResetExecutionData() {
	m.execution_data = nil
	m.clearedexecution_data = false
}

// Where appends a list predicates to the WorkflowExecutionMutation builder.
func (m *WorkflowExecutionMutation) Where(ps ...predicate.WorkflowExecution) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowExecutionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowExecutionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkflowExecution, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowExecutionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowExecutionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkflowExecution).
func (m *WorkflowExecutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowExecutionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.inputs != nil {
		fields = append(fields, workflowexecution.FieldInputs)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowExecutionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflowexecution.FieldInputs:
		return m.Inputs()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowExecutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflowexecution.FieldInputs:
		return m.OldInputs(ctx)
	}
	return nil, fmt.Errorf("unknown WorkflowExecution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowExecutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflowexecution.FieldInputs:
		v, ok := value.([][]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInputs(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowExecutionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowExecutionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowExecutionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkflowExecution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowExecutionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflowexecution.FieldInputs) {
		fields = append(fields, workflowexecution.FieldInputs)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowExecutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowExecutionMutation) ClearField(name string) error {
	switch name {
	case workflowexecution.FieldInputs:
		m.ClearInputs()
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowExecutionMutation) ResetField(name string) error {
	switch name {
	case workflowexecution.FieldInputs:
		m.ResetInputs()
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowExecutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.execution != nil {
		edges = append(edges, workflowexecution.EdgeExecution)
	}
	if m.execution_data != nil {
		edges = append(edges, workflowexecution.EdgeExecutionData)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowExecutionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workflowexecution.EdgeExecution:
		if id := m.execution; id != nil {
			return []ent.Value{*id}
		}
	case workflowexecution.EdgeExecutionData:
		if id := m.execution_data; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowExecutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowExecutionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowExecutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedexecution {
		edges = append(edges, workflowexecution.EdgeExecution)
	}
	if m.clearedexecution_data {
		edges = append(edges, workflowexecution.EdgeExecutionData)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowExecutionMutation) EdgeCleared(name string) bool {
	switch name {
	case workflowexecution.EdgeExecution:
		return m.clearedexecution
	case workflowexecution.EdgeExecutionData:
		return m.clearedexecution_data
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowExecutionMutation) ClearEdge(name string) error {
	switch name {
	case workflowexecution.EdgeExecution:
		m.ClearExecution()
		return nil
	case workflowexecution.EdgeExecutionData:
		m.ClearExecutionData()
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowExecutionMutation) ResetEdge(name string) error {
	switch name {
	case workflowexecution.EdgeExecution:
		m.ResetExecution()
		return nil
	case workflowexecution.EdgeExecutionData:
		m.ResetExecutionData()
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecution edge %s", name)
}

// WorkflowExecutionDataMutation represents an operation that mutates the WorkflowExecutionData nodes in the graph.
type WorkflowExecutionDataMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	last_heartbeat            *time.Time
	outputs                   *[][]uint8
	appendoutputs             [][]uint8
	clearedFields             map[string]struct{}
	workflow_execution        *int
	clearedworkflow_execution bool
	done                      bool
	oldValue                  func(context.Context) (*WorkflowExecutionData, error)
	predicates                []predicate.WorkflowExecutionData
}

var _ ent.Mutation = (*WorkflowExecutionDataMutation)(nil)

// workflowexecutiondataOption allows management of the mutation configuration using functional options.
type workflowexecutiondataOption func(*WorkflowExecutionDataMutation)

// newWorkflowExecutionDataMutation creates new mutation for the WorkflowExecutionData entity.
func newWorkflowExecutionDataMutation(c config, op Op, opts ...workflowexecutiondataOption) *WorkflowExecutionDataMutation {
	m := &WorkflowExecutionDataMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflowExecutionData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowExecutionDataID sets the ID field of the mutation.
func withWorkflowExecutionDataID(id int) workflowexecutiondataOption {
	return func(m *WorkflowExecutionDataMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkflowExecutionData
		)
		m.oldValue = func(ctx context.Context) (*WorkflowExecutionData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkflowExecutionData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflowExecutionData sets the old WorkflowExecutionData of the mutation.
func withWorkflowExecutionData(node *WorkflowExecutionData) workflowexecutiondataOption {
	return func(m *WorkflowExecutionDataMutation) {
		m.oldValue = func(context.Context) (*WorkflowExecutionData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowExecutionDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowExecutionDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowExecutionDataMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowExecutionDataMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkflowExecutionData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLastHeartbeat sets the "last_heartbeat" field.
func (m *WorkflowExecutionDataMutation) SetLastHeartbeat(t time.Time) {
	m.last_heartbeat = &t
}

// LastHeartbeat returns the value of the "last_heartbeat" field in the mutation.
func (m *WorkflowExecutionDataMutation) LastHeartbeat() (r time.Time, exists bool) {
	v := m.last_heartbeat
	if v == nil {
		return
	}
	return *v, true
}

// OldLastHeartbeat returns the old "last_heartbeat" field's value of the WorkflowExecutionData entity.
// If the WorkflowExecutionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionDataMutation) OldLastHeartbeat(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastHeartbeat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastHeartbeat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastHeartbeat: %w", err)
	}
	return oldValue.LastHeartbeat, nil
}

// ClearLastHeartbeat clears the value of the "last_heartbeat" field.
func (m *WorkflowExecutionDataMutation) ClearLastHeartbeat() {
	m.last_heartbeat = nil
	m.clearedFields[workflowexecutiondata.FieldLastHeartbeat] = struct{}{}
}

// LastHeartbeatCleared returns if the "last_heartbeat" field was cleared in this mutation.
func (m *WorkflowExecutionDataMutation) LastHeartbeatCleared() bool {
	_, ok := m.clearedFields[workflowexecutiondata.FieldLastHeartbeat]
	return ok
}

// ResetLastHeartbeat resets all changes to the "last_heartbeat" field.
func (m *WorkflowExecutionDataMutation) ResetLastHeartbeat() {
	m.last_heartbeat = nil
	delete(m.clearedFields, workflowexecutiondata.FieldLastHeartbeat)
}

// SetOutputs sets the "outputs" field.
func (m *WorkflowExecutionDataMutation) SetOutputs(u [][]uint8) {
	m.outputs = &u
	m.appendoutputs = nil
}

// Outputs returns the value of the "outputs" field in the mutation.
func (m *WorkflowExecutionDataMutation) Outputs() (r [][]uint8, exists bool) {
	v := m.outputs
	if v == nil {
		return
	}
	return *v, true
}

// OldOutputs returns the old "outputs" field's value of the WorkflowExecutionData entity.
// If the WorkflowExecutionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionDataMutation) OldOutputs(ctx context.Context) (v [][]uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutputs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutputs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutputs: %w", err)
	}
	return oldValue.Outputs, nil
}

// AppendOutputs adds u to the "outputs" field.
func (m *WorkflowExecutionDataMutation) AppendOutputs(u [][]uint8) {
	m.appendoutputs = append(m.appendoutputs, u...)
}

// AppendedOutputs returns the list of values that were appended to the "outputs" field in this mutation.
func (m *WorkflowExecutionDataMutation) AppendedOutputs() ([][]uint8, bool) {
	if len(m.appendoutputs) == 0 {
		return nil, false
	}
	return m.appendoutputs, true
}

// ClearOutputs clears the value of the "outputs" field.
func (m *WorkflowExecutionDataMutation) ClearOutputs() {
	m.outputs = nil
	m.appendoutputs = nil
	m.clearedFields[workflowexecutiondata.FieldOutputs] = struct{}{}
}

// OutputsCleared returns if the "outputs" field was cleared in this mutation.
func (m *WorkflowExecutionDataMutation) OutputsCleared() bool {
	_, ok := m.clearedFields[workflowexecutiondata.FieldOutputs]
	return ok
}

// ResetOutputs resets all changes to the "outputs" field.
func (m *WorkflowExecutionDataMutation) ResetOutputs() {
	m.outputs = nil
	m.appendoutputs = nil
	delete(m.clearedFields, workflowexecutiondata.FieldOutputs)
}

// SetWorkflowExecutionID sets the "workflow_execution" edge to the WorkflowExecution entity by id.
func (m *WorkflowExecutionDataMutation) SetWorkflowExecutionID(id int) {
	m.workflow_execution = &id
}

// ClearWorkflowExecution clears the "workflow_execution" edge to the WorkflowExecution entity.
func (m *WorkflowExecutionDataMutation) ClearWorkflowExecution() {
	m.clearedworkflow_execution = true
}

// WorkflowExecutionCleared reports if the "workflow_execution" edge to the WorkflowExecution entity was cleared.
func (m *WorkflowExecutionDataMutation) WorkflowExecutionCleared() bool {
	return m.clearedworkflow_execution
}

// WorkflowExecutionID returns the "workflow_execution" edge ID in the mutation.
func (m *WorkflowExecutionDataMutation) WorkflowExecutionID() (id int, exists bool) {
	if m.workflow_execution != nil {
		return *m.workflow_execution, true
	}
	return
}

// WorkflowExecutionIDs returns the "workflow_execution" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowExecutionID instead. It exists only for internal usage by the builders.
func (m *WorkflowExecutionDataMutation) WorkflowExecutionIDs() (ids []int) {
	if id := m.workflow_execution; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflowExecution resets all changes to the "workflow_execution" edge.
func (m *WorkflowExecutionDataMutation) ResetWorkflowExecution() {
	m.workflow_execution = nil
	m.clearedworkflow_execution = false
}

// Where appends a list predicates to the WorkflowExecutionDataMutation builder.
func (m *WorkflowExecutionDataMutation) Where(ps ...predicate.WorkflowExecutionData) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowExecutionDataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowExecutionDataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkflowExecutionData, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowExecutionDataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowExecutionDataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkflowExecutionData).
func (m *WorkflowExecutionDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowExecutionDataMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.last_heartbeat != nil {
		fields = append(fields, workflowexecutiondata.FieldLastHeartbeat)
	}
	if m.outputs != nil {
		fields = append(fields, workflowexecutiondata.FieldOutputs)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowExecutionDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflowexecutiondata.FieldLastHeartbeat:
		return m.LastHeartbeat()
	case workflowexecutiondata.FieldOutputs:
		return m.Outputs()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowExecutionDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflowexecutiondata.FieldLastHeartbeat:
		return m.OldLastHeartbeat(ctx)
	case workflowexecutiondata.FieldOutputs:
		return m.OldOutputs(ctx)
	}
	return nil, fmt.Errorf("unknown WorkflowExecutionData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowExecutionDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflowexecutiondata.FieldLastHeartbeat:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastHeartbeat(v)
		return nil
	case workflowexecutiondata.FieldOutputs:
		v, ok := value.([][]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutputs(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecutionData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowExecutionDataMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowExecutionDataMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowExecutionDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkflowExecutionData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowExecutionDataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflowexecutiondata.FieldLastHeartbeat) {
		fields = append(fields, workflowexecutiondata.FieldLastHeartbeat)
	}
	if m.FieldCleared(workflowexecutiondata.FieldOutputs) {
		fields = append(fields, workflowexecutiondata.FieldOutputs)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowExecutionDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowExecutionDataMutation) ClearField(name string) error {
	switch name {
	case workflowexecutiondata.FieldLastHeartbeat:
		m.ClearLastHeartbeat()
		return nil
	case workflowexecutiondata.FieldOutputs:
		m.ClearOutputs()
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecutionData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowExecutionDataMutation) ResetField(name string) error {
	switch name {
	case workflowexecutiondata.FieldLastHeartbeat:
		m.ResetLastHeartbeat()
		return nil
	case workflowexecutiondata.FieldOutputs:
		m.ResetOutputs()
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecutionData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowExecutionDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.workflow_execution != nil {
		edges = append(edges, workflowexecutiondata.EdgeWorkflowExecution)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowExecutionDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workflowexecutiondata.EdgeWorkflowExecution:
		if id := m.workflow_execution; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowExecutionDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowExecutionDataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowExecutionDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedworkflow_execution {
		edges = append(edges, workflowexecutiondata.EdgeWorkflowExecution)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowExecutionDataMutation) EdgeCleared(name string) bool {
	switch name {
	case workflowexecutiondata.EdgeWorkflowExecution:
		return m.clearedworkflow_execution
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowExecutionDataMutation) ClearEdge(name string) error {
	switch name {
	case workflowexecutiondata.EdgeWorkflowExecution:
		m.ClearWorkflowExecution()
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecutionData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowExecutionDataMutation) ResetEdge(name string) error {
	switch name {
	case workflowexecutiondata.EdgeWorkflowExecution:
		m.ResetWorkflowExecution()
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecutionData edge %s", name)
}
