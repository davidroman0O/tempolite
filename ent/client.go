// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/davidroman0O/tempolite/ent/migrate"
	"github.com/davidroman0O/tempolite/ent/schema"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/davidroman0O/tempolite/ent/activitydata"
	"github.com/davidroman0O/tempolite/ent/activityentity"
	"github.com/davidroman0O/tempolite/ent/activityexecution"
	"github.com/davidroman0O/tempolite/ent/activityexecutiondata"
	"github.com/davidroman0O/tempolite/ent/hierarchy"
	"github.com/davidroman0O/tempolite/ent/queue"
	"github.com/davidroman0O/tempolite/ent/run"
	"github.com/davidroman0O/tempolite/ent/sagadata"
	"github.com/davidroman0O/tempolite/ent/sagaentity"
	"github.com/davidroman0O/tempolite/ent/sagaexecution"
	"github.com/davidroman0O/tempolite/ent/sagaexecutiondata"
	"github.com/davidroman0O/tempolite/ent/sagavalue"
	"github.com/davidroman0O/tempolite/ent/sideeffectdata"
	"github.com/davidroman0O/tempolite/ent/sideeffectentity"
	"github.com/davidroman0O/tempolite/ent/sideeffectexecution"
	"github.com/davidroman0O/tempolite/ent/sideeffectexecutiondata"
	"github.com/davidroman0O/tempolite/ent/signaldata"
	"github.com/davidroman0O/tempolite/ent/signalentity"
	"github.com/davidroman0O/tempolite/ent/signalexecution"
	"github.com/davidroman0O/tempolite/ent/signalexecutiondata"
	"github.com/davidroman0O/tempolite/ent/version"
	"github.com/davidroman0O/tempolite/ent/workflowdata"
	"github.com/davidroman0O/tempolite/ent/workflowentity"
	"github.com/davidroman0O/tempolite/ent/workflowexecution"
	"github.com/davidroman0O/tempolite/ent/workflowexecutiondata"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// ActivityData is the client for interacting with the ActivityData builders.
	ActivityData *ActivityDataClient
	// ActivityEntity is the client for interacting with the ActivityEntity builders.
	ActivityEntity *ActivityEntityClient
	// ActivityExecution is the client for interacting with the ActivityExecution builders.
	ActivityExecution *ActivityExecutionClient
	// ActivityExecutionData is the client for interacting with the ActivityExecutionData builders.
	ActivityExecutionData *ActivityExecutionDataClient
	// Hierarchy is the client for interacting with the Hierarchy builders.
	Hierarchy *HierarchyClient
	// Queue is the client for interacting with the Queue builders.
	Queue *QueueClient
	// Run is the client for interacting with the Run builders.
	Run *RunClient
	// SagaData is the client for interacting with the SagaData builders.
	SagaData *SagaDataClient
	// SagaEntity is the client for interacting with the SagaEntity builders.
	SagaEntity *SagaEntityClient
	// SagaExecution is the client for interacting with the SagaExecution builders.
	SagaExecution *SagaExecutionClient
	// SagaExecutionData is the client for interacting with the SagaExecutionData builders.
	SagaExecutionData *SagaExecutionDataClient
	// SagaValue is the client for interacting with the SagaValue builders.
	SagaValue *SagaValueClient
	// SideEffectData is the client for interacting with the SideEffectData builders.
	SideEffectData *SideEffectDataClient
	// SideEffectEntity is the client for interacting with the SideEffectEntity builders.
	SideEffectEntity *SideEffectEntityClient
	// SideEffectExecution is the client for interacting with the SideEffectExecution builders.
	SideEffectExecution *SideEffectExecutionClient
	// SideEffectExecutionData is the client for interacting with the SideEffectExecutionData builders.
	SideEffectExecutionData *SideEffectExecutionDataClient
	// SignalData is the client for interacting with the SignalData builders.
	SignalData *SignalDataClient
	// SignalEntity is the client for interacting with the SignalEntity builders.
	SignalEntity *SignalEntityClient
	// SignalExecution is the client for interacting with the SignalExecution builders.
	SignalExecution *SignalExecutionClient
	// SignalExecutionData is the client for interacting with the SignalExecutionData builders.
	SignalExecutionData *SignalExecutionDataClient
	// Version is the client for interacting with the Version builders.
	Version *VersionClient
	// WorkflowData is the client for interacting with the WorkflowData builders.
	WorkflowData *WorkflowDataClient
	// WorkflowEntity is the client for interacting with the WorkflowEntity builders.
	WorkflowEntity *WorkflowEntityClient
	// WorkflowExecution is the client for interacting with the WorkflowExecution builders.
	WorkflowExecution *WorkflowExecutionClient
	// WorkflowExecutionData is the client for interacting with the WorkflowExecutionData builders.
	WorkflowExecutionData *WorkflowExecutionDataClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.ActivityData = NewActivityDataClient(c.config)
	c.ActivityEntity = NewActivityEntityClient(c.config)
	c.ActivityExecution = NewActivityExecutionClient(c.config)
	c.ActivityExecutionData = NewActivityExecutionDataClient(c.config)
	c.Hierarchy = NewHierarchyClient(c.config)
	c.Queue = NewQueueClient(c.config)
	c.Run = NewRunClient(c.config)
	c.SagaData = NewSagaDataClient(c.config)
	c.SagaEntity = NewSagaEntityClient(c.config)
	c.SagaExecution = NewSagaExecutionClient(c.config)
	c.SagaExecutionData = NewSagaExecutionDataClient(c.config)
	c.SagaValue = NewSagaValueClient(c.config)
	c.SideEffectData = NewSideEffectDataClient(c.config)
	c.SideEffectEntity = NewSideEffectEntityClient(c.config)
	c.SideEffectExecution = NewSideEffectExecutionClient(c.config)
	c.SideEffectExecutionData = NewSideEffectExecutionDataClient(c.config)
	c.SignalData = NewSignalDataClient(c.config)
	c.SignalEntity = NewSignalEntityClient(c.config)
	c.SignalExecution = NewSignalExecutionClient(c.config)
	c.SignalExecutionData = NewSignalExecutionDataClient(c.config)
	c.Version = NewVersionClient(c.config)
	c.WorkflowData = NewWorkflowDataClient(c.config)
	c.WorkflowEntity = NewWorkflowEntityClient(c.config)
	c.WorkflowExecution = NewWorkflowExecutionClient(c.config)
	c.WorkflowExecutionData = NewWorkflowExecutionDataClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                     ctx,
		config:                  cfg,
		ActivityData:            NewActivityDataClient(cfg),
		ActivityEntity:          NewActivityEntityClient(cfg),
		ActivityExecution:       NewActivityExecutionClient(cfg),
		ActivityExecutionData:   NewActivityExecutionDataClient(cfg),
		Hierarchy:               NewHierarchyClient(cfg),
		Queue:                   NewQueueClient(cfg),
		Run:                     NewRunClient(cfg),
		SagaData:                NewSagaDataClient(cfg),
		SagaEntity:              NewSagaEntityClient(cfg),
		SagaExecution:           NewSagaExecutionClient(cfg),
		SagaExecutionData:       NewSagaExecutionDataClient(cfg),
		SagaValue:               NewSagaValueClient(cfg),
		SideEffectData:          NewSideEffectDataClient(cfg),
		SideEffectEntity:        NewSideEffectEntityClient(cfg),
		SideEffectExecution:     NewSideEffectExecutionClient(cfg),
		SideEffectExecutionData: NewSideEffectExecutionDataClient(cfg),
		SignalData:              NewSignalDataClient(cfg),
		SignalEntity:            NewSignalEntityClient(cfg),
		SignalExecution:         NewSignalExecutionClient(cfg),
		SignalExecutionData:     NewSignalExecutionDataClient(cfg),
		Version:                 NewVersionClient(cfg),
		WorkflowData:            NewWorkflowDataClient(cfg),
		WorkflowEntity:          NewWorkflowEntityClient(cfg),
		WorkflowExecution:       NewWorkflowExecutionClient(cfg),
		WorkflowExecutionData:   NewWorkflowExecutionDataClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                     ctx,
		config:                  cfg,
		ActivityData:            NewActivityDataClient(cfg),
		ActivityEntity:          NewActivityEntityClient(cfg),
		ActivityExecution:       NewActivityExecutionClient(cfg),
		ActivityExecutionData:   NewActivityExecutionDataClient(cfg),
		Hierarchy:               NewHierarchyClient(cfg),
		Queue:                   NewQueueClient(cfg),
		Run:                     NewRunClient(cfg),
		SagaData:                NewSagaDataClient(cfg),
		SagaEntity:              NewSagaEntityClient(cfg),
		SagaExecution:           NewSagaExecutionClient(cfg),
		SagaExecutionData:       NewSagaExecutionDataClient(cfg),
		SagaValue:               NewSagaValueClient(cfg),
		SideEffectData:          NewSideEffectDataClient(cfg),
		SideEffectEntity:        NewSideEffectEntityClient(cfg),
		SideEffectExecution:     NewSideEffectExecutionClient(cfg),
		SideEffectExecutionData: NewSideEffectExecutionDataClient(cfg),
		SignalData:              NewSignalDataClient(cfg),
		SignalEntity:            NewSignalEntityClient(cfg),
		SignalExecution:         NewSignalExecutionClient(cfg),
		SignalExecutionData:     NewSignalExecutionDataClient(cfg),
		Version:                 NewVersionClient(cfg),
		WorkflowData:            NewWorkflowDataClient(cfg),
		WorkflowEntity:          NewWorkflowEntityClient(cfg),
		WorkflowExecution:       NewWorkflowExecutionClient(cfg),
		WorkflowExecutionData:   NewWorkflowExecutionDataClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		ActivityData.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.ActivityData, c.ActivityEntity, c.ActivityExecution, c.ActivityExecutionData,
		c.Hierarchy, c.Queue, c.Run, c.SagaData, c.SagaEntity, c.SagaExecution,
		c.SagaExecutionData, c.SagaValue, c.SideEffectData, c.SideEffectEntity,
		c.SideEffectExecution, c.SideEffectExecutionData, c.SignalData, c.SignalEntity,
		c.SignalExecution, c.SignalExecutionData, c.Version, c.WorkflowData,
		c.WorkflowEntity, c.WorkflowExecution, c.WorkflowExecutionData,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.ActivityData, c.ActivityEntity, c.ActivityExecution, c.ActivityExecutionData,
		c.Hierarchy, c.Queue, c.Run, c.SagaData, c.SagaEntity, c.SagaExecution,
		c.SagaExecutionData, c.SagaValue, c.SideEffectData, c.SideEffectEntity,
		c.SideEffectExecution, c.SideEffectExecutionData, c.SignalData, c.SignalEntity,
		c.SignalExecution, c.SignalExecutionData, c.Version, c.WorkflowData,
		c.WorkflowEntity, c.WorkflowExecution, c.WorkflowExecutionData,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *ActivityDataMutation:
		return c.ActivityData.mutate(ctx, m)
	case *ActivityEntityMutation:
		return c.ActivityEntity.mutate(ctx, m)
	case *ActivityExecutionMutation:
		return c.ActivityExecution.mutate(ctx, m)
	case *ActivityExecutionDataMutation:
		return c.ActivityExecutionData.mutate(ctx, m)
	case *HierarchyMutation:
		return c.Hierarchy.mutate(ctx, m)
	case *QueueMutation:
		return c.Queue.mutate(ctx, m)
	case *RunMutation:
		return c.Run.mutate(ctx, m)
	case *SagaDataMutation:
		return c.SagaData.mutate(ctx, m)
	case *SagaEntityMutation:
		return c.SagaEntity.mutate(ctx, m)
	case *SagaExecutionMutation:
		return c.SagaExecution.mutate(ctx, m)
	case *SagaExecutionDataMutation:
		return c.SagaExecutionData.mutate(ctx, m)
	case *SagaValueMutation:
		return c.SagaValue.mutate(ctx, m)
	case *SideEffectDataMutation:
		return c.SideEffectData.mutate(ctx, m)
	case *SideEffectEntityMutation:
		return c.SideEffectEntity.mutate(ctx, m)
	case *SideEffectExecutionMutation:
		return c.SideEffectExecution.mutate(ctx, m)
	case *SideEffectExecutionDataMutation:
		return c.SideEffectExecutionData.mutate(ctx, m)
	case *SignalDataMutation:
		return c.SignalData.mutate(ctx, m)
	case *SignalEntityMutation:
		return c.SignalEntity.mutate(ctx, m)
	case *SignalExecutionMutation:
		return c.SignalExecution.mutate(ctx, m)
	case *SignalExecutionDataMutation:
		return c.SignalExecutionData.mutate(ctx, m)
	case *VersionMutation:
		return c.Version.mutate(ctx, m)
	case *WorkflowDataMutation:
		return c.WorkflowData.mutate(ctx, m)
	case *WorkflowEntityMutation:
		return c.WorkflowEntity.mutate(ctx, m)
	case *WorkflowExecutionMutation:
		return c.WorkflowExecution.mutate(ctx, m)
	case *WorkflowExecutionDataMutation:
		return c.WorkflowExecutionData.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// ActivityDataClient is a client for the ActivityData schema.
type ActivityDataClient struct {
	config
}

// NewActivityDataClient returns a client for the ActivityData from the given config.
func NewActivityDataClient(c config) *ActivityDataClient {
	return &ActivityDataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `activitydata.Hooks(f(g(h())))`.
func (c *ActivityDataClient) Use(hooks ...Hook) {
	c.hooks.ActivityData = append(c.hooks.ActivityData, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `activitydata.Intercept(f(g(h())))`.
func (c *ActivityDataClient) Intercept(interceptors ...Interceptor) {
	c.inters.ActivityData = append(c.inters.ActivityData, interceptors...)
}

// Create returns a builder for creating a ActivityData entity.
func (c *ActivityDataClient) Create() *ActivityDataCreate {
	mutation := newActivityDataMutation(c.config, OpCreate)
	return &ActivityDataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ActivityData entities.
func (c *ActivityDataClient) CreateBulk(builders ...*ActivityDataCreate) *ActivityDataCreateBulk {
	return &ActivityDataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ActivityDataClient) MapCreateBulk(slice any, setFunc func(*ActivityDataCreate, int)) *ActivityDataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ActivityDataCreateBulk{err: fmt.Errorf("calling to ActivityDataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ActivityDataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ActivityDataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ActivityData.
func (c *ActivityDataClient) Update() *ActivityDataUpdate {
	mutation := newActivityDataMutation(c.config, OpUpdate)
	return &ActivityDataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ActivityDataClient) UpdateOne(ad *ActivityData) *ActivityDataUpdateOne {
	mutation := newActivityDataMutation(c.config, OpUpdateOne, withActivityData(ad))
	return &ActivityDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ActivityDataClient) UpdateOneID(id schema.ActivityDataID) *ActivityDataUpdateOne {
	mutation := newActivityDataMutation(c.config, OpUpdateOne, withActivityDataID(id))
	return &ActivityDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ActivityData.
func (c *ActivityDataClient) Delete() *ActivityDataDelete {
	mutation := newActivityDataMutation(c.config, OpDelete)
	return &ActivityDataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ActivityDataClient) DeleteOne(ad *ActivityData) *ActivityDataDeleteOne {
	return c.DeleteOneID(ad.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ActivityDataClient) DeleteOneID(id schema.ActivityDataID) *ActivityDataDeleteOne {
	builder := c.Delete().Where(activitydata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ActivityDataDeleteOne{builder}
}

// Query returns a query builder for ActivityData.
func (c *ActivityDataClient) Query() *ActivityDataQuery {
	return &ActivityDataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeActivityData},
		inters: c.Interceptors(),
	}
}

// Get returns a ActivityData entity by its id.
func (c *ActivityDataClient) Get(ctx context.Context, id schema.ActivityDataID) (*ActivityData, error) {
	return c.Query().Where(activitydata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ActivityDataClient) GetX(ctx context.Context, id schema.ActivityDataID) *ActivityData {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryActivity queries the activity edge of a ActivityData.
func (c *ActivityDataClient) QueryActivity(ad *ActivityData) *ActivityEntityQuery {
	query := (&ActivityEntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ad.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(activitydata.Table, activitydata.FieldID, id),
			sqlgraph.To(activityentity.Table, activityentity.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, activitydata.ActivityTable, activitydata.ActivityColumn),
		)
		fromV = sqlgraph.Neighbors(ad.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ActivityDataClient) Hooks() []Hook {
	return c.hooks.ActivityData
}

// Interceptors returns the client interceptors.
func (c *ActivityDataClient) Interceptors() []Interceptor {
	return c.inters.ActivityData
}

func (c *ActivityDataClient) mutate(ctx context.Context, m *ActivityDataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ActivityDataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ActivityDataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ActivityDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ActivityDataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ActivityData mutation op: %q", m.Op())
	}
}

// ActivityEntityClient is a client for the ActivityEntity schema.
type ActivityEntityClient struct {
	config
}

// NewActivityEntityClient returns a client for the ActivityEntity from the given config.
func NewActivityEntityClient(c config) *ActivityEntityClient {
	return &ActivityEntityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `activityentity.Hooks(f(g(h())))`.
func (c *ActivityEntityClient) Use(hooks ...Hook) {
	c.hooks.ActivityEntity = append(c.hooks.ActivityEntity, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `activityentity.Intercept(f(g(h())))`.
func (c *ActivityEntityClient) Intercept(interceptors ...Interceptor) {
	c.inters.ActivityEntity = append(c.inters.ActivityEntity, interceptors...)
}

// Create returns a builder for creating a ActivityEntity entity.
func (c *ActivityEntityClient) Create() *ActivityEntityCreate {
	mutation := newActivityEntityMutation(c.config, OpCreate)
	return &ActivityEntityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ActivityEntity entities.
func (c *ActivityEntityClient) CreateBulk(builders ...*ActivityEntityCreate) *ActivityEntityCreateBulk {
	return &ActivityEntityCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ActivityEntityClient) MapCreateBulk(slice any, setFunc func(*ActivityEntityCreate, int)) *ActivityEntityCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ActivityEntityCreateBulk{err: fmt.Errorf("calling to ActivityEntityClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ActivityEntityCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ActivityEntityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ActivityEntity.
func (c *ActivityEntityClient) Update() *ActivityEntityUpdate {
	mutation := newActivityEntityMutation(c.config, OpUpdate)
	return &ActivityEntityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ActivityEntityClient) UpdateOne(ae *ActivityEntity) *ActivityEntityUpdateOne {
	mutation := newActivityEntityMutation(c.config, OpUpdateOne, withActivityEntity(ae))
	return &ActivityEntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ActivityEntityClient) UpdateOneID(id schema.ActivityEntityID) *ActivityEntityUpdateOne {
	mutation := newActivityEntityMutation(c.config, OpUpdateOne, withActivityEntityID(id))
	return &ActivityEntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ActivityEntity.
func (c *ActivityEntityClient) Delete() *ActivityEntityDelete {
	mutation := newActivityEntityMutation(c.config, OpDelete)
	return &ActivityEntityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ActivityEntityClient) DeleteOne(ae *ActivityEntity) *ActivityEntityDeleteOne {
	return c.DeleteOneID(ae.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ActivityEntityClient) DeleteOneID(id schema.ActivityEntityID) *ActivityEntityDeleteOne {
	builder := c.Delete().Where(activityentity.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ActivityEntityDeleteOne{builder}
}

// Query returns a query builder for ActivityEntity.
func (c *ActivityEntityClient) Query() *ActivityEntityQuery {
	return &ActivityEntityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeActivityEntity},
		inters: c.Interceptors(),
	}
}

// Get returns a ActivityEntity entity by its id.
func (c *ActivityEntityClient) Get(ctx context.Context, id schema.ActivityEntityID) (*ActivityEntity, error) {
	return c.Query().Where(activityentity.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ActivityEntityClient) GetX(ctx context.Context, id schema.ActivityEntityID) *ActivityEntity {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryWorkflow queries the workflow edge of a ActivityEntity.
func (c *ActivityEntityClient) QueryWorkflow(ae *ActivityEntity) *WorkflowEntityQuery {
	query := (&WorkflowEntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ae.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(activityentity.Table, activityentity.FieldID, id),
			sqlgraph.To(workflowentity.Table, workflowentity.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, activityentity.WorkflowTable, activityentity.WorkflowColumn),
		)
		fromV = sqlgraph.Neighbors(ae.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActivityData queries the activity_data edge of a ActivityEntity.
func (c *ActivityEntityClient) QueryActivityData(ae *ActivityEntity) *ActivityDataQuery {
	query := (&ActivityDataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ae.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(activityentity.Table, activityentity.FieldID, id),
			sqlgraph.To(activitydata.Table, activitydata.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, activityentity.ActivityDataTable, activityentity.ActivityDataColumn),
		)
		fromV = sqlgraph.Neighbors(ae.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExecutions queries the executions edge of a ActivityEntity.
func (c *ActivityEntityClient) QueryExecutions(ae *ActivityEntity) *ActivityExecutionQuery {
	query := (&ActivityExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ae.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(activityentity.Table, activityentity.FieldID, id),
			sqlgraph.To(activityexecution.Table, activityexecution.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, activityentity.ExecutionsTable, activityentity.ExecutionsColumn),
		)
		fromV = sqlgraph.Neighbors(ae.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ActivityEntityClient) Hooks() []Hook {
	return c.hooks.ActivityEntity
}

// Interceptors returns the client interceptors.
func (c *ActivityEntityClient) Interceptors() []Interceptor {
	return c.inters.ActivityEntity
}

func (c *ActivityEntityClient) mutate(ctx context.Context, m *ActivityEntityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ActivityEntityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ActivityEntityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ActivityEntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ActivityEntityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ActivityEntity mutation op: %q", m.Op())
	}
}

// ActivityExecutionClient is a client for the ActivityExecution schema.
type ActivityExecutionClient struct {
	config
}

// NewActivityExecutionClient returns a client for the ActivityExecution from the given config.
func NewActivityExecutionClient(c config) *ActivityExecutionClient {
	return &ActivityExecutionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `activityexecution.Hooks(f(g(h())))`.
func (c *ActivityExecutionClient) Use(hooks ...Hook) {
	c.hooks.ActivityExecution = append(c.hooks.ActivityExecution, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `activityexecution.Intercept(f(g(h())))`.
func (c *ActivityExecutionClient) Intercept(interceptors ...Interceptor) {
	c.inters.ActivityExecution = append(c.inters.ActivityExecution, interceptors...)
}

// Create returns a builder for creating a ActivityExecution entity.
func (c *ActivityExecutionClient) Create() *ActivityExecutionCreate {
	mutation := newActivityExecutionMutation(c.config, OpCreate)
	return &ActivityExecutionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ActivityExecution entities.
func (c *ActivityExecutionClient) CreateBulk(builders ...*ActivityExecutionCreate) *ActivityExecutionCreateBulk {
	return &ActivityExecutionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ActivityExecutionClient) MapCreateBulk(slice any, setFunc func(*ActivityExecutionCreate, int)) *ActivityExecutionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ActivityExecutionCreateBulk{err: fmt.Errorf("calling to ActivityExecutionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ActivityExecutionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ActivityExecutionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ActivityExecution.
func (c *ActivityExecutionClient) Update() *ActivityExecutionUpdate {
	mutation := newActivityExecutionMutation(c.config, OpUpdate)
	return &ActivityExecutionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ActivityExecutionClient) UpdateOne(ae *ActivityExecution) *ActivityExecutionUpdateOne {
	mutation := newActivityExecutionMutation(c.config, OpUpdateOne, withActivityExecution(ae))
	return &ActivityExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ActivityExecutionClient) UpdateOneID(id schema.ActivityExecutionID) *ActivityExecutionUpdateOne {
	mutation := newActivityExecutionMutation(c.config, OpUpdateOne, withActivityExecutionID(id))
	return &ActivityExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ActivityExecution.
func (c *ActivityExecutionClient) Delete() *ActivityExecutionDelete {
	mutation := newActivityExecutionMutation(c.config, OpDelete)
	return &ActivityExecutionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ActivityExecutionClient) DeleteOne(ae *ActivityExecution) *ActivityExecutionDeleteOne {
	return c.DeleteOneID(ae.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ActivityExecutionClient) DeleteOneID(id schema.ActivityExecutionID) *ActivityExecutionDeleteOne {
	builder := c.Delete().Where(activityexecution.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ActivityExecutionDeleteOne{builder}
}

// Query returns a query builder for ActivityExecution.
func (c *ActivityExecutionClient) Query() *ActivityExecutionQuery {
	return &ActivityExecutionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeActivityExecution},
		inters: c.Interceptors(),
	}
}

// Get returns a ActivityExecution entity by its id.
func (c *ActivityExecutionClient) Get(ctx context.Context, id schema.ActivityExecutionID) (*ActivityExecution, error) {
	return c.Query().Where(activityexecution.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ActivityExecutionClient) GetX(ctx context.Context, id schema.ActivityExecutionID) *ActivityExecution {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryActivity queries the activity edge of a ActivityExecution.
func (c *ActivityExecutionClient) QueryActivity(ae *ActivityExecution) *ActivityEntityQuery {
	query := (&ActivityEntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ae.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(activityexecution.Table, activityexecution.FieldID, id),
			sqlgraph.To(activityentity.Table, activityentity.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, activityexecution.ActivityTable, activityexecution.ActivityColumn),
		)
		fromV = sqlgraph.Neighbors(ae.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExecutionData queries the execution_data edge of a ActivityExecution.
func (c *ActivityExecutionClient) QueryExecutionData(ae *ActivityExecution) *ActivityExecutionDataQuery {
	query := (&ActivityExecutionDataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ae.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(activityexecution.Table, activityexecution.FieldID, id),
			sqlgraph.To(activityexecutiondata.Table, activityexecutiondata.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, activityexecution.ExecutionDataTable, activityexecution.ExecutionDataColumn),
		)
		fromV = sqlgraph.Neighbors(ae.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ActivityExecutionClient) Hooks() []Hook {
	return c.hooks.ActivityExecution
}

// Interceptors returns the client interceptors.
func (c *ActivityExecutionClient) Interceptors() []Interceptor {
	return c.inters.ActivityExecution
}

func (c *ActivityExecutionClient) mutate(ctx context.Context, m *ActivityExecutionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ActivityExecutionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ActivityExecutionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ActivityExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ActivityExecutionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ActivityExecution mutation op: %q", m.Op())
	}
}

// ActivityExecutionDataClient is a client for the ActivityExecutionData schema.
type ActivityExecutionDataClient struct {
	config
}

// NewActivityExecutionDataClient returns a client for the ActivityExecutionData from the given config.
func NewActivityExecutionDataClient(c config) *ActivityExecutionDataClient {
	return &ActivityExecutionDataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `activityexecutiondata.Hooks(f(g(h())))`.
func (c *ActivityExecutionDataClient) Use(hooks ...Hook) {
	c.hooks.ActivityExecutionData = append(c.hooks.ActivityExecutionData, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `activityexecutiondata.Intercept(f(g(h())))`.
func (c *ActivityExecutionDataClient) Intercept(interceptors ...Interceptor) {
	c.inters.ActivityExecutionData = append(c.inters.ActivityExecutionData, interceptors...)
}

// Create returns a builder for creating a ActivityExecutionData entity.
func (c *ActivityExecutionDataClient) Create() *ActivityExecutionDataCreate {
	mutation := newActivityExecutionDataMutation(c.config, OpCreate)
	return &ActivityExecutionDataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ActivityExecutionData entities.
func (c *ActivityExecutionDataClient) CreateBulk(builders ...*ActivityExecutionDataCreate) *ActivityExecutionDataCreateBulk {
	return &ActivityExecutionDataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ActivityExecutionDataClient) MapCreateBulk(slice any, setFunc func(*ActivityExecutionDataCreate, int)) *ActivityExecutionDataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ActivityExecutionDataCreateBulk{err: fmt.Errorf("calling to ActivityExecutionDataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ActivityExecutionDataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ActivityExecutionDataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ActivityExecutionData.
func (c *ActivityExecutionDataClient) Update() *ActivityExecutionDataUpdate {
	mutation := newActivityExecutionDataMutation(c.config, OpUpdate)
	return &ActivityExecutionDataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ActivityExecutionDataClient) UpdateOne(aed *ActivityExecutionData) *ActivityExecutionDataUpdateOne {
	mutation := newActivityExecutionDataMutation(c.config, OpUpdateOne, withActivityExecutionData(aed))
	return &ActivityExecutionDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ActivityExecutionDataClient) UpdateOneID(id schema.ActivityExecutionDataID) *ActivityExecutionDataUpdateOne {
	mutation := newActivityExecutionDataMutation(c.config, OpUpdateOne, withActivityExecutionDataID(id))
	return &ActivityExecutionDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ActivityExecutionData.
func (c *ActivityExecutionDataClient) Delete() *ActivityExecutionDataDelete {
	mutation := newActivityExecutionDataMutation(c.config, OpDelete)
	return &ActivityExecutionDataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ActivityExecutionDataClient) DeleteOne(aed *ActivityExecutionData) *ActivityExecutionDataDeleteOne {
	return c.DeleteOneID(aed.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ActivityExecutionDataClient) DeleteOneID(id schema.ActivityExecutionDataID) *ActivityExecutionDataDeleteOne {
	builder := c.Delete().Where(activityexecutiondata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ActivityExecutionDataDeleteOne{builder}
}

// Query returns a query builder for ActivityExecutionData.
func (c *ActivityExecutionDataClient) Query() *ActivityExecutionDataQuery {
	return &ActivityExecutionDataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeActivityExecutionData},
		inters: c.Interceptors(),
	}
}

// Get returns a ActivityExecutionData entity by its id.
func (c *ActivityExecutionDataClient) Get(ctx context.Context, id schema.ActivityExecutionDataID) (*ActivityExecutionData, error) {
	return c.Query().Where(activityexecutiondata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ActivityExecutionDataClient) GetX(ctx context.Context, id schema.ActivityExecutionDataID) *ActivityExecutionData {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryExecution queries the execution edge of a ActivityExecutionData.
func (c *ActivityExecutionDataClient) QueryExecution(aed *ActivityExecutionData) *ActivityExecutionQuery {
	query := (&ActivityExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := aed.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(activityexecutiondata.Table, activityexecutiondata.FieldID, id),
			sqlgraph.To(activityexecution.Table, activityexecution.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, activityexecutiondata.ExecutionTable, activityexecutiondata.ExecutionColumn),
		)
		fromV = sqlgraph.Neighbors(aed.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ActivityExecutionDataClient) Hooks() []Hook {
	return c.hooks.ActivityExecutionData
}

// Interceptors returns the client interceptors.
func (c *ActivityExecutionDataClient) Interceptors() []Interceptor {
	return c.inters.ActivityExecutionData
}

func (c *ActivityExecutionDataClient) mutate(ctx context.Context, m *ActivityExecutionDataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ActivityExecutionDataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ActivityExecutionDataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ActivityExecutionDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ActivityExecutionDataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ActivityExecutionData mutation op: %q", m.Op())
	}
}

// HierarchyClient is a client for the Hierarchy schema.
type HierarchyClient struct {
	config
}

// NewHierarchyClient returns a client for the Hierarchy from the given config.
func NewHierarchyClient(c config) *HierarchyClient {
	return &HierarchyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `hierarchy.Hooks(f(g(h())))`.
func (c *HierarchyClient) Use(hooks ...Hook) {
	c.hooks.Hierarchy = append(c.hooks.Hierarchy, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `hierarchy.Intercept(f(g(h())))`.
func (c *HierarchyClient) Intercept(interceptors ...Interceptor) {
	c.inters.Hierarchy = append(c.inters.Hierarchy, interceptors...)
}

// Create returns a builder for creating a Hierarchy entity.
func (c *HierarchyClient) Create() *HierarchyCreate {
	mutation := newHierarchyMutation(c.config, OpCreate)
	return &HierarchyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Hierarchy entities.
func (c *HierarchyClient) CreateBulk(builders ...*HierarchyCreate) *HierarchyCreateBulk {
	return &HierarchyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *HierarchyClient) MapCreateBulk(slice any, setFunc func(*HierarchyCreate, int)) *HierarchyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &HierarchyCreateBulk{err: fmt.Errorf("calling to HierarchyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*HierarchyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &HierarchyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Hierarchy.
func (c *HierarchyClient) Update() *HierarchyUpdate {
	mutation := newHierarchyMutation(c.config, OpUpdate)
	return &HierarchyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HierarchyClient) UpdateOne(h *Hierarchy) *HierarchyUpdateOne {
	mutation := newHierarchyMutation(c.config, OpUpdateOne, withHierarchy(h))
	return &HierarchyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HierarchyClient) UpdateOneID(id schema.HierarchyID) *HierarchyUpdateOne {
	mutation := newHierarchyMutation(c.config, OpUpdateOne, withHierarchyID(id))
	return &HierarchyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Hierarchy.
func (c *HierarchyClient) Delete() *HierarchyDelete {
	mutation := newHierarchyMutation(c.config, OpDelete)
	return &HierarchyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HierarchyClient) DeleteOne(h *Hierarchy) *HierarchyDeleteOne {
	return c.DeleteOneID(h.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HierarchyClient) DeleteOneID(id schema.HierarchyID) *HierarchyDeleteOne {
	builder := c.Delete().Where(hierarchy.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HierarchyDeleteOne{builder}
}

// Query returns a query builder for Hierarchy.
func (c *HierarchyClient) Query() *HierarchyQuery {
	return &HierarchyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeHierarchy},
		inters: c.Interceptors(),
	}
}

// Get returns a Hierarchy entity by its id.
func (c *HierarchyClient) Get(ctx context.Context, id schema.HierarchyID) (*Hierarchy, error) {
	return c.Query().Where(hierarchy.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HierarchyClient) GetX(ctx context.Context, id schema.HierarchyID) *Hierarchy {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRun queries the run edge of a Hierarchy.
func (c *HierarchyClient) QueryRun(h *Hierarchy) *RunQuery {
	query := (&RunClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := h.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hierarchy.Table, hierarchy.FieldID, id),
			sqlgraph.To(run.Table, run.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, hierarchy.RunTable, hierarchy.RunColumn),
		)
		fromV = sqlgraph.Neighbors(h.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *HierarchyClient) Hooks() []Hook {
	return c.hooks.Hierarchy
}

// Interceptors returns the client interceptors.
func (c *HierarchyClient) Interceptors() []Interceptor {
	return c.inters.Hierarchy
}

func (c *HierarchyClient) mutate(ctx context.Context, m *HierarchyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&HierarchyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&HierarchyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&HierarchyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&HierarchyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Hierarchy mutation op: %q", m.Op())
	}
}

// QueueClient is a client for the Queue schema.
type QueueClient struct {
	config
}

// NewQueueClient returns a client for the Queue from the given config.
func NewQueueClient(c config) *QueueClient {
	return &QueueClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `queue.Hooks(f(g(h())))`.
func (c *QueueClient) Use(hooks ...Hook) {
	c.hooks.Queue = append(c.hooks.Queue, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `queue.Intercept(f(g(h())))`.
func (c *QueueClient) Intercept(interceptors ...Interceptor) {
	c.inters.Queue = append(c.inters.Queue, interceptors...)
}

// Create returns a builder for creating a Queue entity.
func (c *QueueClient) Create() *QueueCreate {
	mutation := newQueueMutation(c.config, OpCreate)
	return &QueueCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Queue entities.
func (c *QueueClient) CreateBulk(builders ...*QueueCreate) *QueueCreateBulk {
	return &QueueCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *QueueClient) MapCreateBulk(slice any, setFunc func(*QueueCreate, int)) *QueueCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &QueueCreateBulk{err: fmt.Errorf("calling to QueueClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*QueueCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &QueueCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Queue.
func (c *QueueClient) Update() *QueueUpdate {
	mutation := newQueueMutation(c.config, OpUpdate)
	return &QueueUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *QueueClient) UpdateOne(q *Queue) *QueueUpdateOne {
	mutation := newQueueMutation(c.config, OpUpdateOne, withQueue(q))
	return &QueueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *QueueClient) UpdateOneID(id schema.QueueID) *QueueUpdateOne {
	mutation := newQueueMutation(c.config, OpUpdateOne, withQueueID(id))
	return &QueueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Queue.
func (c *QueueClient) Delete() *QueueDelete {
	mutation := newQueueMutation(c.config, OpDelete)
	return &QueueDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *QueueClient) DeleteOne(q *Queue) *QueueDeleteOne {
	return c.DeleteOneID(q.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *QueueClient) DeleteOneID(id schema.QueueID) *QueueDeleteOne {
	builder := c.Delete().Where(queue.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &QueueDeleteOne{builder}
}

// Query returns a query builder for Queue.
func (c *QueueClient) Query() *QueueQuery {
	return &QueueQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeQueue},
		inters: c.Interceptors(),
	}
}

// Get returns a Queue entity by its id.
func (c *QueueClient) Get(ctx context.Context, id schema.QueueID) (*Queue, error) {
	return c.Query().Where(queue.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *QueueClient) GetX(ctx context.Context, id schema.QueueID) *Queue {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEntities queries the entities edge of a Queue.
func (c *QueueClient) QueryEntities(q *Queue) *WorkflowEntityQuery {
	query := (&WorkflowEntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := q.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(queue.Table, queue.FieldID, id),
			sqlgraph.To(workflowentity.Table, workflowentity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, queue.EntitiesTable, queue.EntitiesColumn),
		)
		fromV = sqlgraph.Neighbors(q.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *QueueClient) Hooks() []Hook {
	return c.hooks.Queue
}

// Interceptors returns the client interceptors.
func (c *QueueClient) Interceptors() []Interceptor {
	return c.inters.Queue
}

func (c *QueueClient) mutate(ctx context.Context, m *QueueMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&QueueCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&QueueUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&QueueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&QueueDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Queue mutation op: %q", m.Op())
	}
}

// RunClient is a client for the Run schema.
type RunClient struct {
	config
}

// NewRunClient returns a client for the Run from the given config.
func NewRunClient(c config) *RunClient {
	return &RunClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `run.Hooks(f(g(h())))`.
func (c *RunClient) Use(hooks ...Hook) {
	c.hooks.Run = append(c.hooks.Run, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `run.Intercept(f(g(h())))`.
func (c *RunClient) Intercept(interceptors ...Interceptor) {
	c.inters.Run = append(c.inters.Run, interceptors...)
}

// Create returns a builder for creating a Run entity.
func (c *RunClient) Create() *RunCreate {
	mutation := newRunMutation(c.config, OpCreate)
	return &RunCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Run entities.
func (c *RunClient) CreateBulk(builders ...*RunCreate) *RunCreateBulk {
	return &RunCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RunClient) MapCreateBulk(slice any, setFunc func(*RunCreate, int)) *RunCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RunCreateBulk{err: fmt.Errorf("calling to RunClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RunCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RunCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Run.
func (c *RunClient) Update() *RunUpdate {
	mutation := newRunMutation(c.config, OpUpdate)
	return &RunUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RunClient) UpdateOne(r *Run) *RunUpdateOne {
	mutation := newRunMutation(c.config, OpUpdateOne, withRun(r))
	return &RunUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RunClient) UpdateOneID(id schema.RunID) *RunUpdateOne {
	mutation := newRunMutation(c.config, OpUpdateOne, withRunID(id))
	return &RunUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Run.
func (c *RunClient) Delete() *RunDelete {
	mutation := newRunMutation(c.config, OpDelete)
	return &RunDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RunClient) DeleteOne(r *Run) *RunDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RunClient) DeleteOneID(id schema.RunID) *RunDeleteOne {
	builder := c.Delete().Where(run.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RunDeleteOne{builder}
}

// Query returns a query builder for Run.
func (c *RunClient) Query() *RunQuery {
	return &RunQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRun},
		inters: c.Interceptors(),
	}
}

// Get returns a Run entity by its id.
func (c *RunClient) Get(ctx context.Context, id schema.RunID) (*Run, error) {
	return c.Query().Where(run.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RunClient) GetX(ctx context.Context, id schema.RunID) *Run {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEntities queries the entities edge of a Run.
func (c *RunClient) QueryEntities(r *Run) *WorkflowEntityQuery {
	query := (&WorkflowEntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(run.Table, run.FieldID, id),
			sqlgraph.To(workflowentity.Table, workflowentity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, run.EntitiesTable, run.EntitiesColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHierarchies queries the hierarchies edge of a Run.
func (c *RunClient) QueryHierarchies(r *Run) *HierarchyQuery {
	query := (&HierarchyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(run.Table, run.FieldID, id),
			sqlgraph.To(hierarchy.Table, hierarchy.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, run.HierarchiesTable, run.HierarchiesColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RunClient) Hooks() []Hook {
	return c.hooks.Run
}

// Interceptors returns the client interceptors.
func (c *RunClient) Interceptors() []Interceptor {
	return c.inters.Run
}

func (c *RunClient) mutate(ctx context.Context, m *RunMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RunCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RunUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RunUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RunDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Run mutation op: %q", m.Op())
	}
}

// SagaDataClient is a client for the SagaData schema.
type SagaDataClient struct {
	config
}

// NewSagaDataClient returns a client for the SagaData from the given config.
func NewSagaDataClient(c config) *SagaDataClient {
	return &SagaDataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sagadata.Hooks(f(g(h())))`.
func (c *SagaDataClient) Use(hooks ...Hook) {
	c.hooks.SagaData = append(c.hooks.SagaData, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sagadata.Intercept(f(g(h())))`.
func (c *SagaDataClient) Intercept(interceptors ...Interceptor) {
	c.inters.SagaData = append(c.inters.SagaData, interceptors...)
}

// Create returns a builder for creating a SagaData entity.
func (c *SagaDataClient) Create() *SagaDataCreate {
	mutation := newSagaDataMutation(c.config, OpCreate)
	return &SagaDataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SagaData entities.
func (c *SagaDataClient) CreateBulk(builders ...*SagaDataCreate) *SagaDataCreateBulk {
	return &SagaDataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SagaDataClient) MapCreateBulk(slice any, setFunc func(*SagaDataCreate, int)) *SagaDataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SagaDataCreateBulk{err: fmt.Errorf("calling to SagaDataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SagaDataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SagaDataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SagaData.
func (c *SagaDataClient) Update() *SagaDataUpdate {
	mutation := newSagaDataMutation(c.config, OpUpdate)
	return &SagaDataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SagaDataClient) UpdateOne(sd *SagaData) *SagaDataUpdateOne {
	mutation := newSagaDataMutation(c.config, OpUpdateOne, withSagaData(sd))
	return &SagaDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SagaDataClient) UpdateOneID(id schema.SagaDataID) *SagaDataUpdateOne {
	mutation := newSagaDataMutation(c.config, OpUpdateOne, withSagaDataID(id))
	return &SagaDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SagaData.
func (c *SagaDataClient) Delete() *SagaDataDelete {
	mutation := newSagaDataMutation(c.config, OpDelete)
	return &SagaDataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SagaDataClient) DeleteOne(sd *SagaData) *SagaDataDeleteOne {
	return c.DeleteOneID(sd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SagaDataClient) DeleteOneID(id schema.SagaDataID) *SagaDataDeleteOne {
	builder := c.Delete().Where(sagadata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SagaDataDeleteOne{builder}
}

// Query returns a query builder for SagaData.
func (c *SagaDataClient) Query() *SagaDataQuery {
	return &SagaDataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSagaData},
		inters: c.Interceptors(),
	}
}

// Get returns a SagaData entity by its id.
func (c *SagaDataClient) Get(ctx context.Context, id schema.SagaDataID) (*SagaData, error) {
	return c.Query().Where(sagadata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SagaDataClient) GetX(ctx context.Context, id schema.SagaDataID) *SagaData {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySaga queries the saga edge of a SagaData.
func (c *SagaDataClient) QuerySaga(sd *SagaData) *SagaEntityQuery {
	query := (&SagaEntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sagadata.Table, sagadata.FieldID, id),
			sqlgraph.To(sagaentity.Table, sagaentity.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, sagadata.SagaTable, sagadata.SagaColumn),
		)
		fromV = sqlgraph.Neighbors(sd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryValues queries the values edge of a SagaData.
func (c *SagaDataClient) QueryValues(sd *SagaData) *SagaValueQuery {
	query := (&SagaValueClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sagadata.Table, sagadata.FieldID, id),
			sqlgraph.To(sagavalue.Table, sagavalue.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, sagadata.ValuesTable, sagadata.ValuesColumn),
		)
		fromV = sqlgraph.Neighbors(sd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SagaDataClient) Hooks() []Hook {
	return c.hooks.SagaData
}

// Interceptors returns the client interceptors.
func (c *SagaDataClient) Interceptors() []Interceptor {
	return c.inters.SagaData
}

func (c *SagaDataClient) mutate(ctx context.Context, m *SagaDataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SagaDataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SagaDataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SagaDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SagaDataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SagaData mutation op: %q", m.Op())
	}
}

// SagaEntityClient is a client for the SagaEntity schema.
type SagaEntityClient struct {
	config
}

// NewSagaEntityClient returns a client for the SagaEntity from the given config.
func NewSagaEntityClient(c config) *SagaEntityClient {
	return &SagaEntityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sagaentity.Hooks(f(g(h())))`.
func (c *SagaEntityClient) Use(hooks ...Hook) {
	c.hooks.SagaEntity = append(c.hooks.SagaEntity, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sagaentity.Intercept(f(g(h())))`.
func (c *SagaEntityClient) Intercept(interceptors ...Interceptor) {
	c.inters.SagaEntity = append(c.inters.SagaEntity, interceptors...)
}

// Create returns a builder for creating a SagaEntity entity.
func (c *SagaEntityClient) Create() *SagaEntityCreate {
	mutation := newSagaEntityMutation(c.config, OpCreate)
	return &SagaEntityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SagaEntity entities.
func (c *SagaEntityClient) CreateBulk(builders ...*SagaEntityCreate) *SagaEntityCreateBulk {
	return &SagaEntityCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SagaEntityClient) MapCreateBulk(slice any, setFunc func(*SagaEntityCreate, int)) *SagaEntityCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SagaEntityCreateBulk{err: fmt.Errorf("calling to SagaEntityClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SagaEntityCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SagaEntityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SagaEntity.
func (c *SagaEntityClient) Update() *SagaEntityUpdate {
	mutation := newSagaEntityMutation(c.config, OpUpdate)
	return &SagaEntityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SagaEntityClient) UpdateOne(se *SagaEntity) *SagaEntityUpdateOne {
	mutation := newSagaEntityMutation(c.config, OpUpdateOne, withSagaEntity(se))
	return &SagaEntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SagaEntityClient) UpdateOneID(id schema.SagaEntityID) *SagaEntityUpdateOne {
	mutation := newSagaEntityMutation(c.config, OpUpdateOne, withSagaEntityID(id))
	return &SagaEntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SagaEntity.
func (c *SagaEntityClient) Delete() *SagaEntityDelete {
	mutation := newSagaEntityMutation(c.config, OpDelete)
	return &SagaEntityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SagaEntityClient) DeleteOne(se *SagaEntity) *SagaEntityDeleteOne {
	return c.DeleteOneID(se.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SagaEntityClient) DeleteOneID(id schema.SagaEntityID) *SagaEntityDeleteOne {
	builder := c.Delete().Where(sagaentity.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SagaEntityDeleteOne{builder}
}

// Query returns a query builder for SagaEntity.
func (c *SagaEntityClient) Query() *SagaEntityQuery {
	return &SagaEntityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSagaEntity},
		inters: c.Interceptors(),
	}
}

// Get returns a SagaEntity entity by its id.
func (c *SagaEntityClient) Get(ctx context.Context, id schema.SagaEntityID) (*SagaEntity, error) {
	return c.Query().Where(sagaentity.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SagaEntityClient) GetX(ctx context.Context, id schema.SagaEntityID) *SagaEntity {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryWorkflow queries the workflow edge of a SagaEntity.
func (c *SagaEntityClient) QueryWorkflow(se *SagaEntity) *WorkflowEntityQuery {
	query := (&WorkflowEntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := se.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sagaentity.Table, sagaentity.FieldID, id),
			sqlgraph.To(workflowentity.Table, workflowentity.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, sagaentity.WorkflowTable, sagaentity.WorkflowColumn),
		)
		fromV = sqlgraph.Neighbors(se.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySagaData queries the saga_data edge of a SagaEntity.
func (c *SagaEntityClient) QuerySagaData(se *SagaEntity) *SagaDataQuery {
	query := (&SagaDataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := se.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sagaentity.Table, sagaentity.FieldID, id),
			sqlgraph.To(sagadata.Table, sagadata.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, sagaentity.SagaDataTable, sagaentity.SagaDataColumn),
		)
		fromV = sqlgraph.Neighbors(se.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExecutions queries the executions edge of a SagaEntity.
func (c *SagaEntityClient) QueryExecutions(se *SagaEntity) *SagaExecutionQuery {
	query := (&SagaExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := se.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sagaentity.Table, sagaentity.FieldID, id),
			sqlgraph.To(sagaexecution.Table, sagaexecution.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, sagaentity.ExecutionsTable, sagaentity.ExecutionsColumn),
		)
		fromV = sqlgraph.Neighbors(se.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryValues queries the values edge of a SagaEntity.
func (c *SagaEntityClient) QueryValues(se *SagaEntity) *SagaValueQuery {
	query := (&SagaValueClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := se.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sagaentity.Table, sagaentity.FieldID, id),
			sqlgraph.To(sagavalue.Table, sagavalue.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, sagaentity.ValuesTable, sagaentity.ValuesColumn),
		)
		fromV = sqlgraph.Neighbors(se.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SagaEntityClient) Hooks() []Hook {
	return c.hooks.SagaEntity
}

// Interceptors returns the client interceptors.
func (c *SagaEntityClient) Interceptors() []Interceptor {
	return c.inters.SagaEntity
}

func (c *SagaEntityClient) mutate(ctx context.Context, m *SagaEntityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SagaEntityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SagaEntityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SagaEntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SagaEntityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SagaEntity mutation op: %q", m.Op())
	}
}

// SagaExecutionClient is a client for the SagaExecution schema.
type SagaExecutionClient struct {
	config
}

// NewSagaExecutionClient returns a client for the SagaExecution from the given config.
func NewSagaExecutionClient(c config) *SagaExecutionClient {
	return &SagaExecutionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sagaexecution.Hooks(f(g(h())))`.
func (c *SagaExecutionClient) Use(hooks ...Hook) {
	c.hooks.SagaExecution = append(c.hooks.SagaExecution, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sagaexecution.Intercept(f(g(h())))`.
func (c *SagaExecutionClient) Intercept(interceptors ...Interceptor) {
	c.inters.SagaExecution = append(c.inters.SagaExecution, interceptors...)
}

// Create returns a builder for creating a SagaExecution entity.
func (c *SagaExecutionClient) Create() *SagaExecutionCreate {
	mutation := newSagaExecutionMutation(c.config, OpCreate)
	return &SagaExecutionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SagaExecution entities.
func (c *SagaExecutionClient) CreateBulk(builders ...*SagaExecutionCreate) *SagaExecutionCreateBulk {
	return &SagaExecutionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SagaExecutionClient) MapCreateBulk(slice any, setFunc func(*SagaExecutionCreate, int)) *SagaExecutionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SagaExecutionCreateBulk{err: fmt.Errorf("calling to SagaExecutionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SagaExecutionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SagaExecutionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SagaExecution.
func (c *SagaExecutionClient) Update() *SagaExecutionUpdate {
	mutation := newSagaExecutionMutation(c.config, OpUpdate)
	return &SagaExecutionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SagaExecutionClient) UpdateOne(se *SagaExecution) *SagaExecutionUpdateOne {
	mutation := newSagaExecutionMutation(c.config, OpUpdateOne, withSagaExecution(se))
	return &SagaExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SagaExecutionClient) UpdateOneID(id schema.SagaExecutionID) *SagaExecutionUpdateOne {
	mutation := newSagaExecutionMutation(c.config, OpUpdateOne, withSagaExecutionID(id))
	return &SagaExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SagaExecution.
func (c *SagaExecutionClient) Delete() *SagaExecutionDelete {
	mutation := newSagaExecutionMutation(c.config, OpDelete)
	return &SagaExecutionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SagaExecutionClient) DeleteOne(se *SagaExecution) *SagaExecutionDeleteOne {
	return c.DeleteOneID(se.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SagaExecutionClient) DeleteOneID(id schema.SagaExecutionID) *SagaExecutionDeleteOne {
	builder := c.Delete().Where(sagaexecution.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SagaExecutionDeleteOne{builder}
}

// Query returns a query builder for SagaExecution.
func (c *SagaExecutionClient) Query() *SagaExecutionQuery {
	return &SagaExecutionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSagaExecution},
		inters: c.Interceptors(),
	}
}

// Get returns a SagaExecution entity by its id.
func (c *SagaExecutionClient) Get(ctx context.Context, id schema.SagaExecutionID) (*SagaExecution, error) {
	return c.Query().Where(sagaexecution.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SagaExecutionClient) GetX(ctx context.Context, id schema.SagaExecutionID) *SagaExecution {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySaga queries the saga edge of a SagaExecution.
func (c *SagaExecutionClient) QuerySaga(se *SagaExecution) *SagaEntityQuery {
	query := (&SagaEntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := se.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sagaexecution.Table, sagaexecution.FieldID, id),
			sqlgraph.To(sagaentity.Table, sagaentity.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, sagaexecution.SagaTable, sagaexecution.SagaColumn),
		)
		fromV = sqlgraph.Neighbors(se.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExecutionData queries the execution_data edge of a SagaExecution.
func (c *SagaExecutionClient) QueryExecutionData(se *SagaExecution) *SagaExecutionDataQuery {
	query := (&SagaExecutionDataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := se.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sagaexecution.Table, sagaexecution.FieldID, id),
			sqlgraph.To(sagaexecutiondata.Table, sagaexecutiondata.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, sagaexecution.ExecutionDataTable, sagaexecution.ExecutionDataColumn),
		)
		fromV = sqlgraph.Neighbors(se.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryValues queries the values edge of a SagaExecution.
func (c *SagaExecutionClient) QueryValues(se *SagaExecution) *SagaValueQuery {
	query := (&SagaValueClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := se.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sagaexecution.Table, sagaexecution.FieldID, id),
			sqlgraph.To(sagavalue.Table, sagavalue.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, sagaexecution.ValuesTable, sagaexecution.ValuesColumn),
		)
		fromV = sqlgraph.Neighbors(se.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SagaExecutionClient) Hooks() []Hook {
	return c.hooks.SagaExecution
}

// Interceptors returns the client interceptors.
func (c *SagaExecutionClient) Interceptors() []Interceptor {
	return c.inters.SagaExecution
}

func (c *SagaExecutionClient) mutate(ctx context.Context, m *SagaExecutionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SagaExecutionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SagaExecutionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SagaExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SagaExecutionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SagaExecution mutation op: %q", m.Op())
	}
}

// SagaExecutionDataClient is a client for the SagaExecutionData schema.
type SagaExecutionDataClient struct {
	config
}

// NewSagaExecutionDataClient returns a client for the SagaExecutionData from the given config.
func NewSagaExecutionDataClient(c config) *SagaExecutionDataClient {
	return &SagaExecutionDataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sagaexecutiondata.Hooks(f(g(h())))`.
func (c *SagaExecutionDataClient) Use(hooks ...Hook) {
	c.hooks.SagaExecutionData = append(c.hooks.SagaExecutionData, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sagaexecutiondata.Intercept(f(g(h())))`.
func (c *SagaExecutionDataClient) Intercept(interceptors ...Interceptor) {
	c.inters.SagaExecutionData = append(c.inters.SagaExecutionData, interceptors...)
}

// Create returns a builder for creating a SagaExecutionData entity.
func (c *SagaExecutionDataClient) Create() *SagaExecutionDataCreate {
	mutation := newSagaExecutionDataMutation(c.config, OpCreate)
	return &SagaExecutionDataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SagaExecutionData entities.
func (c *SagaExecutionDataClient) CreateBulk(builders ...*SagaExecutionDataCreate) *SagaExecutionDataCreateBulk {
	return &SagaExecutionDataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SagaExecutionDataClient) MapCreateBulk(slice any, setFunc func(*SagaExecutionDataCreate, int)) *SagaExecutionDataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SagaExecutionDataCreateBulk{err: fmt.Errorf("calling to SagaExecutionDataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SagaExecutionDataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SagaExecutionDataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SagaExecutionData.
func (c *SagaExecutionDataClient) Update() *SagaExecutionDataUpdate {
	mutation := newSagaExecutionDataMutation(c.config, OpUpdate)
	return &SagaExecutionDataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SagaExecutionDataClient) UpdateOne(sed *SagaExecutionData) *SagaExecutionDataUpdateOne {
	mutation := newSagaExecutionDataMutation(c.config, OpUpdateOne, withSagaExecutionData(sed))
	return &SagaExecutionDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SagaExecutionDataClient) UpdateOneID(id schema.SagaExecutionDataID) *SagaExecutionDataUpdateOne {
	mutation := newSagaExecutionDataMutation(c.config, OpUpdateOne, withSagaExecutionDataID(id))
	return &SagaExecutionDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SagaExecutionData.
func (c *SagaExecutionDataClient) Delete() *SagaExecutionDataDelete {
	mutation := newSagaExecutionDataMutation(c.config, OpDelete)
	return &SagaExecutionDataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SagaExecutionDataClient) DeleteOne(sed *SagaExecutionData) *SagaExecutionDataDeleteOne {
	return c.DeleteOneID(sed.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SagaExecutionDataClient) DeleteOneID(id schema.SagaExecutionDataID) *SagaExecutionDataDeleteOne {
	builder := c.Delete().Where(sagaexecutiondata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SagaExecutionDataDeleteOne{builder}
}

// Query returns a query builder for SagaExecutionData.
func (c *SagaExecutionDataClient) Query() *SagaExecutionDataQuery {
	return &SagaExecutionDataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSagaExecutionData},
		inters: c.Interceptors(),
	}
}

// Get returns a SagaExecutionData entity by its id.
func (c *SagaExecutionDataClient) Get(ctx context.Context, id schema.SagaExecutionDataID) (*SagaExecutionData, error) {
	return c.Query().Where(sagaexecutiondata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SagaExecutionDataClient) GetX(ctx context.Context, id schema.SagaExecutionDataID) *SagaExecutionData {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryExecution queries the execution edge of a SagaExecutionData.
func (c *SagaExecutionDataClient) QueryExecution(sed *SagaExecutionData) *SagaExecutionQuery {
	query := (&SagaExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sed.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sagaexecutiondata.Table, sagaexecutiondata.FieldID, id),
			sqlgraph.To(sagaexecution.Table, sagaexecution.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, sagaexecutiondata.ExecutionTable, sagaexecutiondata.ExecutionColumn),
		)
		fromV = sqlgraph.Neighbors(sed.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryValues queries the values edge of a SagaExecutionData.
func (c *SagaExecutionDataClient) QueryValues(sed *SagaExecutionData) *SagaValueQuery {
	query := (&SagaValueClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sed.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sagaexecutiondata.Table, sagaexecutiondata.FieldID, id),
			sqlgraph.To(sagavalue.Table, sagavalue.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, sagaexecutiondata.ValuesTable, sagaexecutiondata.ValuesColumn),
		)
		fromV = sqlgraph.Neighbors(sed.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SagaExecutionDataClient) Hooks() []Hook {
	return c.hooks.SagaExecutionData
}

// Interceptors returns the client interceptors.
func (c *SagaExecutionDataClient) Interceptors() []Interceptor {
	return c.inters.SagaExecutionData
}

func (c *SagaExecutionDataClient) mutate(ctx context.Context, m *SagaExecutionDataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SagaExecutionDataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SagaExecutionDataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SagaExecutionDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SagaExecutionDataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SagaExecutionData mutation op: %q", m.Op())
	}
}

// SagaValueClient is a client for the SagaValue schema.
type SagaValueClient struct {
	config
}

// NewSagaValueClient returns a client for the SagaValue from the given config.
func NewSagaValueClient(c config) *SagaValueClient {
	return &SagaValueClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sagavalue.Hooks(f(g(h())))`.
func (c *SagaValueClient) Use(hooks ...Hook) {
	c.hooks.SagaValue = append(c.hooks.SagaValue, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sagavalue.Intercept(f(g(h())))`.
func (c *SagaValueClient) Intercept(interceptors ...Interceptor) {
	c.inters.SagaValue = append(c.inters.SagaValue, interceptors...)
}

// Create returns a builder for creating a SagaValue entity.
func (c *SagaValueClient) Create() *SagaValueCreate {
	mutation := newSagaValueMutation(c.config, OpCreate)
	return &SagaValueCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SagaValue entities.
func (c *SagaValueClient) CreateBulk(builders ...*SagaValueCreate) *SagaValueCreateBulk {
	return &SagaValueCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SagaValueClient) MapCreateBulk(slice any, setFunc func(*SagaValueCreate, int)) *SagaValueCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SagaValueCreateBulk{err: fmt.Errorf("calling to SagaValueClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SagaValueCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SagaValueCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SagaValue.
func (c *SagaValueClient) Update() *SagaValueUpdate {
	mutation := newSagaValueMutation(c.config, OpUpdate)
	return &SagaValueUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SagaValueClient) UpdateOne(sv *SagaValue) *SagaValueUpdateOne {
	mutation := newSagaValueMutation(c.config, OpUpdateOne, withSagaValue(sv))
	return &SagaValueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SagaValueClient) UpdateOneID(id schema.SagaValueID) *SagaValueUpdateOne {
	mutation := newSagaValueMutation(c.config, OpUpdateOne, withSagaValueID(id))
	return &SagaValueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SagaValue.
func (c *SagaValueClient) Delete() *SagaValueDelete {
	mutation := newSagaValueMutation(c.config, OpDelete)
	return &SagaValueDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SagaValueClient) DeleteOne(sv *SagaValue) *SagaValueDeleteOne {
	return c.DeleteOneID(sv.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SagaValueClient) DeleteOneID(id schema.SagaValueID) *SagaValueDeleteOne {
	builder := c.Delete().Where(sagavalue.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SagaValueDeleteOne{builder}
}

// Query returns a query builder for SagaValue.
func (c *SagaValueClient) Query() *SagaValueQuery {
	return &SagaValueQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSagaValue},
		inters: c.Interceptors(),
	}
}

// Get returns a SagaValue entity by its id.
func (c *SagaValueClient) Get(ctx context.Context, id schema.SagaValueID) (*SagaValue, error) {
	return c.Query().Where(sagavalue.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SagaValueClient) GetX(ctx context.Context, id schema.SagaValueID) *SagaValue {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryExecution queries the execution edge of a SagaValue.
func (c *SagaValueClient) QueryExecution(sv *SagaValue) *SagaExecutionQuery {
	query := (&SagaExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sagavalue.Table, sagavalue.FieldID, id),
			sqlgraph.To(sagaexecution.Table, sagaexecution.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, sagavalue.ExecutionTable, sagavalue.ExecutionColumn),
		)
		fromV = sqlgraph.Neighbors(sv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySagaData queries the saga_data edge of a SagaValue.
func (c *SagaValueClient) QuerySagaData(sv *SagaValue) *SagaDataQuery {
	query := (&SagaDataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sagavalue.Table, sagavalue.FieldID, id),
			sqlgraph.To(sagadata.Table, sagadata.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, sagavalue.SagaDataTable, sagavalue.SagaDataColumn),
		)
		fromV = sqlgraph.Neighbors(sv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExecutionData queries the execution_data edge of a SagaValue.
func (c *SagaValueClient) QueryExecutionData(sv *SagaValue) *SagaExecutionDataQuery {
	query := (&SagaExecutionDataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sagavalue.Table, sagavalue.FieldID, id),
			sqlgraph.To(sagaexecutiondata.Table, sagaexecutiondata.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, sagavalue.ExecutionDataTable, sagavalue.ExecutionDataColumn),
		)
		fromV = sqlgraph.Neighbors(sv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SagaValueClient) Hooks() []Hook {
	return c.hooks.SagaValue
}

// Interceptors returns the client interceptors.
func (c *SagaValueClient) Interceptors() []Interceptor {
	return c.inters.SagaValue
}

func (c *SagaValueClient) mutate(ctx context.Context, m *SagaValueMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SagaValueCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SagaValueUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SagaValueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SagaValueDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SagaValue mutation op: %q", m.Op())
	}
}

// SideEffectDataClient is a client for the SideEffectData schema.
type SideEffectDataClient struct {
	config
}

// NewSideEffectDataClient returns a client for the SideEffectData from the given config.
func NewSideEffectDataClient(c config) *SideEffectDataClient {
	return &SideEffectDataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sideeffectdata.Hooks(f(g(h())))`.
func (c *SideEffectDataClient) Use(hooks ...Hook) {
	c.hooks.SideEffectData = append(c.hooks.SideEffectData, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sideeffectdata.Intercept(f(g(h())))`.
func (c *SideEffectDataClient) Intercept(interceptors ...Interceptor) {
	c.inters.SideEffectData = append(c.inters.SideEffectData, interceptors...)
}

// Create returns a builder for creating a SideEffectData entity.
func (c *SideEffectDataClient) Create() *SideEffectDataCreate {
	mutation := newSideEffectDataMutation(c.config, OpCreate)
	return &SideEffectDataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SideEffectData entities.
func (c *SideEffectDataClient) CreateBulk(builders ...*SideEffectDataCreate) *SideEffectDataCreateBulk {
	return &SideEffectDataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SideEffectDataClient) MapCreateBulk(slice any, setFunc func(*SideEffectDataCreate, int)) *SideEffectDataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SideEffectDataCreateBulk{err: fmt.Errorf("calling to SideEffectDataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SideEffectDataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SideEffectDataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SideEffectData.
func (c *SideEffectDataClient) Update() *SideEffectDataUpdate {
	mutation := newSideEffectDataMutation(c.config, OpUpdate)
	return &SideEffectDataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SideEffectDataClient) UpdateOne(sed *SideEffectData) *SideEffectDataUpdateOne {
	mutation := newSideEffectDataMutation(c.config, OpUpdateOne, withSideEffectData(sed))
	return &SideEffectDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SideEffectDataClient) UpdateOneID(id schema.SideEffectDataID) *SideEffectDataUpdateOne {
	mutation := newSideEffectDataMutation(c.config, OpUpdateOne, withSideEffectDataID(id))
	return &SideEffectDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SideEffectData.
func (c *SideEffectDataClient) Delete() *SideEffectDataDelete {
	mutation := newSideEffectDataMutation(c.config, OpDelete)
	return &SideEffectDataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SideEffectDataClient) DeleteOne(sed *SideEffectData) *SideEffectDataDeleteOne {
	return c.DeleteOneID(sed.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SideEffectDataClient) DeleteOneID(id schema.SideEffectDataID) *SideEffectDataDeleteOne {
	builder := c.Delete().Where(sideeffectdata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SideEffectDataDeleteOne{builder}
}

// Query returns a query builder for SideEffectData.
func (c *SideEffectDataClient) Query() *SideEffectDataQuery {
	return &SideEffectDataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSideEffectData},
		inters: c.Interceptors(),
	}
}

// Get returns a SideEffectData entity by its id.
func (c *SideEffectDataClient) Get(ctx context.Context, id schema.SideEffectDataID) (*SideEffectData, error) {
	return c.Query().Where(sideeffectdata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SideEffectDataClient) GetX(ctx context.Context, id schema.SideEffectDataID) *SideEffectData {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySideEffect queries the side_effect edge of a SideEffectData.
func (c *SideEffectDataClient) QuerySideEffect(sed *SideEffectData) *SideEffectEntityQuery {
	query := (&SideEffectEntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sed.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sideeffectdata.Table, sideeffectdata.FieldID, id),
			sqlgraph.To(sideeffectentity.Table, sideeffectentity.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, sideeffectdata.SideEffectTable, sideeffectdata.SideEffectColumn),
		)
		fromV = sqlgraph.Neighbors(sed.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SideEffectDataClient) Hooks() []Hook {
	return c.hooks.SideEffectData
}

// Interceptors returns the client interceptors.
func (c *SideEffectDataClient) Interceptors() []Interceptor {
	return c.inters.SideEffectData
}

func (c *SideEffectDataClient) mutate(ctx context.Context, m *SideEffectDataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SideEffectDataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SideEffectDataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SideEffectDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SideEffectDataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SideEffectData mutation op: %q", m.Op())
	}
}

// SideEffectEntityClient is a client for the SideEffectEntity schema.
type SideEffectEntityClient struct {
	config
}

// NewSideEffectEntityClient returns a client for the SideEffectEntity from the given config.
func NewSideEffectEntityClient(c config) *SideEffectEntityClient {
	return &SideEffectEntityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sideeffectentity.Hooks(f(g(h())))`.
func (c *SideEffectEntityClient) Use(hooks ...Hook) {
	c.hooks.SideEffectEntity = append(c.hooks.SideEffectEntity, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sideeffectentity.Intercept(f(g(h())))`.
func (c *SideEffectEntityClient) Intercept(interceptors ...Interceptor) {
	c.inters.SideEffectEntity = append(c.inters.SideEffectEntity, interceptors...)
}

// Create returns a builder for creating a SideEffectEntity entity.
func (c *SideEffectEntityClient) Create() *SideEffectEntityCreate {
	mutation := newSideEffectEntityMutation(c.config, OpCreate)
	return &SideEffectEntityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SideEffectEntity entities.
func (c *SideEffectEntityClient) CreateBulk(builders ...*SideEffectEntityCreate) *SideEffectEntityCreateBulk {
	return &SideEffectEntityCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SideEffectEntityClient) MapCreateBulk(slice any, setFunc func(*SideEffectEntityCreate, int)) *SideEffectEntityCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SideEffectEntityCreateBulk{err: fmt.Errorf("calling to SideEffectEntityClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SideEffectEntityCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SideEffectEntityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SideEffectEntity.
func (c *SideEffectEntityClient) Update() *SideEffectEntityUpdate {
	mutation := newSideEffectEntityMutation(c.config, OpUpdate)
	return &SideEffectEntityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SideEffectEntityClient) UpdateOne(see *SideEffectEntity) *SideEffectEntityUpdateOne {
	mutation := newSideEffectEntityMutation(c.config, OpUpdateOne, withSideEffectEntity(see))
	return &SideEffectEntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SideEffectEntityClient) UpdateOneID(id schema.SideEffectEntityID) *SideEffectEntityUpdateOne {
	mutation := newSideEffectEntityMutation(c.config, OpUpdateOne, withSideEffectEntityID(id))
	return &SideEffectEntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SideEffectEntity.
func (c *SideEffectEntityClient) Delete() *SideEffectEntityDelete {
	mutation := newSideEffectEntityMutation(c.config, OpDelete)
	return &SideEffectEntityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SideEffectEntityClient) DeleteOne(see *SideEffectEntity) *SideEffectEntityDeleteOne {
	return c.DeleteOneID(see.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SideEffectEntityClient) DeleteOneID(id schema.SideEffectEntityID) *SideEffectEntityDeleteOne {
	builder := c.Delete().Where(sideeffectentity.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SideEffectEntityDeleteOne{builder}
}

// Query returns a query builder for SideEffectEntity.
func (c *SideEffectEntityClient) Query() *SideEffectEntityQuery {
	return &SideEffectEntityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSideEffectEntity},
		inters: c.Interceptors(),
	}
}

// Get returns a SideEffectEntity entity by its id.
func (c *SideEffectEntityClient) Get(ctx context.Context, id schema.SideEffectEntityID) (*SideEffectEntity, error) {
	return c.Query().Where(sideeffectentity.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SideEffectEntityClient) GetX(ctx context.Context, id schema.SideEffectEntityID) *SideEffectEntity {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryWorkflow queries the workflow edge of a SideEffectEntity.
func (c *SideEffectEntityClient) QueryWorkflow(see *SideEffectEntity) *WorkflowEntityQuery {
	query := (&WorkflowEntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := see.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sideeffectentity.Table, sideeffectentity.FieldID, id),
			sqlgraph.To(workflowentity.Table, workflowentity.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, sideeffectentity.WorkflowTable, sideeffectentity.WorkflowColumn),
		)
		fromV = sqlgraph.Neighbors(see.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySideEffectData queries the side_effect_data edge of a SideEffectEntity.
func (c *SideEffectEntityClient) QuerySideEffectData(see *SideEffectEntity) *SideEffectDataQuery {
	query := (&SideEffectDataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := see.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sideeffectentity.Table, sideeffectentity.FieldID, id),
			sqlgraph.To(sideeffectdata.Table, sideeffectdata.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, sideeffectentity.SideEffectDataTable, sideeffectentity.SideEffectDataColumn),
		)
		fromV = sqlgraph.Neighbors(see.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExecutions queries the executions edge of a SideEffectEntity.
func (c *SideEffectEntityClient) QueryExecutions(see *SideEffectEntity) *SideEffectExecutionQuery {
	query := (&SideEffectExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := see.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sideeffectentity.Table, sideeffectentity.FieldID, id),
			sqlgraph.To(sideeffectexecution.Table, sideeffectexecution.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, sideeffectentity.ExecutionsTable, sideeffectentity.ExecutionsColumn),
		)
		fromV = sqlgraph.Neighbors(see.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SideEffectEntityClient) Hooks() []Hook {
	return c.hooks.SideEffectEntity
}

// Interceptors returns the client interceptors.
func (c *SideEffectEntityClient) Interceptors() []Interceptor {
	return c.inters.SideEffectEntity
}

func (c *SideEffectEntityClient) mutate(ctx context.Context, m *SideEffectEntityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SideEffectEntityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SideEffectEntityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SideEffectEntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SideEffectEntityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SideEffectEntity mutation op: %q", m.Op())
	}
}

// SideEffectExecutionClient is a client for the SideEffectExecution schema.
type SideEffectExecutionClient struct {
	config
}

// NewSideEffectExecutionClient returns a client for the SideEffectExecution from the given config.
func NewSideEffectExecutionClient(c config) *SideEffectExecutionClient {
	return &SideEffectExecutionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sideeffectexecution.Hooks(f(g(h())))`.
func (c *SideEffectExecutionClient) Use(hooks ...Hook) {
	c.hooks.SideEffectExecution = append(c.hooks.SideEffectExecution, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sideeffectexecution.Intercept(f(g(h())))`.
func (c *SideEffectExecutionClient) Intercept(interceptors ...Interceptor) {
	c.inters.SideEffectExecution = append(c.inters.SideEffectExecution, interceptors...)
}

// Create returns a builder for creating a SideEffectExecution entity.
func (c *SideEffectExecutionClient) Create() *SideEffectExecutionCreate {
	mutation := newSideEffectExecutionMutation(c.config, OpCreate)
	return &SideEffectExecutionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SideEffectExecution entities.
func (c *SideEffectExecutionClient) CreateBulk(builders ...*SideEffectExecutionCreate) *SideEffectExecutionCreateBulk {
	return &SideEffectExecutionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SideEffectExecutionClient) MapCreateBulk(slice any, setFunc func(*SideEffectExecutionCreate, int)) *SideEffectExecutionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SideEffectExecutionCreateBulk{err: fmt.Errorf("calling to SideEffectExecutionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SideEffectExecutionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SideEffectExecutionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SideEffectExecution.
func (c *SideEffectExecutionClient) Update() *SideEffectExecutionUpdate {
	mutation := newSideEffectExecutionMutation(c.config, OpUpdate)
	return &SideEffectExecutionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SideEffectExecutionClient) UpdateOne(see *SideEffectExecution) *SideEffectExecutionUpdateOne {
	mutation := newSideEffectExecutionMutation(c.config, OpUpdateOne, withSideEffectExecution(see))
	return &SideEffectExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SideEffectExecutionClient) UpdateOneID(id schema.SideEffectExecutionID) *SideEffectExecutionUpdateOne {
	mutation := newSideEffectExecutionMutation(c.config, OpUpdateOne, withSideEffectExecutionID(id))
	return &SideEffectExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SideEffectExecution.
func (c *SideEffectExecutionClient) Delete() *SideEffectExecutionDelete {
	mutation := newSideEffectExecutionMutation(c.config, OpDelete)
	return &SideEffectExecutionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SideEffectExecutionClient) DeleteOne(see *SideEffectExecution) *SideEffectExecutionDeleteOne {
	return c.DeleteOneID(see.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SideEffectExecutionClient) DeleteOneID(id schema.SideEffectExecutionID) *SideEffectExecutionDeleteOne {
	builder := c.Delete().Where(sideeffectexecution.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SideEffectExecutionDeleteOne{builder}
}

// Query returns a query builder for SideEffectExecution.
func (c *SideEffectExecutionClient) Query() *SideEffectExecutionQuery {
	return &SideEffectExecutionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSideEffectExecution},
		inters: c.Interceptors(),
	}
}

// Get returns a SideEffectExecution entity by its id.
func (c *SideEffectExecutionClient) Get(ctx context.Context, id schema.SideEffectExecutionID) (*SideEffectExecution, error) {
	return c.Query().Where(sideeffectexecution.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SideEffectExecutionClient) GetX(ctx context.Context, id schema.SideEffectExecutionID) *SideEffectExecution {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySideEffect queries the side_effect edge of a SideEffectExecution.
func (c *SideEffectExecutionClient) QuerySideEffect(see *SideEffectExecution) *SideEffectEntityQuery {
	query := (&SideEffectEntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := see.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sideeffectexecution.Table, sideeffectexecution.FieldID, id),
			sqlgraph.To(sideeffectentity.Table, sideeffectentity.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, sideeffectexecution.SideEffectTable, sideeffectexecution.SideEffectColumn),
		)
		fromV = sqlgraph.Neighbors(see.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExecutionData queries the execution_data edge of a SideEffectExecution.
func (c *SideEffectExecutionClient) QueryExecutionData(see *SideEffectExecution) *SideEffectExecutionDataQuery {
	query := (&SideEffectExecutionDataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := see.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sideeffectexecution.Table, sideeffectexecution.FieldID, id),
			sqlgraph.To(sideeffectexecutiondata.Table, sideeffectexecutiondata.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, sideeffectexecution.ExecutionDataTable, sideeffectexecution.ExecutionDataColumn),
		)
		fromV = sqlgraph.Neighbors(see.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SideEffectExecutionClient) Hooks() []Hook {
	return c.hooks.SideEffectExecution
}

// Interceptors returns the client interceptors.
func (c *SideEffectExecutionClient) Interceptors() []Interceptor {
	return c.inters.SideEffectExecution
}

func (c *SideEffectExecutionClient) mutate(ctx context.Context, m *SideEffectExecutionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SideEffectExecutionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SideEffectExecutionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SideEffectExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SideEffectExecutionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SideEffectExecution mutation op: %q", m.Op())
	}
}

// SideEffectExecutionDataClient is a client for the SideEffectExecutionData schema.
type SideEffectExecutionDataClient struct {
	config
}

// NewSideEffectExecutionDataClient returns a client for the SideEffectExecutionData from the given config.
func NewSideEffectExecutionDataClient(c config) *SideEffectExecutionDataClient {
	return &SideEffectExecutionDataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sideeffectexecutiondata.Hooks(f(g(h())))`.
func (c *SideEffectExecutionDataClient) Use(hooks ...Hook) {
	c.hooks.SideEffectExecutionData = append(c.hooks.SideEffectExecutionData, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sideeffectexecutiondata.Intercept(f(g(h())))`.
func (c *SideEffectExecutionDataClient) Intercept(interceptors ...Interceptor) {
	c.inters.SideEffectExecutionData = append(c.inters.SideEffectExecutionData, interceptors...)
}

// Create returns a builder for creating a SideEffectExecutionData entity.
func (c *SideEffectExecutionDataClient) Create() *SideEffectExecutionDataCreate {
	mutation := newSideEffectExecutionDataMutation(c.config, OpCreate)
	return &SideEffectExecutionDataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SideEffectExecutionData entities.
func (c *SideEffectExecutionDataClient) CreateBulk(builders ...*SideEffectExecutionDataCreate) *SideEffectExecutionDataCreateBulk {
	return &SideEffectExecutionDataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SideEffectExecutionDataClient) MapCreateBulk(slice any, setFunc func(*SideEffectExecutionDataCreate, int)) *SideEffectExecutionDataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SideEffectExecutionDataCreateBulk{err: fmt.Errorf("calling to SideEffectExecutionDataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SideEffectExecutionDataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SideEffectExecutionDataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SideEffectExecutionData.
func (c *SideEffectExecutionDataClient) Update() *SideEffectExecutionDataUpdate {
	mutation := newSideEffectExecutionDataMutation(c.config, OpUpdate)
	return &SideEffectExecutionDataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SideEffectExecutionDataClient) UpdateOne(seed *SideEffectExecutionData) *SideEffectExecutionDataUpdateOne {
	mutation := newSideEffectExecutionDataMutation(c.config, OpUpdateOne, withSideEffectExecutionData(seed))
	return &SideEffectExecutionDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SideEffectExecutionDataClient) UpdateOneID(id schema.SideEffectExecutionDataID) *SideEffectExecutionDataUpdateOne {
	mutation := newSideEffectExecutionDataMutation(c.config, OpUpdateOne, withSideEffectExecutionDataID(id))
	return &SideEffectExecutionDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SideEffectExecutionData.
func (c *SideEffectExecutionDataClient) Delete() *SideEffectExecutionDataDelete {
	mutation := newSideEffectExecutionDataMutation(c.config, OpDelete)
	return &SideEffectExecutionDataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SideEffectExecutionDataClient) DeleteOne(seed *SideEffectExecutionData) *SideEffectExecutionDataDeleteOne {
	return c.DeleteOneID(seed.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SideEffectExecutionDataClient) DeleteOneID(id schema.SideEffectExecutionDataID) *SideEffectExecutionDataDeleteOne {
	builder := c.Delete().Where(sideeffectexecutiondata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SideEffectExecutionDataDeleteOne{builder}
}

// Query returns a query builder for SideEffectExecutionData.
func (c *SideEffectExecutionDataClient) Query() *SideEffectExecutionDataQuery {
	return &SideEffectExecutionDataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSideEffectExecutionData},
		inters: c.Interceptors(),
	}
}

// Get returns a SideEffectExecutionData entity by its id.
func (c *SideEffectExecutionDataClient) Get(ctx context.Context, id schema.SideEffectExecutionDataID) (*SideEffectExecutionData, error) {
	return c.Query().Where(sideeffectexecutiondata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SideEffectExecutionDataClient) GetX(ctx context.Context, id schema.SideEffectExecutionDataID) *SideEffectExecutionData {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryExecution queries the execution edge of a SideEffectExecutionData.
func (c *SideEffectExecutionDataClient) QueryExecution(seed *SideEffectExecutionData) *SideEffectExecutionQuery {
	query := (&SideEffectExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := seed.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sideeffectexecutiondata.Table, sideeffectexecutiondata.FieldID, id),
			sqlgraph.To(sideeffectexecution.Table, sideeffectexecution.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, sideeffectexecutiondata.ExecutionTable, sideeffectexecutiondata.ExecutionColumn),
		)
		fromV = sqlgraph.Neighbors(seed.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SideEffectExecutionDataClient) Hooks() []Hook {
	return c.hooks.SideEffectExecutionData
}

// Interceptors returns the client interceptors.
func (c *SideEffectExecutionDataClient) Interceptors() []Interceptor {
	return c.inters.SideEffectExecutionData
}

func (c *SideEffectExecutionDataClient) mutate(ctx context.Context, m *SideEffectExecutionDataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SideEffectExecutionDataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SideEffectExecutionDataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SideEffectExecutionDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SideEffectExecutionDataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SideEffectExecutionData mutation op: %q", m.Op())
	}
}

// SignalDataClient is a client for the SignalData schema.
type SignalDataClient struct {
	config
}

// NewSignalDataClient returns a client for the SignalData from the given config.
func NewSignalDataClient(c config) *SignalDataClient {
	return &SignalDataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `signaldata.Hooks(f(g(h())))`.
func (c *SignalDataClient) Use(hooks ...Hook) {
	c.hooks.SignalData = append(c.hooks.SignalData, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `signaldata.Intercept(f(g(h())))`.
func (c *SignalDataClient) Intercept(interceptors ...Interceptor) {
	c.inters.SignalData = append(c.inters.SignalData, interceptors...)
}

// Create returns a builder for creating a SignalData entity.
func (c *SignalDataClient) Create() *SignalDataCreate {
	mutation := newSignalDataMutation(c.config, OpCreate)
	return &SignalDataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SignalData entities.
func (c *SignalDataClient) CreateBulk(builders ...*SignalDataCreate) *SignalDataCreateBulk {
	return &SignalDataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SignalDataClient) MapCreateBulk(slice any, setFunc func(*SignalDataCreate, int)) *SignalDataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SignalDataCreateBulk{err: fmt.Errorf("calling to SignalDataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SignalDataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SignalDataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SignalData.
func (c *SignalDataClient) Update() *SignalDataUpdate {
	mutation := newSignalDataMutation(c.config, OpUpdate)
	return &SignalDataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SignalDataClient) UpdateOne(sd *SignalData) *SignalDataUpdateOne {
	mutation := newSignalDataMutation(c.config, OpUpdateOne, withSignalData(sd))
	return &SignalDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SignalDataClient) UpdateOneID(id schema.SignalDataID) *SignalDataUpdateOne {
	mutation := newSignalDataMutation(c.config, OpUpdateOne, withSignalDataID(id))
	return &SignalDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SignalData.
func (c *SignalDataClient) Delete() *SignalDataDelete {
	mutation := newSignalDataMutation(c.config, OpDelete)
	return &SignalDataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SignalDataClient) DeleteOne(sd *SignalData) *SignalDataDeleteOne {
	return c.DeleteOneID(sd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SignalDataClient) DeleteOneID(id schema.SignalDataID) *SignalDataDeleteOne {
	builder := c.Delete().Where(signaldata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SignalDataDeleteOne{builder}
}

// Query returns a query builder for SignalData.
func (c *SignalDataClient) Query() *SignalDataQuery {
	return &SignalDataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSignalData},
		inters: c.Interceptors(),
	}
}

// Get returns a SignalData entity by its id.
func (c *SignalDataClient) Get(ctx context.Context, id schema.SignalDataID) (*SignalData, error) {
	return c.Query().Where(signaldata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SignalDataClient) GetX(ctx context.Context, id schema.SignalDataID) *SignalData {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySignal queries the signal edge of a SignalData.
func (c *SignalDataClient) QuerySignal(sd *SignalData) *SignalEntityQuery {
	query := (&SignalEntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(signaldata.Table, signaldata.FieldID, id),
			sqlgraph.To(signalentity.Table, signalentity.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, signaldata.SignalTable, signaldata.SignalColumn),
		)
		fromV = sqlgraph.Neighbors(sd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SignalDataClient) Hooks() []Hook {
	return c.hooks.SignalData
}

// Interceptors returns the client interceptors.
func (c *SignalDataClient) Interceptors() []Interceptor {
	return c.inters.SignalData
}

func (c *SignalDataClient) mutate(ctx context.Context, m *SignalDataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SignalDataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SignalDataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SignalDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SignalDataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SignalData mutation op: %q", m.Op())
	}
}

// SignalEntityClient is a client for the SignalEntity schema.
type SignalEntityClient struct {
	config
}

// NewSignalEntityClient returns a client for the SignalEntity from the given config.
func NewSignalEntityClient(c config) *SignalEntityClient {
	return &SignalEntityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `signalentity.Hooks(f(g(h())))`.
func (c *SignalEntityClient) Use(hooks ...Hook) {
	c.hooks.SignalEntity = append(c.hooks.SignalEntity, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `signalentity.Intercept(f(g(h())))`.
func (c *SignalEntityClient) Intercept(interceptors ...Interceptor) {
	c.inters.SignalEntity = append(c.inters.SignalEntity, interceptors...)
}

// Create returns a builder for creating a SignalEntity entity.
func (c *SignalEntityClient) Create() *SignalEntityCreate {
	mutation := newSignalEntityMutation(c.config, OpCreate)
	return &SignalEntityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SignalEntity entities.
func (c *SignalEntityClient) CreateBulk(builders ...*SignalEntityCreate) *SignalEntityCreateBulk {
	return &SignalEntityCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SignalEntityClient) MapCreateBulk(slice any, setFunc func(*SignalEntityCreate, int)) *SignalEntityCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SignalEntityCreateBulk{err: fmt.Errorf("calling to SignalEntityClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SignalEntityCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SignalEntityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SignalEntity.
func (c *SignalEntityClient) Update() *SignalEntityUpdate {
	mutation := newSignalEntityMutation(c.config, OpUpdate)
	return &SignalEntityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SignalEntityClient) UpdateOne(se *SignalEntity) *SignalEntityUpdateOne {
	mutation := newSignalEntityMutation(c.config, OpUpdateOne, withSignalEntity(se))
	return &SignalEntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SignalEntityClient) UpdateOneID(id schema.SignalEntityID) *SignalEntityUpdateOne {
	mutation := newSignalEntityMutation(c.config, OpUpdateOne, withSignalEntityID(id))
	return &SignalEntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SignalEntity.
func (c *SignalEntityClient) Delete() *SignalEntityDelete {
	mutation := newSignalEntityMutation(c.config, OpDelete)
	return &SignalEntityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SignalEntityClient) DeleteOne(se *SignalEntity) *SignalEntityDeleteOne {
	return c.DeleteOneID(se.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SignalEntityClient) DeleteOneID(id schema.SignalEntityID) *SignalEntityDeleteOne {
	builder := c.Delete().Where(signalentity.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SignalEntityDeleteOne{builder}
}

// Query returns a query builder for SignalEntity.
func (c *SignalEntityClient) Query() *SignalEntityQuery {
	return &SignalEntityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSignalEntity},
		inters: c.Interceptors(),
	}
}

// Get returns a SignalEntity entity by its id.
func (c *SignalEntityClient) Get(ctx context.Context, id schema.SignalEntityID) (*SignalEntity, error) {
	return c.Query().Where(signalentity.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SignalEntityClient) GetX(ctx context.Context, id schema.SignalEntityID) *SignalEntity {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySignalData queries the signal_data edge of a SignalEntity.
func (c *SignalEntityClient) QuerySignalData(se *SignalEntity) *SignalDataQuery {
	query := (&SignalDataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := se.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(signalentity.Table, signalentity.FieldID, id),
			sqlgraph.To(signaldata.Table, signaldata.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, signalentity.SignalDataTable, signalentity.SignalDataColumn),
		)
		fromV = sqlgraph.Neighbors(se.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExecutions queries the executions edge of a SignalEntity.
func (c *SignalEntityClient) QueryExecutions(se *SignalEntity) *SignalExecutionQuery {
	query := (&SignalExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := se.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(signalentity.Table, signalentity.FieldID, id),
			sqlgraph.To(signalexecution.Table, signalexecution.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, signalentity.ExecutionsTable, signalentity.ExecutionsColumn),
		)
		fromV = sqlgraph.Neighbors(se.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SignalEntityClient) Hooks() []Hook {
	return c.hooks.SignalEntity
}

// Interceptors returns the client interceptors.
func (c *SignalEntityClient) Interceptors() []Interceptor {
	return c.inters.SignalEntity
}

func (c *SignalEntityClient) mutate(ctx context.Context, m *SignalEntityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SignalEntityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SignalEntityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SignalEntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SignalEntityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SignalEntity mutation op: %q", m.Op())
	}
}

// SignalExecutionClient is a client for the SignalExecution schema.
type SignalExecutionClient struct {
	config
}

// NewSignalExecutionClient returns a client for the SignalExecution from the given config.
func NewSignalExecutionClient(c config) *SignalExecutionClient {
	return &SignalExecutionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `signalexecution.Hooks(f(g(h())))`.
func (c *SignalExecutionClient) Use(hooks ...Hook) {
	c.hooks.SignalExecution = append(c.hooks.SignalExecution, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `signalexecution.Intercept(f(g(h())))`.
func (c *SignalExecutionClient) Intercept(interceptors ...Interceptor) {
	c.inters.SignalExecution = append(c.inters.SignalExecution, interceptors...)
}

// Create returns a builder for creating a SignalExecution entity.
func (c *SignalExecutionClient) Create() *SignalExecutionCreate {
	mutation := newSignalExecutionMutation(c.config, OpCreate)
	return &SignalExecutionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SignalExecution entities.
func (c *SignalExecutionClient) CreateBulk(builders ...*SignalExecutionCreate) *SignalExecutionCreateBulk {
	return &SignalExecutionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SignalExecutionClient) MapCreateBulk(slice any, setFunc func(*SignalExecutionCreate, int)) *SignalExecutionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SignalExecutionCreateBulk{err: fmt.Errorf("calling to SignalExecutionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SignalExecutionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SignalExecutionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SignalExecution.
func (c *SignalExecutionClient) Update() *SignalExecutionUpdate {
	mutation := newSignalExecutionMutation(c.config, OpUpdate)
	return &SignalExecutionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SignalExecutionClient) UpdateOne(se *SignalExecution) *SignalExecutionUpdateOne {
	mutation := newSignalExecutionMutation(c.config, OpUpdateOne, withSignalExecution(se))
	return &SignalExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SignalExecutionClient) UpdateOneID(id schema.SignalExecutionID) *SignalExecutionUpdateOne {
	mutation := newSignalExecutionMutation(c.config, OpUpdateOne, withSignalExecutionID(id))
	return &SignalExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SignalExecution.
func (c *SignalExecutionClient) Delete() *SignalExecutionDelete {
	mutation := newSignalExecutionMutation(c.config, OpDelete)
	return &SignalExecutionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SignalExecutionClient) DeleteOne(se *SignalExecution) *SignalExecutionDeleteOne {
	return c.DeleteOneID(se.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SignalExecutionClient) DeleteOneID(id schema.SignalExecutionID) *SignalExecutionDeleteOne {
	builder := c.Delete().Where(signalexecution.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SignalExecutionDeleteOne{builder}
}

// Query returns a query builder for SignalExecution.
func (c *SignalExecutionClient) Query() *SignalExecutionQuery {
	return &SignalExecutionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSignalExecution},
		inters: c.Interceptors(),
	}
}

// Get returns a SignalExecution entity by its id.
func (c *SignalExecutionClient) Get(ctx context.Context, id schema.SignalExecutionID) (*SignalExecution, error) {
	return c.Query().Where(signalexecution.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SignalExecutionClient) GetX(ctx context.Context, id schema.SignalExecutionID) *SignalExecution {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySignal queries the signal edge of a SignalExecution.
func (c *SignalExecutionClient) QuerySignal(se *SignalExecution) *SignalEntityQuery {
	query := (&SignalEntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := se.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(signalexecution.Table, signalexecution.FieldID, id),
			sqlgraph.To(signalentity.Table, signalentity.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, signalexecution.SignalTable, signalexecution.SignalColumn),
		)
		fromV = sqlgraph.Neighbors(se.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExecutionData queries the execution_data edge of a SignalExecution.
func (c *SignalExecutionClient) QueryExecutionData(se *SignalExecution) *SignalExecutionDataQuery {
	query := (&SignalExecutionDataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := se.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(signalexecution.Table, signalexecution.FieldID, id),
			sqlgraph.To(signalexecutiondata.Table, signalexecutiondata.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, signalexecution.ExecutionDataTable, signalexecution.ExecutionDataColumn),
		)
		fromV = sqlgraph.Neighbors(se.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SignalExecutionClient) Hooks() []Hook {
	return c.hooks.SignalExecution
}

// Interceptors returns the client interceptors.
func (c *SignalExecutionClient) Interceptors() []Interceptor {
	return c.inters.SignalExecution
}

func (c *SignalExecutionClient) mutate(ctx context.Context, m *SignalExecutionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SignalExecutionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SignalExecutionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SignalExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SignalExecutionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SignalExecution mutation op: %q", m.Op())
	}
}

// SignalExecutionDataClient is a client for the SignalExecutionData schema.
type SignalExecutionDataClient struct {
	config
}

// NewSignalExecutionDataClient returns a client for the SignalExecutionData from the given config.
func NewSignalExecutionDataClient(c config) *SignalExecutionDataClient {
	return &SignalExecutionDataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `signalexecutiondata.Hooks(f(g(h())))`.
func (c *SignalExecutionDataClient) Use(hooks ...Hook) {
	c.hooks.SignalExecutionData = append(c.hooks.SignalExecutionData, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `signalexecutiondata.Intercept(f(g(h())))`.
func (c *SignalExecutionDataClient) Intercept(interceptors ...Interceptor) {
	c.inters.SignalExecutionData = append(c.inters.SignalExecutionData, interceptors...)
}

// Create returns a builder for creating a SignalExecutionData entity.
func (c *SignalExecutionDataClient) Create() *SignalExecutionDataCreate {
	mutation := newSignalExecutionDataMutation(c.config, OpCreate)
	return &SignalExecutionDataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SignalExecutionData entities.
func (c *SignalExecutionDataClient) CreateBulk(builders ...*SignalExecutionDataCreate) *SignalExecutionDataCreateBulk {
	return &SignalExecutionDataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SignalExecutionDataClient) MapCreateBulk(slice any, setFunc func(*SignalExecutionDataCreate, int)) *SignalExecutionDataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SignalExecutionDataCreateBulk{err: fmt.Errorf("calling to SignalExecutionDataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SignalExecutionDataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SignalExecutionDataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SignalExecutionData.
func (c *SignalExecutionDataClient) Update() *SignalExecutionDataUpdate {
	mutation := newSignalExecutionDataMutation(c.config, OpUpdate)
	return &SignalExecutionDataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SignalExecutionDataClient) UpdateOne(sed *SignalExecutionData) *SignalExecutionDataUpdateOne {
	mutation := newSignalExecutionDataMutation(c.config, OpUpdateOne, withSignalExecutionData(sed))
	return &SignalExecutionDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SignalExecutionDataClient) UpdateOneID(id schema.SignalExecutionDataID) *SignalExecutionDataUpdateOne {
	mutation := newSignalExecutionDataMutation(c.config, OpUpdateOne, withSignalExecutionDataID(id))
	return &SignalExecutionDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SignalExecutionData.
func (c *SignalExecutionDataClient) Delete() *SignalExecutionDataDelete {
	mutation := newSignalExecutionDataMutation(c.config, OpDelete)
	return &SignalExecutionDataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SignalExecutionDataClient) DeleteOne(sed *SignalExecutionData) *SignalExecutionDataDeleteOne {
	return c.DeleteOneID(sed.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SignalExecutionDataClient) DeleteOneID(id schema.SignalExecutionDataID) *SignalExecutionDataDeleteOne {
	builder := c.Delete().Where(signalexecutiondata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SignalExecutionDataDeleteOne{builder}
}

// Query returns a query builder for SignalExecutionData.
func (c *SignalExecutionDataClient) Query() *SignalExecutionDataQuery {
	return &SignalExecutionDataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSignalExecutionData},
		inters: c.Interceptors(),
	}
}

// Get returns a SignalExecutionData entity by its id.
func (c *SignalExecutionDataClient) Get(ctx context.Context, id schema.SignalExecutionDataID) (*SignalExecutionData, error) {
	return c.Query().Where(signalexecutiondata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SignalExecutionDataClient) GetX(ctx context.Context, id schema.SignalExecutionDataID) *SignalExecutionData {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryExecution queries the execution edge of a SignalExecutionData.
func (c *SignalExecutionDataClient) QueryExecution(sed *SignalExecutionData) *SignalExecutionQuery {
	query := (&SignalExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sed.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(signalexecutiondata.Table, signalexecutiondata.FieldID, id),
			sqlgraph.To(signalexecution.Table, signalexecution.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, signalexecutiondata.ExecutionTable, signalexecutiondata.ExecutionColumn),
		)
		fromV = sqlgraph.Neighbors(sed.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SignalExecutionDataClient) Hooks() []Hook {
	return c.hooks.SignalExecutionData
}

// Interceptors returns the client interceptors.
func (c *SignalExecutionDataClient) Interceptors() []Interceptor {
	return c.inters.SignalExecutionData
}

func (c *SignalExecutionDataClient) mutate(ctx context.Context, m *SignalExecutionDataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SignalExecutionDataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SignalExecutionDataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SignalExecutionDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SignalExecutionDataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SignalExecutionData mutation op: %q", m.Op())
	}
}

// VersionClient is a client for the Version schema.
type VersionClient struct {
	config
}

// NewVersionClient returns a client for the Version from the given config.
func NewVersionClient(c config) *VersionClient {
	return &VersionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `version.Hooks(f(g(h())))`.
func (c *VersionClient) Use(hooks ...Hook) {
	c.hooks.Version = append(c.hooks.Version, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `version.Intercept(f(g(h())))`.
func (c *VersionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Version = append(c.inters.Version, interceptors...)
}

// Create returns a builder for creating a Version entity.
func (c *VersionClient) Create() *VersionCreate {
	mutation := newVersionMutation(c.config, OpCreate)
	return &VersionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Version entities.
func (c *VersionClient) CreateBulk(builders ...*VersionCreate) *VersionCreateBulk {
	return &VersionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VersionClient) MapCreateBulk(slice any, setFunc func(*VersionCreate, int)) *VersionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VersionCreateBulk{err: fmt.Errorf("calling to VersionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VersionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VersionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Version.
func (c *VersionClient) Update() *VersionUpdate {
	mutation := newVersionMutation(c.config, OpUpdate)
	return &VersionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VersionClient) UpdateOne(v *Version) *VersionUpdateOne {
	mutation := newVersionMutation(c.config, OpUpdateOne, withVersion(v))
	return &VersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VersionClient) UpdateOneID(id schema.VersionID) *VersionUpdateOne {
	mutation := newVersionMutation(c.config, OpUpdateOne, withVersionID(id))
	return &VersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Version.
func (c *VersionClient) Delete() *VersionDelete {
	mutation := newVersionMutation(c.config, OpDelete)
	return &VersionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VersionClient) DeleteOne(v *Version) *VersionDeleteOne {
	return c.DeleteOneID(v.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VersionClient) DeleteOneID(id schema.VersionID) *VersionDeleteOne {
	builder := c.Delete().Where(version.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VersionDeleteOne{builder}
}

// Query returns a query builder for Version.
func (c *VersionClient) Query() *VersionQuery {
	return &VersionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVersion},
		inters: c.Interceptors(),
	}
}

// Get returns a Version entity by its id.
func (c *VersionClient) Get(ctx context.Context, id schema.VersionID) (*Version, error) {
	return c.Query().Where(version.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VersionClient) GetX(ctx context.Context, id schema.VersionID) *Version {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryWorkflow queries the workflow edge of a Version.
func (c *VersionClient) QueryWorkflow(v *Version) *WorkflowEntityQuery {
	query := (&WorkflowEntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(version.Table, version.FieldID, id),
			sqlgraph.To(workflowentity.Table, workflowentity.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, version.WorkflowTable, version.WorkflowColumn),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VersionClient) Hooks() []Hook {
	return c.hooks.Version
}

// Interceptors returns the client interceptors.
func (c *VersionClient) Interceptors() []Interceptor {
	return c.inters.Version
}

func (c *VersionClient) mutate(ctx context.Context, m *VersionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VersionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VersionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VersionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Version mutation op: %q", m.Op())
	}
}

// WorkflowDataClient is a client for the WorkflowData schema.
type WorkflowDataClient struct {
	config
}

// NewWorkflowDataClient returns a client for the WorkflowData from the given config.
func NewWorkflowDataClient(c config) *WorkflowDataClient {
	return &WorkflowDataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workflowdata.Hooks(f(g(h())))`.
func (c *WorkflowDataClient) Use(hooks ...Hook) {
	c.hooks.WorkflowData = append(c.hooks.WorkflowData, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `workflowdata.Intercept(f(g(h())))`.
func (c *WorkflowDataClient) Intercept(interceptors ...Interceptor) {
	c.inters.WorkflowData = append(c.inters.WorkflowData, interceptors...)
}

// Create returns a builder for creating a WorkflowData entity.
func (c *WorkflowDataClient) Create() *WorkflowDataCreate {
	mutation := newWorkflowDataMutation(c.config, OpCreate)
	return &WorkflowDataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WorkflowData entities.
func (c *WorkflowDataClient) CreateBulk(builders ...*WorkflowDataCreate) *WorkflowDataCreateBulk {
	return &WorkflowDataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WorkflowDataClient) MapCreateBulk(slice any, setFunc func(*WorkflowDataCreate, int)) *WorkflowDataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WorkflowDataCreateBulk{err: fmt.Errorf("calling to WorkflowDataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WorkflowDataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WorkflowDataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WorkflowData.
func (c *WorkflowDataClient) Update() *WorkflowDataUpdate {
	mutation := newWorkflowDataMutation(c.config, OpUpdate)
	return &WorkflowDataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkflowDataClient) UpdateOne(wd *WorkflowData) *WorkflowDataUpdateOne {
	mutation := newWorkflowDataMutation(c.config, OpUpdateOne, withWorkflowData(wd))
	return &WorkflowDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkflowDataClient) UpdateOneID(id schema.WorkflowDataID) *WorkflowDataUpdateOne {
	mutation := newWorkflowDataMutation(c.config, OpUpdateOne, withWorkflowDataID(id))
	return &WorkflowDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WorkflowData.
func (c *WorkflowDataClient) Delete() *WorkflowDataDelete {
	mutation := newWorkflowDataMutation(c.config, OpDelete)
	return &WorkflowDataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WorkflowDataClient) DeleteOne(wd *WorkflowData) *WorkflowDataDeleteOne {
	return c.DeleteOneID(wd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WorkflowDataClient) DeleteOneID(id schema.WorkflowDataID) *WorkflowDataDeleteOne {
	builder := c.Delete().Where(workflowdata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkflowDataDeleteOne{builder}
}

// Query returns a query builder for WorkflowData.
func (c *WorkflowDataClient) Query() *WorkflowDataQuery {
	return &WorkflowDataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWorkflowData},
		inters: c.Interceptors(),
	}
}

// Get returns a WorkflowData entity by its id.
func (c *WorkflowDataClient) Get(ctx context.Context, id schema.WorkflowDataID) (*WorkflowData, error) {
	return c.Query().Where(workflowdata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkflowDataClient) GetX(ctx context.Context, id schema.WorkflowDataID) *WorkflowData {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryWorkflow queries the workflow edge of a WorkflowData.
func (c *WorkflowDataClient) QueryWorkflow(wd *WorkflowData) *WorkflowEntityQuery {
	query := (&WorkflowEntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := wd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowdata.Table, workflowdata.FieldID, id),
			sqlgraph.To(workflowentity.Table, workflowentity.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, workflowdata.WorkflowTable, workflowdata.WorkflowColumn),
		)
		fromV = sqlgraph.Neighbors(wd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorkflowDataClient) Hooks() []Hook {
	return c.hooks.WorkflowData
}

// Interceptors returns the client interceptors.
func (c *WorkflowDataClient) Interceptors() []Interceptor {
	return c.inters.WorkflowData
}

func (c *WorkflowDataClient) mutate(ctx context.Context, m *WorkflowDataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WorkflowDataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WorkflowDataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WorkflowDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WorkflowDataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WorkflowData mutation op: %q", m.Op())
	}
}

// WorkflowEntityClient is a client for the WorkflowEntity schema.
type WorkflowEntityClient struct {
	config
}

// NewWorkflowEntityClient returns a client for the WorkflowEntity from the given config.
func NewWorkflowEntityClient(c config) *WorkflowEntityClient {
	return &WorkflowEntityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workflowentity.Hooks(f(g(h())))`.
func (c *WorkflowEntityClient) Use(hooks ...Hook) {
	c.hooks.WorkflowEntity = append(c.hooks.WorkflowEntity, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `workflowentity.Intercept(f(g(h())))`.
func (c *WorkflowEntityClient) Intercept(interceptors ...Interceptor) {
	c.inters.WorkflowEntity = append(c.inters.WorkflowEntity, interceptors...)
}

// Create returns a builder for creating a WorkflowEntity entity.
func (c *WorkflowEntityClient) Create() *WorkflowEntityCreate {
	mutation := newWorkflowEntityMutation(c.config, OpCreate)
	return &WorkflowEntityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WorkflowEntity entities.
func (c *WorkflowEntityClient) CreateBulk(builders ...*WorkflowEntityCreate) *WorkflowEntityCreateBulk {
	return &WorkflowEntityCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WorkflowEntityClient) MapCreateBulk(slice any, setFunc func(*WorkflowEntityCreate, int)) *WorkflowEntityCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WorkflowEntityCreateBulk{err: fmt.Errorf("calling to WorkflowEntityClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WorkflowEntityCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WorkflowEntityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WorkflowEntity.
func (c *WorkflowEntityClient) Update() *WorkflowEntityUpdate {
	mutation := newWorkflowEntityMutation(c.config, OpUpdate)
	return &WorkflowEntityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkflowEntityClient) UpdateOne(we *WorkflowEntity) *WorkflowEntityUpdateOne {
	mutation := newWorkflowEntityMutation(c.config, OpUpdateOne, withWorkflowEntity(we))
	return &WorkflowEntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkflowEntityClient) UpdateOneID(id schema.WorkflowEntityID) *WorkflowEntityUpdateOne {
	mutation := newWorkflowEntityMutation(c.config, OpUpdateOne, withWorkflowEntityID(id))
	return &WorkflowEntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WorkflowEntity.
func (c *WorkflowEntityClient) Delete() *WorkflowEntityDelete {
	mutation := newWorkflowEntityMutation(c.config, OpDelete)
	return &WorkflowEntityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WorkflowEntityClient) DeleteOne(we *WorkflowEntity) *WorkflowEntityDeleteOne {
	return c.DeleteOneID(we.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WorkflowEntityClient) DeleteOneID(id schema.WorkflowEntityID) *WorkflowEntityDeleteOne {
	builder := c.Delete().Where(workflowentity.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkflowEntityDeleteOne{builder}
}

// Query returns a query builder for WorkflowEntity.
func (c *WorkflowEntityClient) Query() *WorkflowEntityQuery {
	return &WorkflowEntityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWorkflowEntity},
		inters: c.Interceptors(),
	}
}

// Get returns a WorkflowEntity entity by its id.
func (c *WorkflowEntityClient) Get(ctx context.Context, id schema.WorkflowEntityID) (*WorkflowEntity, error) {
	return c.Query().Where(workflowentity.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkflowEntityClient) GetX(ctx context.Context, id schema.WorkflowEntityID) *WorkflowEntity {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryQueue queries the queue edge of a WorkflowEntity.
func (c *WorkflowEntityClient) QueryQueue(we *WorkflowEntity) *QueueQuery {
	query := (&QueueClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := we.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowentity.Table, workflowentity.FieldID, id),
			sqlgraph.To(queue.Table, queue.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workflowentity.QueueTable, workflowentity.QueueColumn),
		)
		fromV = sqlgraph.Neighbors(we.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRun queries the run edge of a WorkflowEntity.
func (c *WorkflowEntityClient) QueryRun(we *WorkflowEntity) *RunQuery {
	query := (&RunClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := we.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowentity.Table, workflowentity.FieldID, id),
			sqlgraph.To(run.Table, run.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workflowentity.RunTable, workflowentity.RunColumn),
		)
		fromV = sqlgraph.Neighbors(we.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVersions queries the versions edge of a WorkflowEntity.
func (c *WorkflowEntityClient) QueryVersions(we *WorkflowEntity) *VersionQuery {
	query := (&VersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := we.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowentity.Table, workflowentity.FieldID, id),
			sqlgraph.To(version.Table, version.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, workflowentity.VersionsTable, workflowentity.VersionsColumn),
		)
		fromV = sqlgraph.Neighbors(we.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkflowData queries the workflow_data edge of a WorkflowEntity.
func (c *WorkflowEntityClient) QueryWorkflowData(we *WorkflowEntity) *WorkflowDataQuery {
	query := (&WorkflowDataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := we.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowentity.Table, workflowentity.FieldID, id),
			sqlgraph.To(workflowdata.Table, workflowdata.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, workflowentity.WorkflowDataTable, workflowentity.WorkflowDataColumn),
		)
		fromV = sqlgraph.Neighbors(we.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActivityChildren queries the activity_children edge of a WorkflowEntity.
func (c *WorkflowEntityClient) QueryActivityChildren(we *WorkflowEntity) *ActivityEntityQuery {
	query := (&ActivityEntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := we.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowentity.Table, workflowentity.FieldID, id),
			sqlgraph.To(activityentity.Table, activityentity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, workflowentity.ActivityChildrenTable, workflowentity.ActivityChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(we.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySagaChildren queries the saga_children edge of a WorkflowEntity.
func (c *WorkflowEntityClient) QuerySagaChildren(we *WorkflowEntity) *SagaEntityQuery {
	query := (&SagaEntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := we.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowentity.Table, workflowentity.FieldID, id),
			sqlgraph.To(sagaentity.Table, sagaentity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, workflowentity.SagaChildrenTable, workflowentity.SagaChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(we.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySideEffectChildren queries the side_effect_children edge of a WorkflowEntity.
func (c *WorkflowEntityClient) QuerySideEffectChildren(we *WorkflowEntity) *SideEffectEntityQuery {
	query := (&SideEffectEntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := we.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowentity.Table, workflowentity.FieldID, id),
			sqlgraph.To(sideeffectentity.Table, sideeffectentity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, workflowentity.SideEffectChildrenTable, workflowentity.SideEffectChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(we.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExecutions queries the executions edge of a WorkflowEntity.
func (c *WorkflowEntityClient) QueryExecutions(we *WorkflowEntity) *WorkflowExecutionQuery {
	query := (&WorkflowExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := we.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowentity.Table, workflowentity.FieldID, id),
			sqlgraph.To(workflowexecution.Table, workflowexecution.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, workflowentity.ExecutionsTable, workflowentity.ExecutionsColumn),
		)
		fromV = sqlgraph.Neighbors(we.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorkflowEntityClient) Hooks() []Hook {
	return c.hooks.WorkflowEntity
}

// Interceptors returns the client interceptors.
func (c *WorkflowEntityClient) Interceptors() []Interceptor {
	return c.inters.WorkflowEntity
}

func (c *WorkflowEntityClient) mutate(ctx context.Context, m *WorkflowEntityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WorkflowEntityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WorkflowEntityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WorkflowEntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WorkflowEntityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WorkflowEntity mutation op: %q", m.Op())
	}
}

// WorkflowExecutionClient is a client for the WorkflowExecution schema.
type WorkflowExecutionClient struct {
	config
}

// NewWorkflowExecutionClient returns a client for the WorkflowExecution from the given config.
func NewWorkflowExecutionClient(c config) *WorkflowExecutionClient {
	return &WorkflowExecutionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workflowexecution.Hooks(f(g(h())))`.
func (c *WorkflowExecutionClient) Use(hooks ...Hook) {
	c.hooks.WorkflowExecution = append(c.hooks.WorkflowExecution, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `workflowexecution.Intercept(f(g(h())))`.
func (c *WorkflowExecutionClient) Intercept(interceptors ...Interceptor) {
	c.inters.WorkflowExecution = append(c.inters.WorkflowExecution, interceptors...)
}

// Create returns a builder for creating a WorkflowExecution entity.
func (c *WorkflowExecutionClient) Create() *WorkflowExecutionCreate {
	mutation := newWorkflowExecutionMutation(c.config, OpCreate)
	return &WorkflowExecutionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WorkflowExecution entities.
func (c *WorkflowExecutionClient) CreateBulk(builders ...*WorkflowExecutionCreate) *WorkflowExecutionCreateBulk {
	return &WorkflowExecutionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WorkflowExecutionClient) MapCreateBulk(slice any, setFunc func(*WorkflowExecutionCreate, int)) *WorkflowExecutionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WorkflowExecutionCreateBulk{err: fmt.Errorf("calling to WorkflowExecutionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WorkflowExecutionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WorkflowExecutionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WorkflowExecution.
func (c *WorkflowExecutionClient) Update() *WorkflowExecutionUpdate {
	mutation := newWorkflowExecutionMutation(c.config, OpUpdate)
	return &WorkflowExecutionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkflowExecutionClient) UpdateOne(we *WorkflowExecution) *WorkflowExecutionUpdateOne {
	mutation := newWorkflowExecutionMutation(c.config, OpUpdateOne, withWorkflowExecution(we))
	return &WorkflowExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkflowExecutionClient) UpdateOneID(id schema.WorkflowExecutionID) *WorkflowExecutionUpdateOne {
	mutation := newWorkflowExecutionMutation(c.config, OpUpdateOne, withWorkflowExecutionID(id))
	return &WorkflowExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WorkflowExecution.
func (c *WorkflowExecutionClient) Delete() *WorkflowExecutionDelete {
	mutation := newWorkflowExecutionMutation(c.config, OpDelete)
	return &WorkflowExecutionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WorkflowExecutionClient) DeleteOne(we *WorkflowExecution) *WorkflowExecutionDeleteOne {
	return c.DeleteOneID(we.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WorkflowExecutionClient) DeleteOneID(id schema.WorkflowExecutionID) *WorkflowExecutionDeleteOne {
	builder := c.Delete().Where(workflowexecution.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkflowExecutionDeleteOne{builder}
}

// Query returns a query builder for WorkflowExecution.
func (c *WorkflowExecutionClient) Query() *WorkflowExecutionQuery {
	return &WorkflowExecutionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWorkflowExecution},
		inters: c.Interceptors(),
	}
}

// Get returns a WorkflowExecution entity by its id.
func (c *WorkflowExecutionClient) Get(ctx context.Context, id schema.WorkflowExecutionID) (*WorkflowExecution, error) {
	return c.Query().Where(workflowexecution.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkflowExecutionClient) GetX(ctx context.Context, id schema.WorkflowExecutionID) *WorkflowExecution {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryWorkflow queries the workflow edge of a WorkflowExecution.
func (c *WorkflowExecutionClient) QueryWorkflow(we *WorkflowExecution) *WorkflowEntityQuery {
	query := (&WorkflowEntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := we.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowexecution.Table, workflowexecution.FieldID, id),
			sqlgraph.To(workflowentity.Table, workflowentity.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workflowexecution.WorkflowTable, workflowexecution.WorkflowColumn),
		)
		fromV = sqlgraph.Neighbors(we.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExecutionData queries the execution_data edge of a WorkflowExecution.
func (c *WorkflowExecutionClient) QueryExecutionData(we *WorkflowExecution) *WorkflowExecutionDataQuery {
	query := (&WorkflowExecutionDataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := we.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowexecution.Table, workflowexecution.FieldID, id),
			sqlgraph.To(workflowexecutiondata.Table, workflowexecutiondata.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, workflowexecution.ExecutionDataTable, workflowexecution.ExecutionDataColumn),
		)
		fromV = sqlgraph.Neighbors(we.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorkflowExecutionClient) Hooks() []Hook {
	return c.hooks.WorkflowExecution
}

// Interceptors returns the client interceptors.
func (c *WorkflowExecutionClient) Interceptors() []Interceptor {
	return c.inters.WorkflowExecution
}

func (c *WorkflowExecutionClient) mutate(ctx context.Context, m *WorkflowExecutionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WorkflowExecutionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WorkflowExecutionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WorkflowExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WorkflowExecutionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WorkflowExecution mutation op: %q", m.Op())
	}
}

// WorkflowExecutionDataClient is a client for the WorkflowExecutionData schema.
type WorkflowExecutionDataClient struct {
	config
}

// NewWorkflowExecutionDataClient returns a client for the WorkflowExecutionData from the given config.
func NewWorkflowExecutionDataClient(c config) *WorkflowExecutionDataClient {
	return &WorkflowExecutionDataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workflowexecutiondata.Hooks(f(g(h())))`.
func (c *WorkflowExecutionDataClient) Use(hooks ...Hook) {
	c.hooks.WorkflowExecutionData = append(c.hooks.WorkflowExecutionData, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `workflowexecutiondata.Intercept(f(g(h())))`.
func (c *WorkflowExecutionDataClient) Intercept(interceptors ...Interceptor) {
	c.inters.WorkflowExecutionData = append(c.inters.WorkflowExecutionData, interceptors...)
}

// Create returns a builder for creating a WorkflowExecutionData entity.
func (c *WorkflowExecutionDataClient) Create() *WorkflowExecutionDataCreate {
	mutation := newWorkflowExecutionDataMutation(c.config, OpCreate)
	return &WorkflowExecutionDataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WorkflowExecutionData entities.
func (c *WorkflowExecutionDataClient) CreateBulk(builders ...*WorkflowExecutionDataCreate) *WorkflowExecutionDataCreateBulk {
	return &WorkflowExecutionDataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WorkflowExecutionDataClient) MapCreateBulk(slice any, setFunc func(*WorkflowExecutionDataCreate, int)) *WorkflowExecutionDataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WorkflowExecutionDataCreateBulk{err: fmt.Errorf("calling to WorkflowExecutionDataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WorkflowExecutionDataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WorkflowExecutionDataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WorkflowExecutionData.
func (c *WorkflowExecutionDataClient) Update() *WorkflowExecutionDataUpdate {
	mutation := newWorkflowExecutionDataMutation(c.config, OpUpdate)
	return &WorkflowExecutionDataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkflowExecutionDataClient) UpdateOne(wed *WorkflowExecutionData) *WorkflowExecutionDataUpdateOne {
	mutation := newWorkflowExecutionDataMutation(c.config, OpUpdateOne, withWorkflowExecutionData(wed))
	return &WorkflowExecutionDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkflowExecutionDataClient) UpdateOneID(id schema.WorkflowExecutionDataID) *WorkflowExecutionDataUpdateOne {
	mutation := newWorkflowExecutionDataMutation(c.config, OpUpdateOne, withWorkflowExecutionDataID(id))
	return &WorkflowExecutionDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WorkflowExecutionData.
func (c *WorkflowExecutionDataClient) Delete() *WorkflowExecutionDataDelete {
	mutation := newWorkflowExecutionDataMutation(c.config, OpDelete)
	return &WorkflowExecutionDataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WorkflowExecutionDataClient) DeleteOne(wed *WorkflowExecutionData) *WorkflowExecutionDataDeleteOne {
	return c.DeleteOneID(wed.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WorkflowExecutionDataClient) DeleteOneID(id schema.WorkflowExecutionDataID) *WorkflowExecutionDataDeleteOne {
	builder := c.Delete().Where(workflowexecutiondata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkflowExecutionDataDeleteOne{builder}
}

// Query returns a query builder for WorkflowExecutionData.
func (c *WorkflowExecutionDataClient) Query() *WorkflowExecutionDataQuery {
	return &WorkflowExecutionDataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWorkflowExecutionData},
		inters: c.Interceptors(),
	}
}

// Get returns a WorkflowExecutionData entity by its id.
func (c *WorkflowExecutionDataClient) Get(ctx context.Context, id schema.WorkflowExecutionDataID) (*WorkflowExecutionData, error) {
	return c.Query().Where(workflowexecutiondata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkflowExecutionDataClient) GetX(ctx context.Context, id schema.WorkflowExecutionDataID) *WorkflowExecutionData {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryExecution queries the execution edge of a WorkflowExecutionData.
func (c *WorkflowExecutionDataClient) QueryExecution(wed *WorkflowExecutionData) *WorkflowExecutionQuery {
	query := (&WorkflowExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := wed.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowexecutiondata.Table, workflowexecutiondata.FieldID, id),
			sqlgraph.To(workflowexecution.Table, workflowexecution.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, workflowexecutiondata.ExecutionTable, workflowexecutiondata.ExecutionColumn),
		)
		fromV = sqlgraph.Neighbors(wed.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorkflowExecutionDataClient) Hooks() []Hook {
	return c.hooks.WorkflowExecutionData
}

// Interceptors returns the client interceptors.
func (c *WorkflowExecutionDataClient) Interceptors() []Interceptor {
	return c.inters.WorkflowExecutionData
}

func (c *WorkflowExecutionDataClient) mutate(ctx context.Context, m *WorkflowExecutionDataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WorkflowExecutionDataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WorkflowExecutionDataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WorkflowExecutionDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WorkflowExecutionDataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WorkflowExecutionData mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		ActivityData, ActivityEntity, ActivityExecution, ActivityExecutionData,
		Hierarchy, Queue, Run, SagaData, SagaEntity, SagaExecution, SagaExecutionData,
		SagaValue, SideEffectData, SideEffectEntity, SideEffectExecution,
		SideEffectExecutionData, SignalData, SignalEntity, SignalExecution,
		SignalExecutionData, Version, WorkflowData, WorkflowEntity, WorkflowExecution,
		WorkflowExecutionData []ent.Hook
	}
	inters struct {
		ActivityData, ActivityEntity, ActivityExecution, ActivityExecutionData,
		Hierarchy, Queue, Run, SagaData, SagaEntity, SagaExecution, SagaExecutionData,
		SagaValue, SideEffectData, SideEffectEntity, SideEffectExecution,
		SideEffectExecutionData, SignalData, SignalEntity, SignalExecution,
		SignalExecutionData, Version, WorkflowData, WorkflowEntity, WorkflowExecution,
		WorkflowExecutionData []ent.Interceptor
	}
)
