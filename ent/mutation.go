// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/davidroman0O/tempolite/ent/activitydata"
	"github.com/davidroman0O/tempolite/ent/activityentity"
	"github.com/davidroman0O/tempolite/ent/activityexecution"
	"github.com/davidroman0O/tempolite/ent/activityexecutiondata"
	"github.com/davidroman0O/tempolite/ent/hierarchy"
	"github.com/davidroman0O/tempolite/ent/predicate"
	"github.com/davidroman0O/tempolite/ent/queue"
	"github.com/davidroman0O/tempolite/ent/run"
	"github.com/davidroman0O/tempolite/ent/sagadata"
	"github.com/davidroman0O/tempolite/ent/sagaentity"
	"github.com/davidroman0O/tempolite/ent/sagaexecution"
	"github.com/davidroman0O/tempolite/ent/sagaexecutiondata"
	"github.com/davidroman0O/tempolite/ent/sagavalue"
	"github.com/davidroman0O/tempolite/ent/schema"
	"github.com/davidroman0O/tempolite/ent/sideeffectdata"
	"github.com/davidroman0O/tempolite/ent/sideeffectentity"
	"github.com/davidroman0O/tempolite/ent/sideeffectexecution"
	"github.com/davidroman0O/tempolite/ent/sideeffectexecutiondata"
	"github.com/davidroman0O/tempolite/ent/signaldata"
	"github.com/davidroman0O/tempolite/ent/signalentity"
	"github.com/davidroman0O/tempolite/ent/signalexecution"
	"github.com/davidroman0O/tempolite/ent/signalexecutiondata"
	"github.com/davidroman0O/tempolite/ent/version"
	"github.com/davidroman0O/tempolite/ent/workflowdata"
	"github.com/davidroman0O/tempolite/ent/workflowentity"
	"github.com/davidroman0O/tempolite/ent/workflowexecution"
	"github.com/davidroman0O/tempolite/ent/workflowexecutiondata"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeActivityData            = "ActivityData"
	TypeActivityEntity          = "ActivityEntity"
	TypeActivityExecution       = "ActivityExecution"
	TypeActivityExecutionData   = "ActivityExecutionData"
	TypeHierarchy               = "Hierarchy"
	TypeQueue                   = "Queue"
	TypeRun                     = "Run"
	TypeSagaData                = "SagaData"
	TypeSagaEntity              = "SagaEntity"
	TypeSagaExecution           = "SagaExecution"
	TypeSagaExecutionData       = "SagaExecutionData"
	TypeSagaValue               = "SagaValue"
	TypeSideEffectData          = "SideEffectData"
	TypeSideEffectEntity        = "SideEffectEntity"
	TypeSideEffectExecution     = "SideEffectExecution"
	TypeSideEffectExecutionData = "SideEffectExecutionData"
	TypeSignalData              = "SignalData"
	TypeSignalEntity            = "SignalEntity"
	TypeSignalExecution         = "SignalExecution"
	TypeSignalExecutionData     = "SignalExecutionData"
	TypeVersion                 = "Version"
	TypeWorkflowData            = "WorkflowData"
	TypeWorkflowEntity          = "WorkflowEntity"
	TypeWorkflowExecution       = "WorkflowExecution"
	TypeWorkflowExecutionData   = "WorkflowExecutionData"
)

// ActivityDataMutation represents an operation that mutates the ActivityData nodes in the graph.
type ActivityDataMutation struct {
	config
	op              Op
	typ             string
	id              *schema.ActivityDataID
	inputs          *[][]uint8
	appendinputs    [][]uint8
	output          *[]byte
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	activity        *schema.ActivityEntityID
	clearedactivity bool
	done            bool
	oldValue        func(context.Context) (*ActivityData, error)
	predicates      []predicate.ActivityData
}

var _ ent.Mutation = (*ActivityDataMutation)(nil)

// activitydataOption allows management of the mutation configuration using functional options.
type activitydataOption func(*ActivityDataMutation)

// newActivityDataMutation creates new mutation for the ActivityData entity.
func newActivityDataMutation(c config, op Op, opts ...activitydataOption) *ActivityDataMutation {
	m := &ActivityDataMutation{
		config:        c,
		op:            op,
		typ:           TypeActivityData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActivityDataID sets the ID field of the mutation.
func withActivityDataID(id schema.ActivityDataID) activitydataOption {
	return func(m *ActivityDataMutation) {
		var (
			err   error
			once  sync.Once
			value *ActivityData
		)
		m.oldValue = func(ctx context.Context) (*ActivityData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ActivityData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActivityData sets the old ActivityData of the mutation.
func withActivityData(node *ActivityData) activitydataOption {
	return func(m *ActivityDataMutation) {
		m.oldValue = func(context.Context) (*ActivityData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActivityDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActivityDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ActivityData entities.
func (m *ActivityDataMutation) SetID(id schema.ActivityDataID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActivityDataMutation) ID() (id schema.ActivityDataID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActivityDataMutation) IDs(ctx context.Context) ([]schema.ActivityDataID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []schema.ActivityDataID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ActivityData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntityID sets the "entity_id" field.
func (m *ActivityDataMutation) SetEntityID(sei schema.ActivityEntityID) {
	m.activity = &sei
}

// EntityID returns the value of the "entity_id" field in the mutation.
func (m *ActivityDataMutation) EntityID() (r schema.ActivityEntityID, exists bool) {
	v := m.activity
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityID returns the old "entity_id" field's value of the ActivityData entity.
// If the ActivityData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityDataMutation) OldEntityID(ctx context.Context) (v schema.ActivityEntityID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityID: %w", err)
	}
	return oldValue.EntityID, nil
}

// ResetEntityID resets all changes to the "entity_id" field.
func (m *ActivityDataMutation) ResetEntityID() {
	m.activity = nil
}

// SetInputs sets the "inputs" field.
func (m *ActivityDataMutation) SetInputs(u [][]uint8) {
	m.inputs = &u
	m.appendinputs = nil
}

// Inputs returns the value of the "inputs" field in the mutation.
func (m *ActivityDataMutation) Inputs() (r [][]uint8, exists bool) {
	v := m.inputs
	if v == nil {
		return
	}
	return *v, true
}

// OldInputs returns the old "inputs" field's value of the ActivityData entity.
// If the ActivityData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityDataMutation) OldInputs(ctx context.Context) (v [][]uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInputs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInputs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInputs: %w", err)
	}
	return oldValue.Inputs, nil
}

// AppendInputs adds u to the "inputs" field.
func (m *ActivityDataMutation) AppendInputs(u [][]uint8) {
	m.appendinputs = append(m.appendinputs, u...)
}

// AppendedInputs returns the list of values that were appended to the "inputs" field in this mutation.
func (m *ActivityDataMutation) AppendedInputs() ([][]uint8, bool) {
	if len(m.appendinputs) == 0 {
		return nil, false
	}
	return m.appendinputs, true
}

// ClearInputs clears the value of the "inputs" field.
func (m *ActivityDataMutation) ClearInputs() {
	m.inputs = nil
	m.appendinputs = nil
	m.clearedFields[activitydata.FieldInputs] = struct{}{}
}

// InputsCleared returns if the "inputs" field was cleared in this mutation.
func (m *ActivityDataMutation) InputsCleared() bool {
	_, ok := m.clearedFields[activitydata.FieldInputs]
	return ok
}

// ResetInputs resets all changes to the "inputs" field.
func (m *ActivityDataMutation) ResetInputs() {
	m.inputs = nil
	m.appendinputs = nil
	delete(m.clearedFields, activitydata.FieldInputs)
}

// SetOutput sets the "output" field.
func (m *ActivityDataMutation) SetOutput(b []byte) {
	m.output = &b
}

// Output returns the value of the "output" field in the mutation.
func (m *ActivityDataMutation) Output() (r []byte, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the ActivityData entity.
// If the ActivityData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityDataMutation) OldOutput(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// ClearOutput clears the value of the "output" field.
func (m *ActivityDataMutation) ClearOutput() {
	m.output = nil
	m.clearedFields[activitydata.FieldOutput] = struct{}{}
}

// OutputCleared returns if the "output" field was cleared in this mutation.
func (m *ActivityDataMutation) OutputCleared() bool {
	_, ok := m.clearedFields[activitydata.FieldOutput]
	return ok
}

// ResetOutput resets all changes to the "output" field.
func (m *ActivityDataMutation) ResetOutput() {
	m.output = nil
	delete(m.clearedFields, activitydata.FieldOutput)
}

// SetCreatedAt sets the "created_at" field.
func (m *ActivityDataMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ActivityDataMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ActivityData entity.
// If the ActivityData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityDataMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ActivityDataMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ActivityDataMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ActivityDataMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ActivityData entity.
// If the ActivityData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityDataMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ActivityDataMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetActivityID sets the "activity" edge to the ActivityEntity entity by id.
func (m *ActivityDataMutation) SetActivityID(id schema.ActivityEntityID) {
	m.activity = &id
}

// ClearActivity clears the "activity" edge to the ActivityEntity entity.
func (m *ActivityDataMutation) ClearActivity() {
	m.clearedactivity = true
	m.clearedFields[activitydata.FieldEntityID] = struct{}{}
}

// ActivityCleared reports if the "activity" edge to the ActivityEntity entity was cleared.
func (m *ActivityDataMutation) ActivityCleared() bool {
	return m.clearedactivity
}

// ActivityID returns the "activity" edge ID in the mutation.
func (m *ActivityDataMutation) ActivityID() (id schema.ActivityEntityID, exists bool) {
	if m.activity != nil {
		return *m.activity, true
	}
	return
}

// ActivityIDs returns the "activity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActivityID instead. It exists only for internal usage by the builders.
func (m *ActivityDataMutation) ActivityIDs() (ids []schema.ActivityEntityID) {
	if id := m.activity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActivity resets all changes to the "activity" edge.
func (m *ActivityDataMutation) ResetActivity() {
	m.activity = nil
	m.clearedactivity = false
}

// Where appends a list predicates to the ActivityDataMutation builder.
func (m *ActivityDataMutation) Where(ps ...predicate.ActivityData) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ActivityDataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ActivityDataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ActivityData, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ActivityDataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ActivityDataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ActivityData).
func (m *ActivityDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActivityDataMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.activity != nil {
		fields = append(fields, activitydata.FieldEntityID)
	}
	if m.inputs != nil {
		fields = append(fields, activitydata.FieldInputs)
	}
	if m.output != nil {
		fields = append(fields, activitydata.FieldOutput)
	}
	if m.created_at != nil {
		fields = append(fields, activitydata.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, activitydata.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActivityDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case activitydata.FieldEntityID:
		return m.EntityID()
	case activitydata.FieldInputs:
		return m.Inputs()
	case activitydata.FieldOutput:
		return m.Output()
	case activitydata.FieldCreatedAt:
		return m.CreatedAt()
	case activitydata.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActivityDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case activitydata.FieldEntityID:
		return m.OldEntityID(ctx)
	case activitydata.FieldInputs:
		return m.OldInputs(ctx)
	case activitydata.FieldOutput:
		return m.OldOutput(ctx)
	case activitydata.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case activitydata.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ActivityData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case activitydata.FieldEntityID:
		v, ok := value.(schema.ActivityEntityID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityID(v)
		return nil
	case activitydata.FieldInputs:
		v, ok := value.([][]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInputs(v)
		return nil
	case activitydata.FieldOutput:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case activitydata.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case activitydata.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ActivityData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActivityDataMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActivityDataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ActivityData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActivityDataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(activitydata.FieldInputs) {
		fields = append(fields, activitydata.FieldInputs)
	}
	if m.FieldCleared(activitydata.FieldOutput) {
		fields = append(fields, activitydata.FieldOutput)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActivityDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActivityDataMutation) ClearField(name string) error {
	switch name {
	case activitydata.FieldInputs:
		m.ClearInputs()
		return nil
	case activitydata.FieldOutput:
		m.ClearOutput()
		return nil
	}
	return fmt.Errorf("unknown ActivityData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActivityDataMutation) ResetField(name string) error {
	switch name {
	case activitydata.FieldEntityID:
		m.ResetEntityID()
		return nil
	case activitydata.FieldInputs:
		m.ResetInputs()
		return nil
	case activitydata.FieldOutput:
		m.ResetOutput()
		return nil
	case activitydata.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case activitydata.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ActivityData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActivityDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.activity != nil {
		edges = append(edges, activitydata.EdgeActivity)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActivityDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case activitydata.EdgeActivity:
		if id := m.activity; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActivityDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActivityDataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActivityDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedactivity {
		edges = append(edges, activitydata.EdgeActivity)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActivityDataMutation) EdgeCleared(name string) bool {
	switch name {
	case activitydata.EdgeActivity:
		return m.clearedactivity
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActivityDataMutation) ClearEdge(name string) error {
	switch name {
	case activitydata.EdgeActivity:
		m.ClearActivity()
		return nil
	}
	return fmt.Errorf("unknown ActivityData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActivityDataMutation) ResetEdge(name string) error {
	switch name {
	case activitydata.EdgeActivity:
		m.ResetActivity()
		return nil
	}
	return fmt.Errorf("unknown ActivityData edge %s", name)
}

// ActivityEntityMutation represents an operation that mutates the ActivityEntity nodes in the graph.
type ActivityEntityMutation struct {
	config
	op                   Op
	typ                  string
	id                   *schema.ActivityEntityID
	handler_name         *string
	_type                *schema.EntityType
	status               *schema.EntityStatus
	step_id              *schema.ActivityStepID
	run_id               *schema.RunID
	addrun_id            *schema.RunID
	retry_policy         *schema.RetryPolicy
	retry_state          *schema.RetryState
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	workflow             *schema.WorkflowEntityID
	clearedworkflow      bool
	activity_data        *schema.ActivityDataID
	clearedactivity_data bool
	executions           map[schema.ActivityExecutionID]struct{}
	removedexecutions    map[schema.ActivityExecutionID]struct{}
	clearedexecutions    bool
	done                 bool
	oldValue             func(context.Context) (*ActivityEntity, error)
	predicates           []predicate.ActivityEntity
}

var _ ent.Mutation = (*ActivityEntityMutation)(nil)

// activityentityOption allows management of the mutation configuration using functional options.
type activityentityOption func(*ActivityEntityMutation)

// newActivityEntityMutation creates new mutation for the ActivityEntity entity.
func newActivityEntityMutation(c config, op Op, opts ...activityentityOption) *ActivityEntityMutation {
	m := &ActivityEntityMutation{
		config:        c,
		op:            op,
		typ:           TypeActivityEntity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActivityEntityID sets the ID field of the mutation.
func withActivityEntityID(id schema.ActivityEntityID) activityentityOption {
	return func(m *ActivityEntityMutation) {
		var (
			err   error
			once  sync.Once
			value *ActivityEntity
		)
		m.oldValue = func(ctx context.Context) (*ActivityEntity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ActivityEntity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActivityEntity sets the old ActivityEntity of the mutation.
func withActivityEntity(node *ActivityEntity) activityentityOption {
	return func(m *ActivityEntityMutation) {
		m.oldValue = func(context.Context) (*ActivityEntity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActivityEntityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActivityEntityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ActivityEntity entities.
func (m *ActivityEntityMutation) SetID(id schema.ActivityEntityID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActivityEntityMutation) ID() (id schema.ActivityEntityID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActivityEntityMutation) IDs(ctx context.Context) ([]schema.ActivityEntityID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []schema.ActivityEntityID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ActivityEntity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHandlerName sets the "handler_name" field.
func (m *ActivityEntityMutation) SetHandlerName(s string) {
	m.handler_name = &s
}

// HandlerName returns the value of the "handler_name" field in the mutation.
func (m *ActivityEntityMutation) HandlerName() (r string, exists bool) {
	v := m.handler_name
	if v == nil {
		return
	}
	return *v, true
}

// OldHandlerName returns the old "handler_name" field's value of the ActivityEntity entity.
// If the ActivityEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityEntityMutation) OldHandlerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandlerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandlerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandlerName: %w", err)
	}
	return oldValue.HandlerName, nil
}

// ResetHandlerName resets all changes to the "handler_name" field.
func (m *ActivityEntityMutation) ResetHandlerName() {
	m.handler_name = nil
}

// SetType sets the "type" field.
func (m *ActivityEntityMutation) SetType(st schema.EntityType) {
	m._type = &st
}

// GetType returns the value of the "type" field in the mutation.
func (m *ActivityEntityMutation) GetType() (r schema.EntityType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ActivityEntity entity.
// If the ActivityEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityEntityMutation) OldType(ctx context.Context) (v schema.EntityType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ActivityEntityMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *ActivityEntityMutation) SetStatus(ss schema.EntityStatus) {
	m.status = &ss
}

// Status returns the value of the "status" field in the mutation.
func (m *ActivityEntityMutation) Status() (r schema.EntityStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ActivityEntity entity.
// If the ActivityEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityEntityMutation) OldStatus(ctx context.Context) (v schema.EntityStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ActivityEntityMutation) ResetStatus() {
	m.status = nil
}

// SetStepID sets the "step_id" field.
func (m *ActivityEntityMutation) SetStepID(ssi schema.ActivityStepID) {
	m.step_id = &ssi
}

// StepID returns the value of the "step_id" field in the mutation.
func (m *ActivityEntityMutation) StepID() (r schema.ActivityStepID, exists bool) {
	v := m.step_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStepID returns the old "step_id" field's value of the ActivityEntity entity.
// If the ActivityEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityEntityMutation) OldStepID(ctx context.Context) (v schema.ActivityStepID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStepID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStepID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStepID: %w", err)
	}
	return oldValue.StepID, nil
}

// ResetStepID resets all changes to the "step_id" field.
func (m *ActivityEntityMutation) ResetStepID() {
	m.step_id = nil
}

// SetRunID sets the "run_id" field.
func (m *ActivityEntityMutation) SetRunID(si schema.RunID) {
	m.run_id = &si
	m.addrun_id = nil
}

// RunID returns the value of the "run_id" field in the mutation.
func (m *ActivityEntityMutation) RunID() (r schema.RunID, exists bool) {
	v := m.run_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRunID returns the old "run_id" field's value of the ActivityEntity entity.
// If the ActivityEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityEntityMutation) OldRunID(ctx context.Context) (v schema.RunID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunID: %w", err)
	}
	return oldValue.RunID, nil
}

// AddRunID adds si to the "run_id" field.
func (m *ActivityEntityMutation) AddRunID(si schema.RunID) {
	if m.addrun_id != nil {
		*m.addrun_id += si
	} else {
		m.addrun_id = &si
	}
}

// AddedRunID returns the value that was added to the "run_id" field in this mutation.
func (m *ActivityEntityMutation) AddedRunID() (r schema.RunID, exists bool) {
	v := m.addrun_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRunID resets all changes to the "run_id" field.
func (m *ActivityEntityMutation) ResetRunID() {
	m.run_id = nil
	m.addrun_id = nil
}

// SetRetryPolicy sets the "retry_policy" field.
func (m *ActivityEntityMutation) SetRetryPolicy(sp schema.RetryPolicy) {
	m.retry_policy = &sp
}

// RetryPolicy returns the value of the "retry_policy" field in the mutation.
func (m *ActivityEntityMutation) RetryPolicy() (r schema.RetryPolicy, exists bool) {
	v := m.retry_policy
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryPolicy returns the old "retry_policy" field's value of the ActivityEntity entity.
// If the ActivityEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityEntityMutation) OldRetryPolicy(ctx context.Context) (v schema.RetryPolicy, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryPolicy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryPolicy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryPolicy: %w", err)
	}
	return oldValue.RetryPolicy, nil
}

// ResetRetryPolicy resets all changes to the "retry_policy" field.
func (m *ActivityEntityMutation) ResetRetryPolicy() {
	m.retry_policy = nil
}

// SetRetryState sets the "retry_state" field.
func (m *ActivityEntityMutation) SetRetryState(ss schema.RetryState) {
	m.retry_state = &ss
}

// RetryState returns the value of the "retry_state" field in the mutation.
func (m *ActivityEntityMutation) RetryState() (r schema.RetryState, exists bool) {
	v := m.retry_state
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryState returns the old "retry_state" field's value of the ActivityEntity entity.
// If the ActivityEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityEntityMutation) OldRetryState(ctx context.Context) (v schema.RetryState, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryState: %w", err)
	}
	return oldValue.RetryState, nil
}

// ResetRetryState resets all changes to the "retry_state" field.
func (m *ActivityEntityMutation) ResetRetryState() {
	m.retry_state = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ActivityEntityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ActivityEntityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ActivityEntity entity.
// If the ActivityEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityEntityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ActivityEntityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ActivityEntityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ActivityEntityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ActivityEntity entity.
// If the ActivityEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityEntityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ActivityEntityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetWorkflowID sets the "workflow" edge to the WorkflowEntity entity by id.
func (m *ActivityEntityMutation) SetWorkflowID(id schema.WorkflowEntityID) {
	m.workflow = &id
}

// ClearWorkflow clears the "workflow" edge to the WorkflowEntity entity.
func (m *ActivityEntityMutation) ClearWorkflow() {
	m.clearedworkflow = true
}

// WorkflowCleared reports if the "workflow" edge to the WorkflowEntity entity was cleared.
func (m *ActivityEntityMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowID returns the "workflow" edge ID in the mutation.
func (m *ActivityEntityMutation) WorkflowID() (id schema.WorkflowEntityID, exists bool) {
	if m.workflow != nil {
		return *m.workflow, true
	}
	return
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *ActivityEntityMutation) WorkflowIDs() (ids []schema.WorkflowEntityID) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *ActivityEntityMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// SetActivityDataID sets the "activity_data" edge to the ActivityData entity by id.
func (m *ActivityEntityMutation) SetActivityDataID(id schema.ActivityDataID) {
	m.activity_data = &id
}

// ClearActivityData clears the "activity_data" edge to the ActivityData entity.
func (m *ActivityEntityMutation) ClearActivityData() {
	m.clearedactivity_data = true
}

// ActivityDataCleared reports if the "activity_data" edge to the ActivityData entity was cleared.
func (m *ActivityEntityMutation) ActivityDataCleared() bool {
	return m.clearedactivity_data
}

// ActivityDataID returns the "activity_data" edge ID in the mutation.
func (m *ActivityEntityMutation) ActivityDataID() (id schema.ActivityDataID, exists bool) {
	if m.activity_data != nil {
		return *m.activity_data, true
	}
	return
}

// ActivityDataIDs returns the "activity_data" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActivityDataID instead. It exists only for internal usage by the builders.
func (m *ActivityEntityMutation) ActivityDataIDs() (ids []schema.ActivityDataID) {
	if id := m.activity_data; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActivityData resets all changes to the "activity_data" edge.
func (m *ActivityEntityMutation) ResetActivityData() {
	m.activity_data = nil
	m.clearedactivity_data = false
}

// AddExecutionIDs adds the "executions" edge to the ActivityExecution entity by ids.
func (m *ActivityEntityMutation) AddExecutionIDs(ids ...schema.ActivityExecutionID) {
	if m.executions == nil {
		m.executions = make(map[schema.ActivityExecutionID]struct{})
	}
	for i := range ids {
		m.executions[ids[i]] = struct{}{}
	}
}

// ClearExecutions clears the "executions" edge to the ActivityExecution entity.
func (m *ActivityEntityMutation) ClearExecutions() {
	m.clearedexecutions = true
}

// ExecutionsCleared reports if the "executions" edge to the ActivityExecution entity was cleared.
func (m *ActivityEntityMutation) ExecutionsCleared() bool {
	return m.clearedexecutions
}

// RemoveExecutionIDs removes the "executions" edge to the ActivityExecution entity by IDs.
func (m *ActivityEntityMutation) RemoveExecutionIDs(ids ...schema.ActivityExecutionID) {
	if m.removedexecutions == nil {
		m.removedexecutions = make(map[schema.ActivityExecutionID]struct{})
	}
	for i := range ids {
		delete(m.executions, ids[i])
		m.removedexecutions[ids[i]] = struct{}{}
	}
}

// RemovedExecutions returns the removed IDs of the "executions" edge to the ActivityExecution entity.
func (m *ActivityEntityMutation) RemovedExecutionsIDs() (ids []schema.ActivityExecutionID) {
	for id := range m.removedexecutions {
		ids = append(ids, id)
	}
	return
}

// ExecutionsIDs returns the "executions" edge IDs in the mutation.
func (m *ActivityEntityMutation) ExecutionsIDs() (ids []schema.ActivityExecutionID) {
	for id := range m.executions {
		ids = append(ids, id)
	}
	return
}

// ResetExecutions resets all changes to the "executions" edge.
func (m *ActivityEntityMutation) ResetExecutions() {
	m.executions = nil
	m.clearedexecutions = false
	m.removedexecutions = nil
}

// Where appends a list predicates to the ActivityEntityMutation builder.
func (m *ActivityEntityMutation) Where(ps ...predicate.ActivityEntity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ActivityEntityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ActivityEntityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ActivityEntity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ActivityEntityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ActivityEntityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ActivityEntity).
func (m *ActivityEntityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActivityEntityMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.handler_name != nil {
		fields = append(fields, activityentity.FieldHandlerName)
	}
	if m._type != nil {
		fields = append(fields, activityentity.FieldType)
	}
	if m.status != nil {
		fields = append(fields, activityentity.FieldStatus)
	}
	if m.step_id != nil {
		fields = append(fields, activityentity.FieldStepID)
	}
	if m.run_id != nil {
		fields = append(fields, activityentity.FieldRunID)
	}
	if m.retry_policy != nil {
		fields = append(fields, activityentity.FieldRetryPolicy)
	}
	if m.retry_state != nil {
		fields = append(fields, activityentity.FieldRetryState)
	}
	if m.created_at != nil {
		fields = append(fields, activityentity.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, activityentity.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActivityEntityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case activityentity.FieldHandlerName:
		return m.HandlerName()
	case activityentity.FieldType:
		return m.GetType()
	case activityentity.FieldStatus:
		return m.Status()
	case activityentity.FieldStepID:
		return m.StepID()
	case activityentity.FieldRunID:
		return m.RunID()
	case activityentity.FieldRetryPolicy:
		return m.RetryPolicy()
	case activityentity.FieldRetryState:
		return m.RetryState()
	case activityentity.FieldCreatedAt:
		return m.CreatedAt()
	case activityentity.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActivityEntityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case activityentity.FieldHandlerName:
		return m.OldHandlerName(ctx)
	case activityentity.FieldType:
		return m.OldType(ctx)
	case activityentity.FieldStatus:
		return m.OldStatus(ctx)
	case activityentity.FieldStepID:
		return m.OldStepID(ctx)
	case activityentity.FieldRunID:
		return m.OldRunID(ctx)
	case activityentity.FieldRetryPolicy:
		return m.OldRetryPolicy(ctx)
	case activityentity.FieldRetryState:
		return m.OldRetryState(ctx)
	case activityentity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case activityentity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ActivityEntity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityEntityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case activityentity.FieldHandlerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandlerName(v)
		return nil
	case activityentity.FieldType:
		v, ok := value.(schema.EntityType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case activityentity.FieldStatus:
		v, ok := value.(schema.EntityStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case activityentity.FieldStepID:
		v, ok := value.(schema.ActivityStepID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStepID(v)
		return nil
	case activityentity.FieldRunID:
		v, ok := value.(schema.RunID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunID(v)
		return nil
	case activityentity.FieldRetryPolicy:
		v, ok := value.(schema.RetryPolicy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryPolicy(v)
		return nil
	case activityentity.FieldRetryState:
		v, ok := value.(schema.RetryState)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryState(v)
		return nil
	case activityentity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case activityentity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ActivityEntity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActivityEntityMutation) AddedFields() []string {
	var fields []string
	if m.addrun_id != nil {
		fields = append(fields, activityentity.FieldRunID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActivityEntityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case activityentity.FieldRunID:
		return m.AddedRunID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityEntityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case activityentity.FieldRunID:
		v, ok := value.(schema.RunID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRunID(v)
		return nil
	}
	return fmt.Errorf("unknown ActivityEntity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActivityEntityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActivityEntityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActivityEntityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ActivityEntity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActivityEntityMutation) ResetField(name string) error {
	switch name {
	case activityentity.FieldHandlerName:
		m.ResetHandlerName()
		return nil
	case activityentity.FieldType:
		m.ResetType()
		return nil
	case activityentity.FieldStatus:
		m.ResetStatus()
		return nil
	case activityentity.FieldStepID:
		m.ResetStepID()
		return nil
	case activityentity.FieldRunID:
		m.ResetRunID()
		return nil
	case activityentity.FieldRetryPolicy:
		m.ResetRetryPolicy()
		return nil
	case activityentity.FieldRetryState:
		m.ResetRetryState()
		return nil
	case activityentity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case activityentity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ActivityEntity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActivityEntityMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.workflow != nil {
		edges = append(edges, activityentity.EdgeWorkflow)
	}
	if m.activity_data != nil {
		edges = append(edges, activityentity.EdgeActivityData)
	}
	if m.executions != nil {
		edges = append(edges, activityentity.EdgeExecutions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActivityEntityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case activityentity.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	case activityentity.EdgeActivityData:
		if id := m.activity_data; id != nil {
			return []ent.Value{*id}
		}
	case activityentity.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.executions))
		for id := range m.executions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActivityEntityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedexecutions != nil {
		edges = append(edges, activityentity.EdgeExecutions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActivityEntityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case activityentity.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.removedexecutions))
		for id := range m.removedexecutions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActivityEntityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedworkflow {
		edges = append(edges, activityentity.EdgeWorkflow)
	}
	if m.clearedactivity_data {
		edges = append(edges, activityentity.EdgeActivityData)
	}
	if m.clearedexecutions {
		edges = append(edges, activityentity.EdgeExecutions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActivityEntityMutation) EdgeCleared(name string) bool {
	switch name {
	case activityentity.EdgeWorkflow:
		return m.clearedworkflow
	case activityentity.EdgeActivityData:
		return m.clearedactivity_data
	case activityentity.EdgeExecutions:
		return m.clearedexecutions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActivityEntityMutation) ClearEdge(name string) error {
	switch name {
	case activityentity.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	case activityentity.EdgeActivityData:
		m.ClearActivityData()
		return nil
	}
	return fmt.Errorf("unknown ActivityEntity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActivityEntityMutation) ResetEdge(name string) error {
	switch name {
	case activityentity.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	case activityentity.EdgeActivityData:
		m.ResetActivityData()
		return nil
	case activityentity.EdgeExecutions:
		m.ResetExecutions()
		return nil
	}
	return fmt.Errorf("unknown ActivityEntity edge %s", name)
}

// ActivityExecutionMutation represents an operation that mutates the ActivityExecution nodes in the graph.
type ActivityExecutionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *schema.ActivityExecutionID
	started_at            *time.Time
	completed_at          *time.Time
	status                *schema.ExecutionStatus
	error                 *string
	stack_trace           *string
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	activity              *schema.ActivityEntityID
	clearedactivity       bool
	execution_data        *schema.ActivityExecutionDataID
	clearedexecution_data bool
	done                  bool
	oldValue              func(context.Context) (*ActivityExecution, error)
	predicates            []predicate.ActivityExecution
}

var _ ent.Mutation = (*ActivityExecutionMutation)(nil)

// activityexecutionOption allows management of the mutation configuration using functional options.
type activityexecutionOption func(*ActivityExecutionMutation)

// newActivityExecutionMutation creates new mutation for the ActivityExecution entity.
func newActivityExecutionMutation(c config, op Op, opts ...activityexecutionOption) *ActivityExecutionMutation {
	m := &ActivityExecutionMutation{
		config:        c,
		op:            op,
		typ:           TypeActivityExecution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActivityExecutionID sets the ID field of the mutation.
func withActivityExecutionID(id schema.ActivityExecutionID) activityexecutionOption {
	return func(m *ActivityExecutionMutation) {
		var (
			err   error
			once  sync.Once
			value *ActivityExecution
		)
		m.oldValue = func(ctx context.Context) (*ActivityExecution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ActivityExecution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActivityExecution sets the old ActivityExecution of the mutation.
func withActivityExecution(node *ActivityExecution) activityexecutionOption {
	return func(m *ActivityExecutionMutation) {
		m.oldValue = func(context.Context) (*ActivityExecution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActivityExecutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActivityExecutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ActivityExecution entities.
func (m *ActivityExecutionMutation) SetID(id schema.ActivityExecutionID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActivityExecutionMutation) ID() (id schema.ActivityExecutionID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActivityExecutionMutation) IDs(ctx context.Context) ([]schema.ActivityExecutionID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []schema.ActivityExecutionID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ActivityExecution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetActivityEntityID sets the "activity_entity_id" field.
func (m *ActivityExecutionMutation) SetActivityEntityID(sei schema.ActivityEntityID) {
	m.activity = &sei
}

// ActivityEntityID returns the value of the "activity_entity_id" field in the mutation.
func (m *ActivityExecutionMutation) ActivityEntityID() (r schema.ActivityEntityID, exists bool) {
	v := m.activity
	if v == nil {
		return
	}
	return *v, true
}

// OldActivityEntityID returns the old "activity_entity_id" field's value of the ActivityExecution entity.
// If the ActivityExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityExecutionMutation) OldActivityEntityID(ctx context.Context) (v schema.ActivityEntityID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActivityEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActivityEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivityEntityID: %w", err)
	}
	return oldValue.ActivityEntityID, nil
}

// ResetActivityEntityID resets all changes to the "activity_entity_id" field.
func (m *ActivityExecutionMutation) ResetActivityEntityID() {
	m.activity = nil
}

// SetStartedAt sets the "started_at" field.
func (m *ActivityExecutionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *ActivityExecutionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the ActivityExecution entity.
// If the ActivityExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityExecutionMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *ActivityExecutionMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetCompletedAt sets the "completed_at" field.
func (m *ActivityExecutionMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *ActivityExecutionMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the ActivityExecution entity.
// If the ActivityExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityExecutionMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *ActivityExecutionMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[activityexecution.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *ActivityExecutionMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[activityexecution.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *ActivityExecutionMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, activityexecution.FieldCompletedAt)
}

// SetStatus sets the "status" field.
func (m *ActivityExecutionMutation) SetStatus(ss schema.ExecutionStatus) {
	m.status = &ss
}

// Status returns the value of the "status" field in the mutation.
func (m *ActivityExecutionMutation) Status() (r schema.ExecutionStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ActivityExecution entity.
// If the ActivityExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityExecutionMutation) OldStatus(ctx context.Context) (v schema.ExecutionStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ActivityExecutionMutation) ResetStatus() {
	m.status = nil
}

// SetError sets the "error" field.
func (m *ActivityExecutionMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *ActivityExecutionMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the ActivityExecution entity.
// If the ActivityExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityExecutionMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *ActivityExecutionMutation) ClearError() {
	m.error = nil
	m.clearedFields[activityexecution.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *ActivityExecutionMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[activityexecution.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *ActivityExecutionMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, activityexecution.FieldError)
}

// SetStackTrace sets the "stack_trace" field.
func (m *ActivityExecutionMutation) SetStackTrace(s string) {
	m.stack_trace = &s
}

// StackTrace returns the value of the "stack_trace" field in the mutation.
func (m *ActivityExecutionMutation) StackTrace() (r string, exists bool) {
	v := m.stack_trace
	if v == nil {
		return
	}
	return *v, true
}

// OldStackTrace returns the old "stack_trace" field's value of the ActivityExecution entity.
// If the ActivityExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityExecutionMutation) OldStackTrace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStackTrace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStackTrace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStackTrace: %w", err)
	}
	return oldValue.StackTrace, nil
}

// ClearStackTrace clears the value of the "stack_trace" field.
func (m *ActivityExecutionMutation) ClearStackTrace() {
	m.stack_trace = nil
	m.clearedFields[activityexecution.FieldStackTrace] = struct{}{}
}

// StackTraceCleared returns if the "stack_trace" field was cleared in this mutation.
func (m *ActivityExecutionMutation) StackTraceCleared() bool {
	_, ok := m.clearedFields[activityexecution.FieldStackTrace]
	return ok
}

// ResetStackTrace resets all changes to the "stack_trace" field.
func (m *ActivityExecutionMutation) ResetStackTrace() {
	m.stack_trace = nil
	delete(m.clearedFields, activityexecution.FieldStackTrace)
}

// SetCreatedAt sets the "created_at" field.
func (m *ActivityExecutionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ActivityExecutionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ActivityExecution entity.
// If the ActivityExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityExecutionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ActivityExecutionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ActivityExecutionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ActivityExecutionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ActivityExecution entity.
// If the ActivityExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityExecutionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ActivityExecutionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetActivityID sets the "activity" edge to the ActivityEntity entity by id.
func (m *ActivityExecutionMutation) SetActivityID(id schema.ActivityEntityID) {
	m.activity = &id
}

// ClearActivity clears the "activity" edge to the ActivityEntity entity.
func (m *ActivityExecutionMutation) ClearActivity() {
	m.clearedactivity = true
	m.clearedFields[activityexecution.FieldActivityEntityID] = struct{}{}
}

// ActivityCleared reports if the "activity" edge to the ActivityEntity entity was cleared.
func (m *ActivityExecutionMutation) ActivityCleared() bool {
	return m.clearedactivity
}

// ActivityID returns the "activity" edge ID in the mutation.
func (m *ActivityExecutionMutation) ActivityID() (id schema.ActivityEntityID, exists bool) {
	if m.activity != nil {
		return *m.activity, true
	}
	return
}

// ActivityIDs returns the "activity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActivityID instead. It exists only for internal usage by the builders.
func (m *ActivityExecutionMutation) ActivityIDs() (ids []schema.ActivityEntityID) {
	if id := m.activity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActivity resets all changes to the "activity" edge.
func (m *ActivityExecutionMutation) ResetActivity() {
	m.activity = nil
	m.clearedactivity = false
}

// SetExecutionDataID sets the "execution_data" edge to the ActivityExecutionData entity by id.
func (m *ActivityExecutionMutation) SetExecutionDataID(id schema.ActivityExecutionDataID) {
	m.execution_data = &id
}

// ClearExecutionData clears the "execution_data" edge to the ActivityExecutionData entity.
func (m *ActivityExecutionMutation) ClearExecutionData() {
	m.clearedexecution_data = true
}

// ExecutionDataCleared reports if the "execution_data" edge to the ActivityExecutionData entity was cleared.
func (m *ActivityExecutionMutation) ExecutionDataCleared() bool {
	return m.clearedexecution_data
}

// ExecutionDataID returns the "execution_data" edge ID in the mutation.
func (m *ActivityExecutionMutation) ExecutionDataID() (id schema.ActivityExecutionDataID, exists bool) {
	if m.execution_data != nil {
		return *m.execution_data, true
	}
	return
}

// ExecutionDataIDs returns the "execution_data" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExecutionDataID instead. It exists only for internal usage by the builders.
func (m *ActivityExecutionMutation) ExecutionDataIDs() (ids []schema.ActivityExecutionDataID) {
	if id := m.execution_data; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExecutionData resets all changes to the "execution_data" edge.
func (m *ActivityExecutionMutation) ResetExecutionData() {
	m.execution_data = nil
	m.clearedexecution_data = false
}

// Where appends a list predicates to the ActivityExecutionMutation builder.
func (m *ActivityExecutionMutation) Where(ps ...predicate.ActivityExecution) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ActivityExecutionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ActivityExecutionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ActivityExecution, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ActivityExecutionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ActivityExecutionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ActivityExecution).
func (m *ActivityExecutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActivityExecutionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.activity != nil {
		fields = append(fields, activityexecution.FieldActivityEntityID)
	}
	if m.started_at != nil {
		fields = append(fields, activityexecution.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, activityexecution.FieldCompletedAt)
	}
	if m.status != nil {
		fields = append(fields, activityexecution.FieldStatus)
	}
	if m.error != nil {
		fields = append(fields, activityexecution.FieldError)
	}
	if m.stack_trace != nil {
		fields = append(fields, activityexecution.FieldStackTrace)
	}
	if m.created_at != nil {
		fields = append(fields, activityexecution.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, activityexecution.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActivityExecutionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case activityexecution.FieldActivityEntityID:
		return m.ActivityEntityID()
	case activityexecution.FieldStartedAt:
		return m.StartedAt()
	case activityexecution.FieldCompletedAt:
		return m.CompletedAt()
	case activityexecution.FieldStatus:
		return m.Status()
	case activityexecution.FieldError:
		return m.Error()
	case activityexecution.FieldStackTrace:
		return m.StackTrace()
	case activityexecution.FieldCreatedAt:
		return m.CreatedAt()
	case activityexecution.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActivityExecutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case activityexecution.FieldActivityEntityID:
		return m.OldActivityEntityID(ctx)
	case activityexecution.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case activityexecution.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case activityexecution.FieldStatus:
		return m.OldStatus(ctx)
	case activityexecution.FieldError:
		return m.OldError(ctx)
	case activityexecution.FieldStackTrace:
		return m.OldStackTrace(ctx)
	case activityexecution.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case activityexecution.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ActivityExecution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityExecutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case activityexecution.FieldActivityEntityID:
		v, ok := value.(schema.ActivityEntityID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivityEntityID(v)
		return nil
	case activityexecution.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case activityexecution.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case activityexecution.FieldStatus:
		v, ok := value.(schema.ExecutionStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case activityexecution.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case activityexecution.FieldStackTrace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStackTrace(v)
		return nil
	case activityexecution.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case activityexecution.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ActivityExecution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActivityExecutionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActivityExecutionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityExecutionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ActivityExecution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActivityExecutionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(activityexecution.FieldCompletedAt) {
		fields = append(fields, activityexecution.FieldCompletedAt)
	}
	if m.FieldCleared(activityexecution.FieldError) {
		fields = append(fields, activityexecution.FieldError)
	}
	if m.FieldCleared(activityexecution.FieldStackTrace) {
		fields = append(fields, activityexecution.FieldStackTrace)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActivityExecutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActivityExecutionMutation) ClearField(name string) error {
	switch name {
	case activityexecution.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	case activityexecution.FieldError:
		m.ClearError()
		return nil
	case activityexecution.FieldStackTrace:
		m.ClearStackTrace()
		return nil
	}
	return fmt.Errorf("unknown ActivityExecution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActivityExecutionMutation) ResetField(name string) error {
	switch name {
	case activityexecution.FieldActivityEntityID:
		m.ResetActivityEntityID()
		return nil
	case activityexecution.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case activityexecution.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case activityexecution.FieldStatus:
		m.ResetStatus()
		return nil
	case activityexecution.FieldError:
		m.ResetError()
		return nil
	case activityexecution.FieldStackTrace:
		m.ResetStackTrace()
		return nil
	case activityexecution.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case activityexecution.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ActivityExecution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActivityExecutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.activity != nil {
		edges = append(edges, activityexecution.EdgeActivity)
	}
	if m.execution_data != nil {
		edges = append(edges, activityexecution.EdgeExecutionData)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActivityExecutionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case activityexecution.EdgeActivity:
		if id := m.activity; id != nil {
			return []ent.Value{*id}
		}
	case activityexecution.EdgeExecutionData:
		if id := m.execution_data; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActivityExecutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActivityExecutionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActivityExecutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedactivity {
		edges = append(edges, activityexecution.EdgeActivity)
	}
	if m.clearedexecution_data {
		edges = append(edges, activityexecution.EdgeExecutionData)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActivityExecutionMutation) EdgeCleared(name string) bool {
	switch name {
	case activityexecution.EdgeActivity:
		return m.clearedactivity
	case activityexecution.EdgeExecutionData:
		return m.clearedexecution_data
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActivityExecutionMutation) ClearEdge(name string) error {
	switch name {
	case activityexecution.EdgeActivity:
		m.ClearActivity()
		return nil
	case activityexecution.EdgeExecutionData:
		m.ClearExecutionData()
		return nil
	}
	return fmt.Errorf("unknown ActivityExecution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActivityExecutionMutation) ResetEdge(name string) error {
	switch name {
	case activityexecution.EdgeActivity:
		m.ResetActivity()
		return nil
	case activityexecution.EdgeExecutionData:
		m.ResetExecutionData()
		return nil
	}
	return fmt.Errorf("unknown ActivityExecution edge %s", name)
}

// ActivityExecutionDataMutation represents an operation that mutates the ActivityExecutionData nodes in the graph.
type ActivityExecutionDataMutation struct {
	config
	op               Op
	typ              string
	id               *schema.ActivityExecutionDataID
	last_heartbeat   *time.Time
	outputs          *[]byte
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	execution        *schema.ActivityExecutionID
	clearedexecution bool
	done             bool
	oldValue         func(context.Context) (*ActivityExecutionData, error)
	predicates       []predicate.ActivityExecutionData
}

var _ ent.Mutation = (*ActivityExecutionDataMutation)(nil)

// activityexecutiondataOption allows management of the mutation configuration using functional options.
type activityexecutiondataOption func(*ActivityExecutionDataMutation)

// newActivityExecutionDataMutation creates new mutation for the ActivityExecutionData entity.
func newActivityExecutionDataMutation(c config, op Op, opts ...activityexecutiondataOption) *ActivityExecutionDataMutation {
	m := &ActivityExecutionDataMutation{
		config:        c,
		op:            op,
		typ:           TypeActivityExecutionData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActivityExecutionDataID sets the ID field of the mutation.
func withActivityExecutionDataID(id schema.ActivityExecutionDataID) activityexecutiondataOption {
	return func(m *ActivityExecutionDataMutation) {
		var (
			err   error
			once  sync.Once
			value *ActivityExecutionData
		)
		m.oldValue = func(ctx context.Context) (*ActivityExecutionData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ActivityExecutionData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActivityExecutionData sets the old ActivityExecutionData of the mutation.
func withActivityExecutionData(node *ActivityExecutionData) activityexecutiondataOption {
	return func(m *ActivityExecutionDataMutation) {
		m.oldValue = func(context.Context) (*ActivityExecutionData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActivityExecutionDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActivityExecutionDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ActivityExecutionData entities.
func (m *ActivityExecutionDataMutation) SetID(id schema.ActivityExecutionDataID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActivityExecutionDataMutation) ID() (id schema.ActivityExecutionDataID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActivityExecutionDataMutation) IDs(ctx context.Context) ([]schema.ActivityExecutionDataID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []schema.ActivityExecutionDataID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ActivityExecutionData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExecutionID sets the "execution_id" field.
func (m *ActivityExecutionDataMutation) SetExecutionID(sei schema.ActivityExecutionID) {
	m.execution = &sei
}

// ExecutionID returns the value of the "execution_id" field in the mutation.
func (m *ActivityExecutionDataMutation) ExecutionID() (r schema.ActivityExecutionID, exists bool) {
	v := m.execution
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutionID returns the old "execution_id" field's value of the ActivityExecutionData entity.
// If the ActivityExecutionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityExecutionDataMutation) OldExecutionID(ctx context.Context) (v schema.ActivityExecutionID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutionID: %w", err)
	}
	return oldValue.ExecutionID, nil
}

// ResetExecutionID resets all changes to the "execution_id" field.
func (m *ActivityExecutionDataMutation) ResetExecutionID() {
	m.execution = nil
}

// SetLastHeartbeat sets the "last_heartbeat" field.
func (m *ActivityExecutionDataMutation) SetLastHeartbeat(t time.Time) {
	m.last_heartbeat = &t
}

// LastHeartbeat returns the value of the "last_heartbeat" field in the mutation.
func (m *ActivityExecutionDataMutation) LastHeartbeat() (r time.Time, exists bool) {
	v := m.last_heartbeat
	if v == nil {
		return
	}
	return *v, true
}

// OldLastHeartbeat returns the old "last_heartbeat" field's value of the ActivityExecutionData entity.
// If the ActivityExecutionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityExecutionDataMutation) OldLastHeartbeat(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastHeartbeat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastHeartbeat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastHeartbeat: %w", err)
	}
	return oldValue.LastHeartbeat, nil
}

// ClearLastHeartbeat clears the value of the "last_heartbeat" field.
func (m *ActivityExecutionDataMutation) ClearLastHeartbeat() {
	m.last_heartbeat = nil
	m.clearedFields[activityexecutiondata.FieldLastHeartbeat] = struct{}{}
}

// LastHeartbeatCleared returns if the "last_heartbeat" field was cleared in this mutation.
func (m *ActivityExecutionDataMutation) LastHeartbeatCleared() bool {
	_, ok := m.clearedFields[activityexecutiondata.FieldLastHeartbeat]
	return ok
}

// ResetLastHeartbeat resets all changes to the "last_heartbeat" field.
func (m *ActivityExecutionDataMutation) ResetLastHeartbeat() {
	m.last_heartbeat = nil
	delete(m.clearedFields, activityexecutiondata.FieldLastHeartbeat)
}

// SetOutputs sets the "outputs" field.
func (m *ActivityExecutionDataMutation) SetOutputs(b []byte) {
	m.outputs = &b
}

// Outputs returns the value of the "outputs" field in the mutation.
func (m *ActivityExecutionDataMutation) Outputs() (r []byte, exists bool) {
	v := m.outputs
	if v == nil {
		return
	}
	return *v, true
}

// OldOutputs returns the old "outputs" field's value of the ActivityExecutionData entity.
// If the ActivityExecutionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityExecutionDataMutation) OldOutputs(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutputs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutputs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutputs: %w", err)
	}
	return oldValue.Outputs, nil
}

// ClearOutputs clears the value of the "outputs" field.
func (m *ActivityExecutionDataMutation) ClearOutputs() {
	m.outputs = nil
	m.clearedFields[activityexecutiondata.FieldOutputs] = struct{}{}
}

// OutputsCleared returns if the "outputs" field was cleared in this mutation.
func (m *ActivityExecutionDataMutation) OutputsCleared() bool {
	_, ok := m.clearedFields[activityexecutiondata.FieldOutputs]
	return ok
}

// ResetOutputs resets all changes to the "outputs" field.
func (m *ActivityExecutionDataMutation) ResetOutputs() {
	m.outputs = nil
	delete(m.clearedFields, activityexecutiondata.FieldOutputs)
}

// SetCreatedAt sets the "created_at" field.
func (m *ActivityExecutionDataMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ActivityExecutionDataMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ActivityExecutionData entity.
// If the ActivityExecutionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityExecutionDataMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ActivityExecutionDataMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ActivityExecutionDataMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ActivityExecutionDataMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ActivityExecutionData entity.
// If the ActivityExecutionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityExecutionDataMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ActivityExecutionDataMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearExecution clears the "execution" edge to the ActivityExecution entity.
func (m *ActivityExecutionDataMutation) ClearExecution() {
	m.clearedexecution = true
	m.clearedFields[activityexecutiondata.FieldExecutionID] = struct{}{}
}

// ExecutionCleared reports if the "execution" edge to the ActivityExecution entity was cleared.
func (m *ActivityExecutionDataMutation) ExecutionCleared() bool {
	return m.clearedexecution
}

// ExecutionIDs returns the "execution" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExecutionID instead. It exists only for internal usage by the builders.
func (m *ActivityExecutionDataMutation) ExecutionIDs() (ids []schema.ActivityExecutionID) {
	if id := m.execution; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExecution resets all changes to the "execution" edge.
func (m *ActivityExecutionDataMutation) ResetExecution() {
	m.execution = nil
	m.clearedexecution = false
}

// Where appends a list predicates to the ActivityExecutionDataMutation builder.
func (m *ActivityExecutionDataMutation) Where(ps ...predicate.ActivityExecutionData) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ActivityExecutionDataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ActivityExecutionDataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ActivityExecutionData, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ActivityExecutionDataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ActivityExecutionDataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ActivityExecutionData).
func (m *ActivityExecutionDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActivityExecutionDataMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.execution != nil {
		fields = append(fields, activityexecutiondata.FieldExecutionID)
	}
	if m.last_heartbeat != nil {
		fields = append(fields, activityexecutiondata.FieldLastHeartbeat)
	}
	if m.outputs != nil {
		fields = append(fields, activityexecutiondata.FieldOutputs)
	}
	if m.created_at != nil {
		fields = append(fields, activityexecutiondata.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, activityexecutiondata.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActivityExecutionDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case activityexecutiondata.FieldExecutionID:
		return m.ExecutionID()
	case activityexecutiondata.FieldLastHeartbeat:
		return m.LastHeartbeat()
	case activityexecutiondata.FieldOutputs:
		return m.Outputs()
	case activityexecutiondata.FieldCreatedAt:
		return m.CreatedAt()
	case activityexecutiondata.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActivityExecutionDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case activityexecutiondata.FieldExecutionID:
		return m.OldExecutionID(ctx)
	case activityexecutiondata.FieldLastHeartbeat:
		return m.OldLastHeartbeat(ctx)
	case activityexecutiondata.FieldOutputs:
		return m.OldOutputs(ctx)
	case activityexecutiondata.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case activityexecutiondata.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ActivityExecutionData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityExecutionDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case activityexecutiondata.FieldExecutionID:
		v, ok := value.(schema.ActivityExecutionID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutionID(v)
		return nil
	case activityexecutiondata.FieldLastHeartbeat:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastHeartbeat(v)
		return nil
	case activityexecutiondata.FieldOutputs:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutputs(v)
		return nil
	case activityexecutiondata.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case activityexecutiondata.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ActivityExecutionData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActivityExecutionDataMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActivityExecutionDataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityExecutionDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ActivityExecutionData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActivityExecutionDataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(activityexecutiondata.FieldLastHeartbeat) {
		fields = append(fields, activityexecutiondata.FieldLastHeartbeat)
	}
	if m.FieldCleared(activityexecutiondata.FieldOutputs) {
		fields = append(fields, activityexecutiondata.FieldOutputs)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActivityExecutionDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActivityExecutionDataMutation) ClearField(name string) error {
	switch name {
	case activityexecutiondata.FieldLastHeartbeat:
		m.ClearLastHeartbeat()
		return nil
	case activityexecutiondata.FieldOutputs:
		m.ClearOutputs()
		return nil
	}
	return fmt.Errorf("unknown ActivityExecutionData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActivityExecutionDataMutation) ResetField(name string) error {
	switch name {
	case activityexecutiondata.FieldExecutionID:
		m.ResetExecutionID()
		return nil
	case activityexecutiondata.FieldLastHeartbeat:
		m.ResetLastHeartbeat()
		return nil
	case activityexecutiondata.FieldOutputs:
		m.ResetOutputs()
		return nil
	case activityexecutiondata.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case activityexecutiondata.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ActivityExecutionData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActivityExecutionDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.execution != nil {
		edges = append(edges, activityexecutiondata.EdgeExecution)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActivityExecutionDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case activityexecutiondata.EdgeExecution:
		if id := m.execution; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActivityExecutionDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActivityExecutionDataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActivityExecutionDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedexecution {
		edges = append(edges, activityexecutiondata.EdgeExecution)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActivityExecutionDataMutation) EdgeCleared(name string) bool {
	switch name {
	case activityexecutiondata.EdgeExecution:
		return m.clearedexecution
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActivityExecutionDataMutation) ClearEdge(name string) error {
	switch name {
	case activityexecutiondata.EdgeExecution:
		m.ClearExecution()
		return nil
	}
	return fmt.Errorf("unknown ActivityExecutionData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActivityExecutionDataMutation) ResetEdge(name string) error {
	switch name {
	case activityexecutiondata.EdgeExecution:
		m.ResetExecution()
		return nil
	}
	return fmt.Errorf("unknown ActivityExecutionData edge %s", name)
}

// HierarchyMutation represents an operation that mutates the Hierarchy nodes in the graph.
type HierarchyMutation struct {
	config
	op                     Op
	typ                    string
	id                     *schema.HierarchyID
	parent_entity_id       *int
	addparent_entity_id    *int
	child_entity_id        *int
	addchild_entity_id     *int
	parent_execution_id    *int
	addparent_execution_id *int
	child_execution_id     *int
	addchild_execution_id  *int
	parent_step_id         *string
	child_step_id          *string
	parent_type            *schema.EntityType
	child_type             *schema.EntityType
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	run                    *schema.RunID
	clearedrun             bool
	done                   bool
	oldValue               func(context.Context) (*Hierarchy, error)
	predicates             []predicate.Hierarchy
}

var _ ent.Mutation = (*HierarchyMutation)(nil)

// hierarchyOption allows management of the mutation configuration using functional options.
type hierarchyOption func(*HierarchyMutation)

// newHierarchyMutation creates new mutation for the Hierarchy entity.
func newHierarchyMutation(c config, op Op, opts ...hierarchyOption) *HierarchyMutation {
	m := &HierarchyMutation{
		config:        c,
		op:            op,
		typ:           TypeHierarchy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHierarchyID sets the ID field of the mutation.
func withHierarchyID(id schema.HierarchyID) hierarchyOption {
	return func(m *HierarchyMutation) {
		var (
			err   error
			once  sync.Once
			value *Hierarchy
		)
		m.oldValue = func(ctx context.Context) (*Hierarchy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Hierarchy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHierarchy sets the old Hierarchy of the mutation.
func withHierarchy(node *Hierarchy) hierarchyOption {
	return func(m *HierarchyMutation) {
		m.oldValue = func(context.Context) (*Hierarchy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HierarchyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HierarchyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Hierarchy entities.
func (m *HierarchyMutation) SetID(id schema.HierarchyID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HierarchyMutation) ID() (id schema.HierarchyID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HierarchyMutation) IDs(ctx context.Context) ([]schema.HierarchyID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []schema.HierarchyID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Hierarchy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRunID sets the "run_id" field.
func (m *HierarchyMutation) SetRunID(si schema.RunID) {
	m.run = &si
}

// RunID returns the value of the "run_id" field in the mutation.
func (m *HierarchyMutation) RunID() (r schema.RunID, exists bool) {
	v := m.run
	if v == nil {
		return
	}
	return *v, true
}

// OldRunID returns the old "run_id" field's value of the Hierarchy entity.
// If the Hierarchy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HierarchyMutation) OldRunID(ctx context.Context) (v schema.RunID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunID: %w", err)
	}
	return oldValue.RunID, nil
}

// ResetRunID resets all changes to the "run_id" field.
func (m *HierarchyMutation) ResetRunID() {
	m.run = nil
}

// SetParentEntityID sets the "parent_entity_id" field.
func (m *HierarchyMutation) SetParentEntityID(i int) {
	m.parent_entity_id = &i
	m.addparent_entity_id = nil
}

// ParentEntityID returns the value of the "parent_entity_id" field in the mutation.
func (m *HierarchyMutation) ParentEntityID() (r int, exists bool) {
	v := m.parent_entity_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentEntityID returns the old "parent_entity_id" field's value of the Hierarchy entity.
// If the Hierarchy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HierarchyMutation) OldParentEntityID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentEntityID: %w", err)
	}
	return oldValue.ParentEntityID, nil
}

// AddParentEntityID adds i to the "parent_entity_id" field.
func (m *HierarchyMutation) AddParentEntityID(i int) {
	if m.addparent_entity_id != nil {
		*m.addparent_entity_id += i
	} else {
		m.addparent_entity_id = &i
	}
}

// AddedParentEntityID returns the value that was added to the "parent_entity_id" field in this mutation.
func (m *HierarchyMutation) AddedParentEntityID() (r int, exists bool) {
	v := m.addparent_entity_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetParentEntityID resets all changes to the "parent_entity_id" field.
func (m *HierarchyMutation) ResetParentEntityID() {
	m.parent_entity_id = nil
	m.addparent_entity_id = nil
}

// SetChildEntityID sets the "child_entity_id" field.
func (m *HierarchyMutation) SetChildEntityID(i int) {
	m.child_entity_id = &i
	m.addchild_entity_id = nil
}

// ChildEntityID returns the value of the "child_entity_id" field in the mutation.
func (m *HierarchyMutation) ChildEntityID() (r int, exists bool) {
	v := m.child_entity_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChildEntityID returns the old "child_entity_id" field's value of the Hierarchy entity.
// If the Hierarchy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HierarchyMutation) OldChildEntityID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChildEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChildEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChildEntityID: %w", err)
	}
	return oldValue.ChildEntityID, nil
}

// AddChildEntityID adds i to the "child_entity_id" field.
func (m *HierarchyMutation) AddChildEntityID(i int) {
	if m.addchild_entity_id != nil {
		*m.addchild_entity_id += i
	} else {
		m.addchild_entity_id = &i
	}
}

// AddedChildEntityID returns the value that was added to the "child_entity_id" field in this mutation.
func (m *HierarchyMutation) AddedChildEntityID() (r int, exists bool) {
	v := m.addchild_entity_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetChildEntityID resets all changes to the "child_entity_id" field.
func (m *HierarchyMutation) ResetChildEntityID() {
	m.child_entity_id = nil
	m.addchild_entity_id = nil
}

// SetParentExecutionID sets the "parent_execution_id" field.
func (m *HierarchyMutation) SetParentExecutionID(i int) {
	m.parent_execution_id = &i
	m.addparent_execution_id = nil
}

// ParentExecutionID returns the value of the "parent_execution_id" field in the mutation.
func (m *HierarchyMutation) ParentExecutionID() (r int, exists bool) {
	v := m.parent_execution_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentExecutionID returns the old "parent_execution_id" field's value of the Hierarchy entity.
// If the Hierarchy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HierarchyMutation) OldParentExecutionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentExecutionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentExecutionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentExecutionID: %w", err)
	}
	return oldValue.ParentExecutionID, nil
}

// AddParentExecutionID adds i to the "parent_execution_id" field.
func (m *HierarchyMutation) AddParentExecutionID(i int) {
	if m.addparent_execution_id != nil {
		*m.addparent_execution_id += i
	} else {
		m.addparent_execution_id = &i
	}
}

// AddedParentExecutionID returns the value that was added to the "parent_execution_id" field in this mutation.
func (m *HierarchyMutation) AddedParentExecutionID() (r int, exists bool) {
	v := m.addparent_execution_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetParentExecutionID resets all changes to the "parent_execution_id" field.
func (m *HierarchyMutation) ResetParentExecutionID() {
	m.parent_execution_id = nil
	m.addparent_execution_id = nil
}

// SetChildExecutionID sets the "child_execution_id" field.
func (m *HierarchyMutation) SetChildExecutionID(i int) {
	m.child_execution_id = &i
	m.addchild_execution_id = nil
}

// ChildExecutionID returns the value of the "child_execution_id" field in the mutation.
func (m *HierarchyMutation) ChildExecutionID() (r int, exists bool) {
	v := m.child_execution_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChildExecutionID returns the old "child_execution_id" field's value of the Hierarchy entity.
// If the Hierarchy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HierarchyMutation) OldChildExecutionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChildExecutionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChildExecutionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChildExecutionID: %w", err)
	}
	return oldValue.ChildExecutionID, nil
}

// AddChildExecutionID adds i to the "child_execution_id" field.
func (m *HierarchyMutation) AddChildExecutionID(i int) {
	if m.addchild_execution_id != nil {
		*m.addchild_execution_id += i
	} else {
		m.addchild_execution_id = &i
	}
}

// AddedChildExecutionID returns the value that was added to the "child_execution_id" field in this mutation.
func (m *HierarchyMutation) AddedChildExecutionID() (r int, exists bool) {
	v := m.addchild_execution_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetChildExecutionID resets all changes to the "child_execution_id" field.
func (m *HierarchyMutation) ResetChildExecutionID() {
	m.child_execution_id = nil
	m.addchild_execution_id = nil
}

// SetParentStepID sets the "parent_step_id" field.
func (m *HierarchyMutation) SetParentStepID(s string) {
	m.parent_step_id = &s
}

// ParentStepID returns the value of the "parent_step_id" field in the mutation.
func (m *HierarchyMutation) ParentStepID() (r string, exists bool) {
	v := m.parent_step_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentStepID returns the old "parent_step_id" field's value of the Hierarchy entity.
// If the Hierarchy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HierarchyMutation) OldParentStepID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentStepID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentStepID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentStepID: %w", err)
	}
	return oldValue.ParentStepID, nil
}

// ResetParentStepID resets all changes to the "parent_step_id" field.
func (m *HierarchyMutation) ResetParentStepID() {
	m.parent_step_id = nil
}

// SetChildStepID sets the "child_step_id" field.
func (m *HierarchyMutation) SetChildStepID(s string) {
	m.child_step_id = &s
}

// ChildStepID returns the value of the "child_step_id" field in the mutation.
func (m *HierarchyMutation) ChildStepID() (r string, exists bool) {
	v := m.child_step_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChildStepID returns the old "child_step_id" field's value of the Hierarchy entity.
// If the Hierarchy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HierarchyMutation) OldChildStepID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChildStepID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChildStepID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChildStepID: %w", err)
	}
	return oldValue.ChildStepID, nil
}

// ResetChildStepID resets all changes to the "child_step_id" field.
func (m *HierarchyMutation) ResetChildStepID() {
	m.child_step_id = nil
}

// SetParentType sets the "parent_type" field.
func (m *HierarchyMutation) SetParentType(st schema.EntityType) {
	m.parent_type = &st
}

// ParentType returns the value of the "parent_type" field in the mutation.
func (m *HierarchyMutation) ParentType() (r schema.EntityType, exists bool) {
	v := m.parent_type
	if v == nil {
		return
	}
	return *v, true
}

// OldParentType returns the old "parent_type" field's value of the Hierarchy entity.
// If the Hierarchy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HierarchyMutation) OldParentType(ctx context.Context) (v schema.EntityType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentType: %w", err)
	}
	return oldValue.ParentType, nil
}

// ResetParentType resets all changes to the "parent_type" field.
func (m *HierarchyMutation) ResetParentType() {
	m.parent_type = nil
}

// SetChildType sets the "child_type" field.
func (m *HierarchyMutation) SetChildType(st schema.EntityType) {
	m.child_type = &st
}

// ChildType returns the value of the "child_type" field in the mutation.
func (m *HierarchyMutation) ChildType() (r schema.EntityType, exists bool) {
	v := m.child_type
	if v == nil {
		return
	}
	return *v, true
}

// OldChildType returns the old "child_type" field's value of the Hierarchy entity.
// If the Hierarchy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HierarchyMutation) OldChildType(ctx context.Context) (v schema.EntityType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChildType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChildType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChildType: %w", err)
	}
	return oldValue.ChildType, nil
}

// ResetChildType resets all changes to the "child_type" field.
func (m *HierarchyMutation) ResetChildType() {
	m.child_type = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *HierarchyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HierarchyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Hierarchy entity.
// If the Hierarchy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HierarchyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HierarchyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HierarchyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HierarchyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Hierarchy entity.
// If the Hierarchy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HierarchyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HierarchyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearRun clears the "run" edge to the Run entity.
func (m *HierarchyMutation) ClearRun() {
	m.clearedrun = true
	m.clearedFields[hierarchy.FieldRunID] = struct{}{}
}

// RunCleared reports if the "run" edge to the Run entity was cleared.
func (m *HierarchyMutation) RunCleared() bool {
	return m.clearedrun
}

// RunIDs returns the "run" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RunID instead. It exists only for internal usage by the builders.
func (m *HierarchyMutation) RunIDs() (ids []schema.RunID) {
	if id := m.run; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRun resets all changes to the "run" edge.
func (m *HierarchyMutation) ResetRun() {
	m.run = nil
	m.clearedrun = false
}

// Where appends a list predicates to the HierarchyMutation builder.
func (m *HierarchyMutation) Where(ps ...predicate.Hierarchy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HierarchyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HierarchyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Hierarchy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HierarchyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HierarchyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Hierarchy).
func (m *HierarchyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HierarchyMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.run != nil {
		fields = append(fields, hierarchy.FieldRunID)
	}
	if m.parent_entity_id != nil {
		fields = append(fields, hierarchy.FieldParentEntityID)
	}
	if m.child_entity_id != nil {
		fields = append(fields, hierarchy.FieldChildEntityID)
	}
	if m.parent_execution_id != nil {
		fields = append(fields, hierarchy.FieldParentExecutionID)
	}
	if m.child_execution_id != nil {
		fields = append(fields, hierarchy.FieldChildExecutionID)
	}
	if m.parent_step_id != nil {
		fields = append(fields, hierarchy.FieldParentStepID)
	}
	if m.child_step_id != nil {
		fields = append(fields, hierarchy.FieldChildStepID)
	}
	if m.parent_type != nil {
		fields = append(fields, hierarchy.FieldParentType)
	}
	if m.child_type != nil {
		fields = append(fields, hierarchy.FieldChildType)
	}
	if m.created_at != nil {
		fields = append(fields, hierarchy.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, hierarchy.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HierarchyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hierarchy.FieldRunID:
		return m.RunID()
	case hierarchy.FieldParentEntityID:
		return m.ParentEntityID()
	case hierarchy.FieldChildEntityID:
		return m.ChildEntityID()
	case hierarchy.FieldParentExecutionID:
		return m.ParentExecutionID()
	case hierarchy.FieldChildExecutionID:
		return m.ChildExecutionID()
	case hierarchy.FieldParentStepID:
		return m.ParentStepID()
	case hierarchy.FieldChildStepID:
		return m.ChildStepID()
	case hierarchy.FieldParentType:
		return m.ParentType()
	case hierarchy.FieldChildType:
		return m.ChildType()
	case hierarchy.FieldCreatedAt:
		return m.CreatedAt()
	case hierarchy.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HierarchyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hierarchy.FieldRunID:
		return m.OldRunID(ctx)
	case hierarchy.FieldParentEntityID:
		return m.OldParentEntityID(ctx)
	case hierarchy.FieldChildEntityID:
		return m.OldChildEntityID(ctx)
	case hierarchy.FieldParentExecutionID:
		return m.OldParentExecutionID(ctx)
	case hierarchy.FieldChildExecutionID:
		return m.OldChildExecutionID(ctx)
	case hierarchy.FieldParentStepID:
		return m.OldParentStepID(ctx)
	case hierarchy.FieldChildStepID:
		return m.OldChildStepID(ctx)
	case hierarchy.FieldParentType:
		return m.OldParentType(ctx)
	case hierarchy.FieldChildType:
		return m.OldChildType(ctx)
	case hierarchy.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case hierarchy.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Hierarchy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HierarchyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hierarchy.FieldRunID:
		v, ok := value.(schema.RunID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunID(v)
		return nil
	case hierarchy.FieldParentEntityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentEntityID(v)
		return nil
	case hierarchy.FieldChildEntityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChildEntityID(v)
		return nil
	case hierarchy.FieldParentExecutionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentExecutionID(v)
		return nil
	case hierarchy.FieldChildExecutionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChildExecutionID(v)
		return nil
	case hierarchy.FieldParentStepID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentStepID(v)
		return nil
	case hierarchy.FieldChildStepID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChildStepID(v)
		return nil
	case hierarchy.FieldParentType:
		v, ok := value.(schema.EntityType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentType(v)
		return nil
	case hierarchy.FieldChildType:
		v, ok := value.(schema.EntityType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChildType(v)
		return nil
	case hierarchy.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case hierarchy.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Hierarchy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HierarchyMutation) AddedFields() []string {
	var fields []string
	if m.addparent_entity_id != nil {
		fields = append(fields, hierarchy.FieldParentEntityID)
	}
	if m.addchild_entity_id != nil {
		fields = append(fields, hierarchy.FieldChildEntityID)
	}
	if m.addparent_execution_id != nil {
		fields = append(fields, hierarchy.FieldParentExecutionID)
	}
	if m.addchild_execution_id != nil {
		fields = append(fields, hierarchy.FieldChildExecutionID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HierarchyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hierarchy.FieldParentEntityID:
		return m.AddedParentEntityID()
	case hierarchy.FieldChildEntityID:
		return m.AddedChildEntityID()
	case hierarchy.FieldParentExecutionID:
		return m.AddedParentExecutionID()
	case hierarchy.FieldChildExecutionID:
		return m.AddedChildExecutionID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HierarchyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hierarchy.FieldParentEntityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParentEntityID(v)
		return nil
	case hierarchy.FieldChildEntityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChildEntityID(v)
		return nil
	case hierarchy.FieldParentExecutionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParentExecutionID(v)
		return nil
	case hierarchy.FieldChildExecutionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChildExecutionID(v)
		return nil
	}
	return fmt.Errorf("unknown Hierarchy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HierarchyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HierarchyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HierarchyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Hierarchy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HierarchyMutation) ResetField(name string) error {
	switch name {
	case hierarchy.FieldRunID:
		m.ResetRunID()
		return nil
	case hierarchy.FieldParentEntityID:
		m.ResetParentEntityID()
		return nil
	case hierarchy.FieldChildEntityID:
		m.ResetChildEntityID()
		return nil
	case hierarchy.FieldParentExecutionID:
		m.ResetParentExecutionID()
		return nil
	case hierarchy.FieldChildExecutionID:
		m.ResetChildExecutionID()
		return nil
	case hierarchy.FieldParentStepID:
		m.ResetParentStepID()
		return nil
	case hierarchy.FieldChildStepID:
		m.ResetChildStepID()
		return nil
	case hierarchy.FieldParentType:
		m.ResetParentType()
		return nil
	case hierarchy.FieldChildType:
		m.ResetChildType()
		return nil
	case hierarchy.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case hierarchy.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Hierarchy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HierarchyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.run != nil {
		edges = append(edges, hierarchy.EdgeRun)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HierarchyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hierarchy.EdgeRun:
		if id := m.run; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HierarchyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HierarchyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HierarchyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrun {
		edges = append(edges, hierarchy.EdgeRun)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HierarchyMutation) EdgeCleared(name string) bool {
	switch name {
	case hierarchy.EdgeRun:
		return m.clearedrun
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HierarchyMutation) ClearEdge(name string) error {
	switch name {
	case hierarchy.EdgeRun:
		m.ClearRun()
		return nil
	}
	return fmt.Errorf("unknown Hierarchy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HierarchyMutation) ResetEdge(name string) error {
	switch name {
	case hierarchy.EdgeRun:
		m.ResetRun()
		return nil
	}
	return fmt.Errorf("unknown Hierarchy edge %s", name)
}

// QueueMutation represents an operation that mutates the Queue nodes in the graph.
type QueueMutation struct {
	config
	op              Op
	typ             string
	id              *schema.QueueID
	name            *string
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	entities        map[schema.WorkflowEntityID]struct{}
	removedentities map[schema.WorkflowEntityID]struct{}
	clearedentities bool
	done            bool
	oldValue        func(context.Context) (*Queue, error)
	predicates      []predicate.Queue
}

var _ ent.Mutation = (*QueueMutation)(nil)

// queueOption allows management of the mutation configuration using functional options.
type queueOption func(*QueueMutation)

// newQueueMutation creates new mutation for the Queue entity.
func newQueueMutation(c config, op Op, opts ...queueOption) *QueueMutation {
	m := &QueueMutation{
		config:        c,
		op:            op,
		typ:           TypeQueue,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withQueueID sets the ID field of the mutation.
func withQueueID(id schema.QueueID) queueOption {
	return func(m *QueueMutation) {
		var (
			err   error
			once  sync.Once
			value *Queue
		)
		m.oldValue = func(ctx context.Context) (*Queue, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Queue.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withQueue sets the old Queue of the mutation.
func withQueue(node *Queue) queueOption {
	return func(m *QueueMutation) {
		m.oldValue = func(context.Context) (*Queue, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m QueueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m QueueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Queue entities.
func (m *QueueMutation) SetID(id schema.QueueID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *QueueMutation) ID() (id schema.QueueID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *QueueMutation) IDs(ctx context.Context) ([]schema.QueueID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []schema.QueueID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Queue.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *QueueMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *QueueMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Queue entity.
// If the Queue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QueueMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *QueueMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *QueueMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *QueueMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Queue entity.
// If the Queue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QueueMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *QueueMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *QueueMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *QueueMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Queue entity.
// If the Queue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QueueMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *QueueMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddEntityIDs adds the "entities" edge to the WorkflowEntity entity by ids.
func (m *QueueMutation) AddEntityIDs(ids ...schema.WorkflowEntityID) {
	if m.entities == nil {
		m.entities = make(map[schema.WorkflowEntityID]struct{})
	}
	for i := range ids {
		m.entities[ids[i]] = struct{}{}
	}
}

// ClearEntities clears the "entities" edge to the WorkflowEntity entity.
func (m *QueueMutation) ClearEntities() {
	m.clearedentities = true
}

// EntitiesCleared reports if the "entities" edge to the WorkflowEntity entity was cleared.
func (m *QueueMutation) EntitiesCleared() bool {
	return m.clearedentities
}

// RemoveEntityIDs removes the "entities" edge to the WorkflowEntity entity by IDs.
func (m *QueueMutation) RemoveEntityIDs(ids ...schema.WorkflowEntityID) {
	if m.removedentities == nil {
		m.removedentities = make(map[schema.WorkflowEntityID]struct{})
	}
	for i := range ids {
		delete(m.entities, ids[i])
		m.removedentities[ids[i]] = struct{}{}
	}
}

// RemovedEntities returns the removed IDs of the "entities" edge to the WorkflowEntity entity.
func (m *QueueMutation) RemovedEntitiesIDs() (ids []schema.WorkflowEntityID) {
	for id := range m.removedentities {
		ids = append(ids, id)
	}
	return
}

// EntitiesIDs returns the "entities" edge IDs in the mutation.
func (m *QueueMutation) EntitiesIDs() (ids []schema.WorkflowEntityID) {
	for id := range m.entities {
		ids = append(ids, id)
	}
	return
}

// ResetEntities resets all changes to the "entities" edge.
func (m *QueueMutation) ResetEntities() {
	m.entities = nil
	m.clearedentities = false
	m.removedentities = nil
}

// Where appends a list predicates to the QueueMutation builder.
func (m *QueueMutation) Where(ps ...predicate.Queue) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the QueueMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *QueueMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Queue, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *QueueMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *QueueMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Queue).
func (m *QueueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *QueueMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, queue.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, queue.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, queue.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *QueueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case queue.FieldName:
		return m.Name()
	case queue.FieldCreatedAt:
		return m.CreatedAt()
	case queue.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *QueueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case queue.FieldName:
		return m.OldName(ctx)
	case queue.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case queue.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Queue field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QueueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case queue.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case queue.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case queue.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Queue field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *QueueMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *QueueMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QueueMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Queue numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *QueueMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *QueueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *QueueMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Queue nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *QueueMutation) ResetField(name string) error {
	switch name {
	case queue.FieldName:
		m.ResetName()
		return nil
	case queue.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case queue.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Queue field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *QueueMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.entities != nil {
		edges = append(edges, queue.EdgeEntities)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *QueueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case queue.EdgeEntities:
		ids := make([]ent.Value, 0, len(m.entities))
		for id := range m.entities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *QueueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedentities != nil {
		edges = append(edges, queue.EdgeEntities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *QueueMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case queue.EdgeEntities:
		ids := make([]ent.Value, 0, len(m.removedentities))
		for id := range m.removedentities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *QueueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedentities {
		edges = append(edges, queue.EdgeEntities)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *QueueMutation) EdgeCleared(name string) bool {
	switch name {
	case queue.EdgeEntities:
		return m.clearedentities
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *QueueMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Queue unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *QueueMutation) ResetEdge(name string) error {
	switch name {
	case queue.EdgeEntities:
		m.ResetEntities()
		return nil
	}
	return fmt.Errorf("unknown Queue edge %s", name)
}

// RunMutation represents an operation that mutates the Run nodes in the graph.
type RunMutation struct {
	config
	op                 Op
	typ                string
	id                 *schema.RunID
	status             *schema.RunStatus
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	workflows          map[schema.WorkflowEntityID]struct{}
	removedworkflows   map[schema.WorkflowEntityID]struct{}
	clearedworkflows   bool
	hierarchies        map[schema.HierarchyID]struct{}
	removedhierarchies map[schema.HierarchyID]struct{}
	clearedhierarchies bool
	done               bool
	oldValue           func(context.Context) (*Run, error)
	predicates         []predicate.Run
}

var _ ent.Mutation = (*RunMutation)(nil)

// runOption allows management of the mutation configuration using functional options.
type runOption func(*RunMutation)

// newRunMutation creates new mutation for the Run entity.
func newRunMutation(c config, op Op, opts ...runOption) *RunMutation {
	m := &RunMutation{
		config:        c,
		op:            op,
		typ:           TypeRun,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRunID sets the ID field of the mutation.
func withRunID(id schema.RunID) runOption {
	return func(m *RunMutation) {
		var (
			err   error
			once  sync.Once
			value *Run
		)
		m.oldValue = func(ctx context.Context) (*Run, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Run.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRun sets the old Run of the mutation.
func withRun(node *Run) runOption {
	return func(m *RunMutation) {
		m.oldValue = func(context.Context) (*Run, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RunMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RunMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Run entities.
func (m *RunMutation) SetID(id schema.RunID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RunMutation) ID() (id schema.RunID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RunMutation) IDs(ctx context.Context) ([]schema.RunID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []schema.RunID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Run.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *RunMutation) SetStatus(ss schema.RunStatus) {
	m.status = &ss
}

// Status returns the value of the "status" field in the mutation.
func (m *RunMutation) Status() (r schema.RunStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Run entity.
// If the Run object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunMutation) OldStatus(ctx context.Context) (v schema.RunStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RunMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RunMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RunMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Run entity.
// If the Run object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RunMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RunMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RunMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Run entity.
// If the Run object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RunMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddWorkflowIDs adds the "workflows" edge to the WorkflowEntity entity by ids.
func (m *RunMutation) AddWorkflowIDs(ids ...schema.WorkflowEntityID) {
	if m.workflows == nil {
		m.workflows = make(map[schema.WorkflowEntityID]struct{})
	}
	for i := range ids {
		m.workflows[ids[i]] = struct{}{}
	}
}

// ClearWorkflows clears the "workflows" edge to the WorkflowEntity entity.
func (m *RunMutation) ClearWorkflows() {
	m.clearedworkflows = true
}

// WorkflowsCleared reports if the "workflows" edge to the WorkflowEntity entity was cleared.
func (m *RunMutation) WorkflowsCleared() bool {
	return m.clearedworkflows
}

// RemoveWorkflowIDs removes the "workflows" edge to the WorkflowEntity entity by IDs.
func (m *RunMutation) RemoveWorkflowIDs(ids ...schema.WorkflowEntityID) {
	if m.removedworkflows == nil {
		m.removedworkflows = make(map[schema.WorkflowEntityID]struct{})
	}
	for i := range ids {
		delete(m.workflows, ids[i])
		m.removedworkflows[ids[i]] = struct{}{}
	}
}

// RemovedWorkflows returns the removed IDs of the "workflows" edge to the WorkflowEntity entity.
func (m *RunMutation) RemovedWorkflowsIDs() (ids []schema.WorkflowEntityID) {
	for id := range m.removedworkflows {
		ids = append(ids, id)
	}
	return
}

// WorkflowsIDs returns the "workflows" edge IDs in the mutation.
func (m *RunMutation) WorkflowsIDs() (ids []schema.WorkflowEntityID) {
	for id := range m.workflows {
		ids = append(ids, id)
	}
	return
}

// ResetWorkflows resets all changes to the "workflows" edge.
func (m *RunMutation) ResetWorkflows() {
	m.workflows = nil
	m.clearedworkflows = false
	m.removedworkflows = nil
}

// AddHierarchyIDs adds the "hierarchies" edge to the Hierarchy entity by ids.
func (m *RunMutation) AddHierarchyIDs(ids ...schema.HierarchyID) {
	if m.hierarchies == nil {
		m.hierarchies = make(map[schema.HierarchyID]struct{})
	}
	for i := range ids {
		m.hierarchies[ids[i]] = struct{}{}
	}
}

// ClearHierarchies clears the "hierarchies" edge to the Hierarchy entity.
func (m *RunMutation) ClearHierarchies() {
	m.clearedhierarchies = true
}

// HierarchiesCleared reports if the "hierarchies" edge to the Hierarchy entity was cleared.
func (m *RunMutation) HierarchiesCleared() bool {
	return m.clearedhierarchies
}

// RemoveHierarchyIDs removes the "hierarchies" edge to the Hierarchy entity by IDs.
func (m *RunMutation) RemoveHierarchyIDs(ids ...schema.HierarchyID) {
	if m.removedhierarchies == nil {
		m.removedhierarchies = make(map[schema.HierarchyID]struct{})
	}
	for i := range ids {
		delete(m.hierarchies, ids[i])
		m.removedhierarchies[ids[i]] = struct{}{}
	}
}

// RemovedHierarchies returns the removed IDs of the "hierarchies" edge to the Hierarchy entity.
func (m *RunMutation) RemovedHierarchiesIDs() (ids []schema.HierarchyID) {
	for id := range m.removedhierarchies {
		ids = append(ids, id)
	}
	return
}

// HierarchiesIDs returns the "hierarchies" edge IDs in the mutation.
func (m *RunMutation) HierarchiesIDs() (ids []schema.HierarchyID) {
	for id := range m.hierarchies {
		ids = append(ids, id)
	}
	return
}

// ResetHierarchies resets all changes to the "hierarchies" edge.
func (m *RunMutation) ResetHierarchies() {
	m.hierarchies = nil
	m.clearedhierarchies = false
	m.removedhierarchies = nil
}

// Where appends a list predicates to the RunMutation builder.
func (m *RunMutation) Where(ps ...predicate.Run) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RunMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RunMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Run, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RunMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RunMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Run).
func (m *RunMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RunMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.status != nil {
		fields = append(fields, run.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, run.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, run.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RunMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case run.FieldStatus:
		return m.Status()
	case run.FieldCreatedAt:
		return m.CreatedAt()
	case run.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RunMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case run.FieldStatus:
		return m.OldStatus(ctx)
	case run.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case run.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Run field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RunMutation) SetField(name string, value ent.Value) error {
	switch name {
	case run.FieldStatus:
		v, ok := value.(schema.RunStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case run.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case run.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Run field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RunMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RunMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RunMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Run numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RunMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RunMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RunMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Run nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RunMutation) ResetField(name string) error {
	switch name {
	case run.FieldStatus:
		m.ResetStatus()
		return nil
	case run.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case run.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Run field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RunMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.workflows != nil {
		edges = append(edges, run.EdgeWorkflows)
	}
	if m.hierarchies != nil {
		edges = append(edges, run.EdgeHierarchies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RunMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case run.EdgeWorkflows:
		ids := make([]ent.Value, 0, len(m.workflows))
		for id := range m.workflows {
			ids = append(ids, id)
		}
		return ids
	case run.EdgeHierarchies:
		ids := make([]ent.Value, 0, len(m.hierarchies))
		for id := range m.hierarchies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RunMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedworkflows != nil {
		edges = append(edges, run.EdgeWorkflows)
	}
	if m.removedhierarchies != nil {
		edges = append(edges, run.EdgeHierarchies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RunMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case run.EdgeWorkflows:
		ids := make([]ent.Value, 0, len(m.removedworkflows))
		for id := range m.removedworkflows {
			ids = append(ids, id)
		}
		return ids
	case run.EdgeHierarchies:
		ids := make([]ent.Value, 0, len(m.removedhierarchies))
		for id := range m.removedhierarchies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RunMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedworkflows {
		edges = append(edges, run.EdgeWorkflows)
	}
	if m.clearedhierarchies {
		edges = append(edges, run.EdgeHierarchies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RunMutation) EdgeCleared(name string) bool {
	switch name {
	case run.EdgeWorkflows:
		return m.clearedworkflows
	case run.EdgeHierarchies:
		return m.clearedhierarchies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RunMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Run unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RunMutation) ResetEdge(name string) error {
	switch name {
	case run.EdgeWorkflows:
		m.ResetWorkflows()
		return nil
	case run.EdgeHierarchies:
		m.ResetHierarchies()
		return nil
	}
	return fmt.Errorf("unknown Run edge %s", name)
}

// SagaDataMutation represents an operation that mutates the SagaData nodes in the graph.
type SagaDataMutation struct {
	config
	op            Op
	typ           string
	id            *schema.SagaDataID
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	saga          *schema.SagaEntityID
	clearedsaga   bool
	values        map[schema.SagaValueID]struct{}
	removedvalues map[schema.SagaValueID]struct{}
	clearedvalues bool
	done          bool
	oldValue      func(context.Context) (*SagaData, error)
	predicates    []predicate.SagaData
}

var _ ent.Mutation = (*SagaDataMutation)(nil)

// sagadataOption allows management of the mutation configuration using functional options.
type sagadataOption func(*SagaDataMutation)

// newSagaDataMutation creates new mutation for the SagaData entity.
func newSagaDataMutation(c config, op Op, opts ...sagadataOption) *SagaDataMutation {
	m := &SagaDataMutation{
		config:        c,
		op:            op,
		typ:           TypeSagaData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSagaDataID sets the ID field of the mutation.
func withSagaDataID(id schema.SagaDataID) sagadataOption {
	return func(m *SagaDataMutation) {
		var (
			err   error
			once  sync.Once
			value *SagaData
		)
		m.oldValue = func(ctx context.Context) (*SagaData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SagaData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSagaData sets the old SagaData of the mutation.
func withSagaData(node *SagaData) sagadataOption {
	return func(m *SagaDataMutation) {
		m.oldValue = func(context.Context) (*SagaData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SagaDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SagaDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SagaData entities.
func (m *SagaDataMutation) SetID(id schema.SagaDataID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SagaDataMutation) ID() (id schema.SagaDataID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SagaDataMutation) IDs(ctx context.Context) ([]schema.SagaDataID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []schema.SagaDataID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SagaData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntityID sets the "entity_id" field.
func (m *SagaDataMutation) SetEntityID(sei schema.SagaEntityID) {
	m.saga = &sei
}

// EntityID returns the value of the "entity_id" field in the mutation.
func (m *SagaDataMutation) EntityID() (r schema.SagaEntityID, exists bool) {
	v := m.saga
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityID returns the old "entity_id" field's value of the SagaData entity.
// If the SagaData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaDataMutation) OldEntityID(ctx context.Context) (v schema.SagaEntityID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityID: %w", err)
	}
	return oldValue.EntityID, nil
}

// ResetEntityID resets all changes to the "entity_id" field.
func (m *SagaDataMutation) ResetEntityID() {
	m.saga = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SagaDataMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SagaDataMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SagaData entity.
// If the SagaData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaDataMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SagaDataMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SagaDataMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SagaDataMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SagaData entity.
// If the SagaData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaDataMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SagaDataMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSagaID sets the "saga" edge to the SagaEntity entity by id.
func (m *SagaDataMutation) SetSagaID(id schema.SagaEntityID) {
	m.saga = &id
}

// ClearSaga clears the "saga" edge to the SagaEntity entity.
func (m *SagaDataMutation) ClearSaga() {
	m.clearedsaga = true
	m.clearedFields[sagadata.FieldEntityID] = struct{}{}
}

// SagaCleared reports if the "saga" edge to the SagaEntity entity was cleared.
func (m *SagaDataMutation) SagaCleared() bool {
	return m.clearedsaga
}

// SagaID returns the "saga" edge ID in the mutation.
func (m *SagaDataMutation) SagaID() (id schema.SagaEntityID, exists bool) {
	if m.saga != nil {
		return *m.saga, true
	}
	return
}

// SagaIDs returns the "saga" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SagaID instead. It exists only for internal usage by the builders.
func (m *SagaDataMutation) SagaIDs() (ids []schema.SagaEntityID) {
	if id := m.saga; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSaga resets all changes to the "saga" edge.
func (m *SagaDataMutation) ResetSaga() {
	m.saga = nil
	m.clearedsaga = false
}

// AddValueIDs adds the "values" edge to the SagaValue entity by ids.
func (m *SagaDataMutation) AddValueIDs(ids ...schema.SagaValueID) {
	if m.values == nil {
		m.values = make(map[schema.SagaValueID]struct{})
	}
	for i := range ids {
		m.values[ids[i]] = struct{}{}
	}
}

// ClearValues clears the "values" edge to the SagaValue entity.
func (m *SagaDataMutation) ClearValues() {
	m.clearedvalues = true
}

// ValuesCleared reports if the "values" edge to the SagaValue entity was cleared.
func (m *SagaDataMutation) ValuesCleared() bool {
	return m.clearedvalues
}

// RemoveValueIDs removes the "values" edge to the SagaValue entity by IDs.
func (m *SagaDataMutation) RemoveValueIDs(ids ...schema.SagaValueID) {
	if m.removedvalues == nil {
		m.removedvalues = make(map[schema.SagaValueID]struct{})
	}
	for i := range ids {
		delete(m.values, ids[i])
		m.removedvalues[ids[i]] = struct{}{}
	}
}

// RemovedValues returns the removed IDs of the "values" edge to the SagaValue entity.
func (m *SagaDataMutation) RemovedValuesIDs() (ids []schema.SagaValueID) {
	for id := range m.removedvalues {
		ids = append(ids, id)
	}
	return
}

// ValuesIDs returns the "values" edge IDs in the mutation.
func (m *SagaDataMutation) ValuesIDs() (ids []schema.SagaValueID) {
	for id := range m.values {
		ids = append(ids, id)
	}
	return
}

// ResetValues resets all changes to the "values" edge.
func (m *SagaDataMutation) ResetValues() {
	m.values = nil
	m.clearedvalues = false
	m.removedvalues = nil
}

// Where appends a list predicates to the SagaDataMutation builder.
func (m *SagaDataMutation) Where(ps ...predicate.SagaData) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SagaDataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SagaDataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SagaData, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SagaDataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SagaDataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SagaData).
func (m *SagaDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SagaDataMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.saga != nil {
		fields = append(fields, sagadata.FieldEntityID)
	}
	if m.created_at != nil {
		fields = append(fields, sagadata.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sagadata.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SagaDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sagadata.FieldEntityID:
		return m.EntityID()
	case sagadata.FieldCreatedAt:
		return m.CreatedAt()
	case sagadata.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SagaDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sagadata.FieldEntityID:
		return m.OldEntityID(ctx)
	case sagadata.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sagadata.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SagaData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SagaDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sagadata.FieldEntityID:
		v, ok := value.(schema.SagaEntityID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityID(v)
		return nil
	case sagadata.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sagadata.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SagaData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SagaDataMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SagaDataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SagaDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SagaData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SagaDataMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SagaDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SagaDataMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SagaData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SagaDataMutation) ResetField(name string) error {
	switch name {
	case sagadata.FieldEntityID:
		m.ResetEntityID()
		return nil
	case sagadata.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sagadata.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SagaData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SagaDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.saga != nil {
		edges = append(edges, sagadata.EdgeSaga)
	}
	if m.values != nil {
		edges = append(edges, sagadata.EdgeValues)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SagaDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sagadata.EdgeSaga:
		if id := m.saga; id != nil {
			return []ent.Value{*id}
		}
	case sagadata.EdgeValues:
		ids := make([]ent.Value, 0, len(m.values))
		for id := range m.values {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SagaDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedvalues != nil {
		edges = append(edges, sagadata.EdgeValues)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SagaDataMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sagadata.EdgeValues:
		ids := make([]ent.Value, 0, len(m.removedvalues))
		for id := range m.removedvalues {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SagaDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsaga {
		edges = append(edges, sagadata.EdgeSaga)
	}
	if m.clearedvalues {
		edges = append(edges, sagadata.EdgeValues)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SagaDataMutation) EdgeCleared(name string) bool {
	switch name {
	case sagadata.EdgeSaga:
		return m.clearedsaga
	case sagadata.EdgeValues:
		return m.clearedvalues
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SagaDataMutation) ClearEdge(name string) error {
	switch name {
	case sagadata.EdgeSaga:
		m.ClearSaga()
		return nil
	}
	return fmt.Errorf("unknown SagaData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SagaDataMutation) ResetEdge(name string) error {
	switch name {
	case sagadata.EdgeSaga:
		m.ResetSaga()
		return nil
	case sagadata.EdgeValues:
		m.ResetValues()
		return nil
	}
	return fmt.Errorf("unknown SagaData edge %s", name)
}

// SagaEntityMutation represents an operation that mutates the SagaEntity nodes in the graph.
type SagaEntityMutation struct {
	config
	op                Op
	typ               string
	id                *schema.SagaEntityID
	handler_name      *string
	_type             *schema.EntityType
	status            *schema.EntityStatus
	step_id           *string
	run_id            *schema.RunID
	addrun_id         *schema.RunID
	retry_policy      *schema.RetryPolicy
	retry_state       *schema.RetryState
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	workflow          *schema.WorkflowEntityID
	clearedworkflow   bool
	saga_data         *schema.SagaDataID
	clearedsaga_data  bool
	executions        map[schema.SagaExecutionID]struct{}
	removedexecutions map[schema.SagaExecutionID]struct{}
	clearedexecutions bool
	values            map[schema.SagaValueID]struct{}
	removedvalues     map[schema.SagaValueID]struct{}
	clearedvalues     bool
	done              bool
	oldValue          func(context.Context) (*SagaEntity, error)
	predicates        []predicate.SagaEntity
}

var _ ent.Mutation = (*SagaEntityMutation)(nil)

// sagaentityOption allows management of the mutation configuration using functional options.
type sagaentityOption func(*SagaEntityMutation)

// newSagaEntityMutation creates new mutation for the SagaEntity entity.
func newSagaEntityMutation(c config, op Op, opts ...sagaentityOption) *SagaEntityMutation {
	m := &SagaEntityMutation{
		config:        c,
		op:            op,
		typ:           TypeSagaEntity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSagaEntityID sets the ID field of the mutation.
func withSagaEntityID(id schema.SagaEntityID) sagaentityOption {
	return func(m *SagaEntityMutation) {
		var (
			err   error
			once  sync.Once
			value *SagaEntity
		)
		m.oldValue = func(ctx context.Context) (*SagaEntity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SagaEntity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSagaEntity sets the old SagaEntity of the mutation.
func withSagaEntity(node *SagaEntity) sagaentityOption {
	return func(m *SagaEntityMutation) {
		m.oldValue = func(context.Context) (*SagaEntity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SagaEntityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SagaEntityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SagaEntity entities.
func (m *SagaEntityMutation) SetID(id schema.SagaEntityID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SagaEntityMutation) ID() (id schema.SagaEntityID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SagaEntityMutation) IDs(ctx context.Context) ([]schema.SagaEntityID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []schema.SagaEntityID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SagaEntity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHandlerName sets the "handler_name" field.
func (m *SagaEntityMutation) SetHandlerName(s string) {
	m.handler_name = &s
}

// HandlerName returns the value of the "handler_name" field in the mutation.
func (m *SagaEntityMutation) HandlerName() (r string, exists bool) {
	v := m.handler_name
	if v == nil {
		return
	}
	return *v, true
}

// OldHandlerName returns the old "handler_name" field's value of the SagaEntity entity.
// If the SagaEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaEntityMutation) OldHandlerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandlerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandlerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandlerName: %w", err)
	}
	return oldValue.HandlerName, nil
}

// ResetHandlerName resets all changes to the "handler_name" field.
func (m *SagaEntityMutation) ResetHandlerName() {
	m.handler_name = nil
}

// SetType sets the "type" field.
func (m *SagaEntityMutation) SetType(st schema.EntityType) {
	m._type = &st
}

// GetType returns the value of the "type" field in the mutation.
func (m *SagaEntityMutation) GetType() (r schema.EntityType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the SagaEntity entity.
// If the SagaEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaEntityMutation) OldType(ctx context.Context) (v schema.EntityType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *SagaEntityMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *SagaEntityMutation) SetStatus(ss schema.EntityStatus) {
	m.status = &ss
}

// Status returns the value of the "status" field in the mutation.
func (m *SagaEntityMutation) Status() (r schema.EntityStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SagaEntity entity.
// If the SagaEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaEntityMutation) OldStatus(ctx context.Context) (v schema.EntityStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SagaEntityMutation) ResetStatus() {
	m.status = nil
}

// SetStepID sets the "step_id" field.
func (m *SagaEntityMutation) SetStepID(s string) {
	m.step_id = &s
}

// StepID returns the value of the "step_id" field in the mutation.
func (m *SagaEntityMutation) StepID() (r string, exists bool) {
	v := m.step_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStepID returns the old "step_id" field's value of the SagaEntity entity.
// If the SagaEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaEntityMutation) OldStepID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStepID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStepID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStepID: %w", err)
	}
	return oldValue.StepID, nil
}

// ResetStepID resets all changes to the "step_id" field.
func (m *SagaEntityMutation) ResetStepID() {
	m.step_id = nil
}

// SetRunID sets the "run_id" field.
func (m *SagaEntityMutation) SetRunID(si schema.RunID) {
	m.run_id = &si
	m.addrun_id = nil
}

// RunID returns the value of the "run_id" field in the mutation.
func (m *SagaEntityMutation) RunID() (r schema.RunID, exists bool) {
	v := m.run_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRunID returns the old "run_id" field's value of the SagaEntity entity.
// If the SagaEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaEntityMutation) OldRunID(ctx context.Context) (v schema.RunID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunID: %w", err)
	}
	return oldValue.RunID, nil
}

// AddRunID adds si to the "run_id" field.
func (m *SagaEntityMutation) AddRunID(si schema.RunID) {
	if m.addrun_id != nil {
		*m.addrun_id += si
	} else {
		m.addrun_id = &si
	}
}

// AddedRunID returns the value that was added to the "run_id" field in this mutation.
func (m *SagaEntityMutation) AddedRunID() (r schema.RunID, exists bool) {
	v := m.addrun_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRunID resets all changes to the "run_id" field.
func (m *SagaEntityMutation) ResetRunID() {
	m.run_id = nil
	m.addrun_id = nil
}

// SetRetryPolicy sets the "retry_policy" field.
func (m *SagaEntityMutation) SetRetryPolicy(sp schema.RetryPolicy) {
	m.retry_policy = &sp
}

// RetryPolicy returns the value of the "retry_policy" field in the mutation.
func (m *SagaEntityMutation) RetryPolicy() (r schema.RetryPolicy, exists bool) {
	v := m.retry_policy
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryPolicy returns the old "retry_policy" field's value of the SagaEntity entity.
// If the SagaEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaEntityMutation) OldRetryPolicy(ctx context.Context) (v schema.RetryPolicy, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryPolicy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryPolicy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryPolicy: %w", err)
	}
	return oldValue.RetryPolicy, nil
}

// ResetRetryPolicy resets all changes to the "retry_policy" field.
func (m *SagaEntityMutation) ResetRetryPolicy() {
	m.retry_policy = nil
}

// SetRetryState sets the "retry_state" field.
func (m *SagaEntityMutation) SetRetryState(ss schema.RetryState) {
	m.retry_state = &ss
}

// RetryState returns the value of the "retry_state" field in the mutation.
func (m *SagaEntityMutation) RetryState() (r schema.RetryState, exists bool) {
	v := m.retry_state
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryState returns the old "retry_state" field's value of the SagaEntity entity.
// If the SagaEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaEntityMutation) OldRetryState(ctx context.Context) (v schema.RetryState, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryState: %w", err)
	}
	return oldValue.RetryState, nil
}

// ResetRetryState resets all changes to the "retry_state" field.
func (m *SagaEntityMutation) ResetRetryState() {
	m.retry_state = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SagaEntityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SagaEntityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SagaEntity entity.
// If the SagaEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaEntityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SagaEntityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SagaEntityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SagaEntityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SagaEntity entity.
// If the SagaEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaEntityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SagaEntityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetWorkflowID sets the "workflow" edge to the WorkflowEntity entity by id.
func (m *SagaEntityMutation) SetWorkflowID(id schema.WorkflowEntityID) {
	m.workflow = &id
}

// ClearWorkflow clears the "workflow" edge to the WorkflowEntity entity.
func (m *SagaEntityMutation) ClearWorkflow() {
	m.clearedworkflow = true
}

// WorkflowCleared reports if the "workflow" edge to the WorkflowEntity entity was cleared.
func (m *SagaEntityMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowID returns the "workflow" edge ID in the mutation.
func (m *SagaEntityMutation) WorkflowID() (id schema.WorkflowEntityID, exists bool) {
	if m.workflow != nil {
		return *m.workflow, true
	}
	return
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *SagaEntityMutation) WorkflowIDs() (ids []schema.WorkflowEntityID) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *SagaEntityMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// SetSagaDataID sets the "saga_data" edge to the SagaData entity by id.
func (m *SagaEntityMutation) SetSagaDataID(id schema.SagaDataID) {
	m.saga_data = &id
}

// ClearSagaData clears the "saga_data" edge to the SagaData entity.
func (m *SagaEntityMutation) ClearSagaData() {
	m.clearedsaga_data = true
}

// SagaDataCleared reports if the "saga_data" edge to the SagaData entity was cleared.
func (m *SagaEntityMutation) SagaDataCleared() bool {
	return m.clearedsaga_data
}

// SagaDataID returns the "saga_data" edge ID in the mutation.
func (m *SagaEntityMutation) SagaDataID() (id schema.SagaDataID, exists bool) {
	if m.saga_data != nil {
		return *m.saga_data, true
	}
	return
}

// SagaDataIDs returns the "saga_data" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SagaDataID instead. It exists only for internal usage by the builders.
func (m *SagaEntityMutation) SagaDataIDs() (ids []schema.SagaDataID) {
	if id := m.saga_data; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSagaData resets all changes to the "saga_data" edge.
func (m *SagaEntityMutation) ResetSagaData() {
	m.saga_data = nil
	m.clearedsaga_data = false
}

// AddExecutionIDs adds the "executions" edge to the SagaExecution entity by ids.
func (m *SagaEntityMutation) AddExecutionIDs(ids ...schema.SagaExecutionID) {
	if m.executions == nil {
		m.executions = make(map[schema.SagaExecutionID]struct{})
	}
	for i := range ids {
		m.executions[ids[i]] = struct{}{}
	}
}

// ClearExecutions clears the "executions" edge to the SagaExecution entity.
func (m *SagaEntityMutation) ClearExecutions() {
	m.clearedexecutions = true
}

// ExecutionsCleared reports if the "executions" edge to the SagaExecution entity was cleared.
func (m *SagaEntityMutation) ExecutionsCleared() bool {
	return m.clearedexecutions
}

// RemoveExecutionIDs removes the "executions" edge to the SagaExecution entity by IDs.
func (m *SagaEntityMutation) RemoveExecutionIDs(ids ...schema.SagaExecutionID) {
	if m.removedexecutions == nil {
		m.removedexecutions = make(map[schema.SagaExecutionID]struct{})
	}
	for i := range ids {
		delete(m.executions, ids[i])
		m.removedexecutions[ids[i]] = struct{}{}
	}
}

// RemovedExecutions returns the removed IDs of the "executions" edge to the SagaExecution entity.
func (m *SagaEntityMutation) RemovedExecutionsIDs() (ids []schema.SagaExecutionID) {
	for id := range m.removedexecutions {
		ids = append(ids, id)
	}
	return
}

// ExecutionsIDs returns the "executions" edge IDs in the mutation.
func (m *SagaEntityMutation) ExecutionsIDs() (ids []schema.SagaExecutionID) {
	for id := range m.executions {
		ids = append(ids, id)
	}
	return
}

// ResetExecutions resets all changes to the "executions" edge.
func (m *SagaEntityMutation) ResetExecutions() {
	m.executions = nil
	m.clearedexecutions = false
	m.removedexecutions = nil
}

// AddValueIDs adds the "values" edge to the SagaValue entity by ids.
func (m *SagaEntityMutation) AddValueIDs(ids ...schema.SagaValueID) {
	if m.values == nil {
		m.values = make(map[schema.SagaValueID]struct{})
	}
	for i := range ids {
		m.values[ids[i]] = struct{}{}
	}
}

// ClearValues clears the "values" edge to the SagaValue entity.
func (m *SagaEntityMutation) ClearValues() {
	m.clearedvalues = true
}

// ValuesCleared reports if the "values" edge to the SagaValue entity was cleared.
func (m *SagaEntityMutation) ValuesCleared() bool {
	return m.clearedvalues
}

// RemoveValueIDs removes the "values" edge to the SagaValue entity by IDs.
func (m *SagaEntityMutation) RemoveValueIDs(ids ...schema.SagaValueID) {
	if m.removedvalues == nil {
		m.removedvalues = make(map[schema.SagaValueID]struct{})
	}
	for i := range ids {
		delete(m.values, ids[i])
		m.removedvalues[ids[i]] = struct{}{}
	}
}

// RemovedValues returns the removed IDs of the "values" edge to the SagaValue entity.
func (m *SagaEntityMutation) RemovedValuesIDs() (ids []schema.SagaValueID) {
	for id := range m.removedvalues {
		ids = append(ids, id)
	}
	return
}

// ValuesIDs returns the "values" edge IDs in the mutation.
func (m *SagaEntityMutation) ValuesIDs() (ids []schema.SagaValueID) {
	for id := range m.values {
		ids = append(ids, id)
	}
	return
}

// ResetValues resets all changes to the "values" edge.
func (m *SagaEntityMutation) ResetValues() {
	m.values = nil
	m.clearedvalues = false
	m.removedvalues = nil
}

// Where appends a list predicates to the SagaEntityMutation builder.
func (m *SagaEntityMutation) Where(ps ...predicate.SagaEntity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SagaEntityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SagaEntityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SagaEntity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SagaEntityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SagaEntityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SagaEntity).
func (m *SagaEntityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SagaEntityMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.handler_name != nil {
		fields = append(fields, sagaentity.FieldHandlerName)
	}
	if m._type != nil {
		fields = append(fields, sagaentity.FieldType)
	}
	if m.status != nil {
		fields = append(fields, sagaentity.FieldStatus)
	}
	if m.step_id != nil {
		fields = append(fields, sagaentity.FieldStepID)
	}
	if m.run_id != nil {
		fields = append(fields, sagaentity.FieldRunID)
	}
	if m.retry_policy != nil {
		fields = append(fields, sagaentity.FieldRetryPolicy)
	}
	if m.retry_state != nil {
		fields = append(fields, sagaentity.FieldRetryState)
	}
	if m.created_at != nil {
		fields = append(fields, sagaentity.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sagaentity.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SagaEntityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sagaentity.FieldHandlerName:
		return m.HandlerName()
	case sagaentity.FieldType:
		return m.GetType()
	case sagaentity.FieldStatus:
		return m.Status()
	case sagaentity.FieldStepID:
		return m.StepID()
	case sagaentity.FieldRunID:
		return m.RunID()
	case sagaentity.FieldRetryPolicy:
		return m.RetryPolicy()
	case sagaentity.FieldRetryState:
		return m.RetryState()
	case sagaentity.FieldCreatedAt:
		return m.CreatedAt()
	case sagaentity.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SagaEntityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sagaentity.FieldHandlerName:
		return m.OldHandlerName(ctx)
	case sagaentity.FieldType:
		return m.OldType(ctx)
	case sagaentity.FieldStatus:
		return m.OldStatus(ctx)
	case sagaentity.FieldStepID:
		return m.OldStepID(ctx)
	case sagaentity.FieldRunID:
		return m.OldRunID(ctx)
	case sagaentity.FieldRetryPolicy:
		return m.OldRetryPolicy(ctx)
	case sagaentity.FieldRetryState:
		return m.OldRetryState(ctx)
	case sagaentity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sagaentity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SagaEntity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SagaEntityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sagaentity.FieldHandlerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandlerName(v)
		return nil
	case sagaentity.FieldType:
		v, ok := value.(schema.EntityType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case sagaentity.FieldStatus:
		v, ok := value.(schema.EntityStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case sagaentity.FieldStepID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStepID(v)
		return nil
	case sagaentity.FieldRunID:
		v, ok := value.(schema.RunID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunID(v)
		return nil
	case sagaentity.FieldRetryPolicy:
		v, ok := value.(schema.RetryPolicy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryPolicy(v)
		return nil
	case sagaentity.FieldRetryState:
		v, ok := value.(schema.RetryState)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryState(v)
		return nil
	case sagaentity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sagaentity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SagaEntity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SagaEntityMutation) AddedFields() []string {
	var fields []string
	if m.addrun_id != nil {
		fields = append(fields, sagaentity.FieldRunID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SagaEntityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sagaentity.FieldRunID:
		return m.AddedRunID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SagaEntityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sagaentity.FieldRunID:
		v, ok := value.(schema.RunID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRunID(v)
		return nil
	}
	return fmt.Errorf("unknown SagaEntity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SagaEntityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SagaEntityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SagaEntityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SagaEntity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SagaEntityMutation) ResetField(name string) error {
	switch name {
	case sagaentity.FieldHandlerName:
		m.ResetHandlerName()
		return nil
	case sagaentity.FieldType:
		m.ResetType()
		return nil
	case sagaentity.FieldStatus:
		m.ResetStatus()
		return nil
	case sagaentity.FieldStepID:
		m.ResetStepID()
		return nil
	case sagaentity.FieldRunID:
		m.ResetRunID()
		return nil
	case sagaentity.FieldRetryPolicy:
		m.ResetRetryPolicy()
		return nil
	case sagaentity.FieldRetryState:
		m.ResetRetryState()
		return nil
	case sagaentity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sagaentity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SagaEntity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SagaEntityMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.workflow != nil {
		edges = append(edges, sagaentity.EdgeWorkflow)
	}
	if m.saga_data != nil {
		edges = append(edges, sagaentity.EdgeSagaData)
	}
	if m.executions != nil {
		edges = append(edges, sagaentity.EdgeExecutions)
	}
	if m.values != nil {
		edges = append(edges, sagaentity.EdgeValues)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SagaEntityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sagaentity.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	case sagaentity.EdgeSagaData:
		if id := m.saga_data; id != nil {
			return []ent.Value{*id}
		}
	case sagaentity.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.executions))
		for id := range m.executions {
			ids = append(ids, id)
		}
		return ids
	case sagaentity.EdgeValues:
		ids := make([]ent.Value, 0, len(m.values))
		for id := range m.values {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SagaEntityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedexecutions != nil {
		edges = append(edges, sagaentity.EdgeExecutions)
	}
	if m.removedvalues != nil {
		edges = append(edges, sagaentity.EdgeValues)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SagaEntityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sagaentity.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.removedexecutions))
		for id := range m.removedexecutions {
			ids = append(ids, id)
		}
		return ids
	case sagaentity.EdgeValues:
		ids := make([]ent.Value, 0, len(m.removedvalues))
		for id := range m.removedvalues {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SagaEntityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedworkflow {
		edges = append(edges, sagaentity.EdgeWorkflow)
	}
	if m.clearedsaga_data {
		edges = append(edges, sagaentity.EdgeSagaData)
	}
	if m.clearedexecutions {
		edges = append(edges, sagaentity.EdgeExecutions)
	}
	if m.clearedvalues {
		edges = append(edges, sagaentity.EdgeValues)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SagaEntityMutation) EdgeCleared(name string) bool {
	switch name {
	case sagaentity.EdgeWorkflow:
		return m.clearedworkflow
	case sagaentity.EdgeSagaData:
		return m.clearedsaga_data
	case sagaentity.EdgeExecutions:
		return m.clearedexecutions
	case sagaentity.EdgeValues:
		return m.clearedvalues
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SagaEntityMutation) ClearEdge(name string) error {
	switch name {
	case sagaentity.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	case sagaentity.EdgeSagaData:
		m.ClearSagaData()
		return nil
	}
	return fmt.Errorf("unknown SagaEntity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SagaEntityMutation) ResetEdge(name string) error {
	switch name {
	case sagaentity.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	case sagaentity.EdgeSagaData:
		m.ResetSagaData()
		return nil
	case sagaentity.EdgeExecutions:
		m.ResetExecutions()
		return nil
	case sagaentity.EdgeValues:
		m.ResetValues()
		return nil
	}
	return fmt.Errorf("unknown SagaEntity edge %s", name)
}

// SagaExecutionMutation represents an operation that mutates the SagaExecution nodes in the graph.
type SagaExecutionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *schema.SagaExecutionID
	execution_type        *schema.ExecutionType
	started_at            *time.Time
	completed_at          *time.Time
	status                *schema.ExecutionStatus
	error                 *string
	stack_trace           *string
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	saga                  *schema.SagaEntityID
	clearedsaga           bool
	execution_data        *schema.SagaExecutionDataID
	clearedexecution_data bool
	values                map[schema.SagaValueID]struct{}
	removedvalues         map[schema.SagaValueID]struct{}
	clearedvalues         bool
	done                  bool
	oldValue              func(context.Context) (*SagaExecution, error)
	predicates            []predicate.SagaExecution
}

var _ ent.Mutation = (*SagaExecutionMutation)(nil)

// sagaexecutionOption allows management of the mutation configuration using functional options.
type sagaexecutionOption func(*SagaExecutionMutation)

// newSagaExecutionMutation creates new mutation for the SagaExecution entity.
func newSagaExecutionMutation(c config, op Op, opts ...sagaexecutionOption) *SagaExecutionMutation {
	m := &SagaExecutionMutation{
		config:        c,
		op:            op,
		typ:           TypeSagaExecution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSagaExecutionID sets the ID field of the mutation.
func withSagaExecutionID(id schema.SagaExecutionID) sagaexecutionOption {
	return func(m *SagaExecutionMutation) {
		var (
			err   error
			once  sync.Once
			value *SagaExecution
		)
		m.oldValue = func(ctx context.Context) (*SagaExecution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SagaExecution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSagaExecution sets the old SagaExecution of the mutation.
func withSagaExecution(node *SagaExecution) sagaexecutionOption {
	return func(m *SagaExecutionMutation) {
		m.oldValue = func(context.Context) (*SagaExecution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SagaExecutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SagaExecutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SagaExecution entities.
func (m *SagaExecutionMutation) SetID(id schema.SagaExecutionID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SagaExecutionMutation) ID() (id schema.SagaExecutionID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SagaExecutionMutation) IDs(ctx context.Context) ([]schema.SagaExecutionID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []schema.SagaExecutionID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SagaExecution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSagaEntityID sets the "saga_entity_id" field.
func (m *SagaExecutionMutation) SetSagaEntityID(sei schema.SagaEntityID) {
	m.saga = &sei
}

// SagaEntityID returns the value of the "saga_entity_id" field in the mutation.
func (m *SagaExecutionMutation) SagaEntityID() (r schema.SagaEntityID, exists bool) {
	v := m.saga
	if v == nil {
		return
	}
	return *v, true
}

// OldSagaEntityID returns the old "saga_entity_id" field's value of the SagaExecution entity.
// If the SagaExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaExecutionMutation) OldSagaEntityID(ctx context.Context) (v schema.SagaEntityID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSagaEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSagaEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSagaEntityID: %w", err)
	}
	return oldValue.SagaEntityID, nil
}

// ResetSagaEntityID resets all changes to the "saga_entity_id" field.
func (m *SagaExecutionMutation) ResetSagaEntityID() {
	m.saga = nil
}

// SetExecutionType sets the "execution_type" field.
func (m *SagaExecutionMutation) SetExecutionType(st schema.ExecutionType) {
	m.execution_type = &st
}

// ExecutionType returns the value of the "execution_type" field in the mutation.
func (m *SagaExecutionMutation) ExecutionType() (r schema.ExecutionType, exists bool) {
	v := m.execution_type
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutionType returns the old "execution_type" field's value of the SagaExecution entity.
// If the SagaExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaExecutionMutation) OldExecutionType(ctx context.Context) (v schema.ExecutionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutionType: %w", err)
	}
	return oldValue.ExecutionType, nil
}

// ResetExecutionType resets all changes to the "execution_type" field.
func (m *SagaExecutionMutation) ResetExecutionType() {
	m.execution_type = nil
}

// SetStartedAt sets the "started_at" field.
func (m *SagaExecutionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *SagaExecutionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the SagaExecution entity.
// If the SagaExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaExecutionMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *SagaExecutionMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetCompletedAt sets the "completed_at" field.
func (m *SagaExecutionMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *SagaExecutionMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the SagaExecution entity.
// If the SagaExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaExecutionMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *SagaExecutionMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[sagaexecution.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *SagaExecutionMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[sagaexecution.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *SagaExecutionMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, sagaexecution.FieldCompletedAt)
}

// SetStatus sets the "status" field.
func (m *SagaExecutionMutation) SetStatus(ss schema.ExecutionStatus) {
	m.status = &ss
}

// Status returns the value of the "status" field in the mutation.
func (m *SagaExecutionMutation) Status() (r schema.ExecutionStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SagaExecution entity.
// If the SagaExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaExecutionMutation) OldStatus(ctx context.Context) (v schema.ExecutionStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SagaExecutionMutation) ResetStatus() {
	m.status = nil
}

// SetError sets the "error" field.
func (m *SagaExecutionMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *SagaExecutionMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the SagaExecution entity.
// If the SagaExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaExecutionMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *SagaExecutionMutation) ClearError() {
	m.error = nil
	m.clearedFields[sagaexecution.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *SagaExecutionMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[sagaexecution.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *SagaExecutionMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, sagaexecution.FieldError)
}

// SetStackTrace sets the "stack_trace" field.
func (m *SagaExecutionMutation) SetStackTrace(s string) {
	m.stack_trace = &s
}

// StackTrace returns the value of the "stack_trace" field in the mutation.
func (m *SagaExecutionMutation) StackTrace() (r string, exists bool) {
	v := m.stack_trace
	if v == nil {
		return
	}
	return *v, true
}

// OldStackTrace returns the old "stack_trace" field's value of the SagaExecution entity.
// If the SagaExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaExecutionMutation) OldStackTrace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStackTrace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStackTrace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStackTrace: %w", err)
	}
	return oldValue.StackTrace, nil
}

// ClearStackTrace clears the value of the "stack_trace" field.
func (m *SagaExecutionMutation) ClearStackTrace() {
	m.stack_trace = nil
	m.clearedFields[sagaexecution.FieldStackTrace] = struct{}{}
}

// StackTraceCleared returns if the "stack_trace" field was cleared in this mutation.
func (m *SagaExecutionMutation) StackTraceCleared() bool {
	_, ok := m.clearedFields[sagaexecution.FieldStackTrace]
	return ok
}

// ResetStackTrace resets all changes to the "stack_trace" field.
func (m *SagaExecutionMutation) ResetStackTrace() {
	m.stack_trace = nil
	delete(m.clearedFields, sagaexecution.FieldStackTrace)
}

// SetCreatedAt sets the "created_at" field.
func (m *SagaExecutionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SagaExecutionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SagaExecution entity.
// If the SagaExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaExecutionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SagaExecutionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SagaExecutionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SagaExecutionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SagaExecution entity.
// If the SagaExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaExecutionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SagaExecutionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSagaID sets the "saga" edge to the SagaEntity entity by id.
func (m *SagaExecutionMutation) SetSagaID(id schema.SagaEntityID) {
	m.saga = &id
}

// ClearSaga clears the "saga" edge to the SagaEntity entity.
func (m *SagaExecutionMutation) ClearSaga() {
	m.clearedsaga = true
	m.clearedFields[sagaexecution.FieldSagaEntityID] = struct{}{}
}

// SagaCleared reports if the "saga" edge to the SagaEntity entity was cleared.
func (m *SagaExecutionMutation) SagaCleared() bool {
	return m.clearedsaga
}

// SagaID returns the "saga" edge ID in the mutation.
func (m *SagaExecutionMutation) SagaID() (id schema.SagaEntityID, exists bool) {
	if m.saga != nil {
		return *m.saga, true
	}
	return
}

// SagaIDs returns the "saga" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SagaID instead. It exists only for internal usage by the builders.
func (m *SagaExecutionMutation) SagaIDs() (ids []schema.SagaEntityID) {
	if id := m.saga; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSaga resets all changes to the "saga" edge.
func (m *SagaExecutionMutation) ResetSaga() {
	m.saga = nil
	m.clearedsaga = false
}

// SetExecutionDataID sets the "execution_data" edge to the SagaExecutionData entity by id.
func (m *SagaExecutionMutation) SetExecutionDataID(id schema.SagaExecutionDataID) {
	m.execution_data = &id
}

// ClearExecutionData clears the "execution_data" edge to the SagaExecutionData entity.
func (m *SagaExecutionMutation) ClearExecutionData() {
	m.clearedexecution_data = true
}

// ExecutionDataCleared reports if the "execution_data" edge to the SagaExecutionData entity was cleared.
func (m *SagaExecutionMutation) ExecutionDataCleared() bool {
	return m.clearedexecution_data
}

// ExecutionDataID returns the "execution_data" edge ID in the mutation.
func (m *SagaExecutionMutation) ExecutionDataID() (id schema.SagaExecutionDataID, exists bool) {
	if m.execution_data != nil {
		return *m.execution_data, true
	}
	return
}

// ExecutionDataIDs returns the "execution_data" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExecutionDataID instead. It exists only for internal usage by the builders.
func (m *SagaExecutionMutation) ExecutionDataIDs() (ids []schema.SagaExecutionDataID) {
	if id := m.execution_data; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExecutionData resets all changes to the "execution_data" edge.
func (m *SagaExecutionMutation) ResetExecutionData() {
	m.execution_data = nil
	m.clearedexecution_data = false
}

// AddValueIDs adds the "values" edge to the SagaValue entity by ids.
func (m *SagaExecutionMutation) AddValueIDs(ids ...schema.SagaValueID) {
	if m.values == nil {
		m.values = make(map[schema.SagaValueID]struct{})
	}
	for i := range ids {
		m.values[ids[i]] = struct{}{}
	}
}

// ClearValues clears the "values" edge to the SagaValue entity.
func (m *SagaExecutionMutation) ClearValues() {
	m.clearedvalues = true
}

// ValuesCleared reports if the "values" edge to the SagaValue entity was cleared.
func (m *SagaExecutionMutation) ValuesCleared() bool {
	return m.clearedvalues
}

// RemoveValueIDs removes the "values" edge to the SagaValue entity by IDs.
func (m *SagaExecutionMutation) RemoveValueIDs(ids ...schema.SagaValueID) {
	if m.removedvalues == nil {
		m.removedvalues = make(map[schema.SagaValueID]struct{})
	}
	for i := range ids {
		delete(m.values, ids[i])
		m.removedvalues[ids[i]] = struct{}{}
	}
}

// RemovedValues returns the removed IDs of the "values" edge to the SagaValue entity.
func (m *SagaExecutionMutation) RemovedValuesIDs() (ids []schema.SagaValueID) {
	for id := range m.removedvalues {
		ids = append(ids, id)
	}
	return
}

// ValuesIDs returns the "values" edge IDs in the mutation.
func (m *SagaExecutionMutation) ValuesIDs() (ids []schema.SagaValueID) {
	for id := range m.values {
		ids = append(ids, id)
	}
	return
}

// ResetValues resets all changes to the "values" edge.
func (m *SagaExecutionMutation) ResetValues() {
	m.values = nil
	m.clearedvalues = false
	m.removedvalues = nil
}

// Where appends a list predicates to the SagaExecutionMutation builder.
func (m *SagaExecutionMutation) Where(ps ...predicate.SagaExecution) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SagaExecutionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SagaExecutionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SagaExecution, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SagaExecutionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SagaExecutionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SagaExecution).
func (m *SagaExecutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SagaExecutionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.saga != nil {
		fields = append(fields, sagaexecution.FieldSagaEntityID)
	}
	if m.execution_type != nil {
		fields = append(fields, sagaexecution.FieldExecutionType)
	}
	if m.started_at != nil {
		fields = append(fields, sagaexecution.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, sagaexecution.FieldCompletedAt)
	}
	if m.status != nil {
		fields = append(fields, sagaexecution.FieldStatus)
	}
	if m.error != nil {
		fields = append(fields, sagaexecution.FieldError)
	}
	if m.stack_trace != nil {
		fields = append(fields, sagaexecution.FieldStackTrace)
	}
	if m.created_at != nil {
		fields = append(fields, sagaexecution.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sagaexecution.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SagaExecutionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sagaexecution.FieldSagaEntityID:
		return m.SagaEntityID()
	case sagaexecution.FieldExecutionType:
		return m.ExecutionType()
	case sagaexecution.FieldStartedAt:
		return m.StartedAt()
	case sagaexecution.FieldCompletedAt:
		return m.CompletedAt()
	case sagaexecution.FieldStatus:
		return m.Status()
	case sagaexecution.FieldError:
		return m.Error()
	case sagaexecution.FieldStackTrace:
		return m.StackTrace()
	case sagaexecution.FieldCreatedAt:
		return m.CreatedAt()
	case sagaexecution.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SagaExecutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sagaexecution.FieldSagaEntityID:
		return m.OldSagaEntityID(ctx)
	case sagaexecution.FieldExecutionType:
		return m.OldExecutionType(ctx)
	case sagaexecution.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case sagaexecution.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case sagaexecution.FieldStatus:
		return m.OldStatus(ctx)
	case sagaexecution.FieldError:
		return m.OldError(ctx)
	case sagaexecution.FieldStackTrace:
		return m.OldStackTrace(ctx)
	case sagaexecution.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sagaexecution.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SagaExecution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SagaExecutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sagaexecution.FieldSagaEntityID:
		v, ok := value.(schema.SagaEntityID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSagaEntityID(v)
		return nil
	case sagaexecution.FieldExecutionType:
		v, ok := value.(schema.ExecutionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutionType(v)
		return nil
	case sagaexecution.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case sagaexecution.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case sagaexecution.FieldStatus:
		v, ok := value.(schema.ExecutionStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case sagaexecution.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case sagaexecution.FieldStackTrace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStackTrace(v)
		return nil
	case sagaexecution.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sagaexecution.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SagaExecution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SagaExecutionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SagaExecutionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SagaExecutionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SagaExecution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SagaExecutionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sagaexecution.FieldCompletedAt) {
		fields = append(fields, sagaexecution.FieldCompletedAt)
	}
	if m.FieldCleared(sagaexecution.FieldError) {
		fields = append(fields, sagaexecution.FieldError)
	}
	if m.FieldCleared(sagaexecution.FieldStackTrace) {
		fields = append(fields, sagaexecution.FieldStackTrace)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SagaExecutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SagaExecutionMutation) ClearField(name string) error {
	switch name {
	case sagaexecution.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	case sagaexecution.FieldError:
		m.ClearError()
		return nil
	case sagaexecution.FieldStackTrace:
		m.ClearStackTrace()
		return nil
	}
	return fmt.Errorf("unknown SagaExecution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SagaExecutionMutation) ResetField(name string) error {
	switch name {
	case sagaexecution.FieldSagaEntityID:
		m.ResetSagaEntityID()
		return nil
	case sagaexecution.FieldExecutionType:
		m.ResetExecutionType()
		return nil
	case sagaexecution.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case sagaexecution.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case sagaexecution.FieldStatus:
		m.ResetStatus()
		return nil
	case sagaexecution.FieldError:
		m.ResetError()
		return nil
	case sagaexecution.FieldStackTrace:
		m.ResetStackTrace()
		return nil
	case sagaexecution.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sagaexecution.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SagaExecution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SagaExecutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.saga != nil {
		edges = append(edges, sagaexecution.EdgeSaga)
	}
	if m.execution_data != nil {
		edges = append(edges, sagaexecution.EdgeExecutionData)
	}
	if m.values != nil {
		edges = append(edges, sagaexecution.EdgeValues)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SagaExecutionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sagaexecution.EdgeSaga:
		if id := m.saga; id != nil {
			return []ent.Value{*id}
		}
	case sagaexecution.EdgeExecutionData:
		if id := m.execution_data; id != nil {
			return []ent.Value{*id}
		}
	case sagaexecution.EdgeValues:
		ids := make([]ent.Value, 0, len(m.values))
		for id := range m.values {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SagaExecutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedvalues != nil {
		edges = append(edges, sagaexecution.EdgeValues)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SagaExecutionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sagaexecution.EdgeValues:
		ids := make([]ent.Value, 0, len(m.removedvalues))
		for id := range m.removedvalues {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SagaExecutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedsaga {
		edges = append(edges, sagaexecution.EdgeSaga)
	}
	if m.clearedexecution_data {
		edges = append(edges, sagaexecution.EdgeExecutionData)
	}
	if m.clearedvalues {
		edges = append(edges, sagaexecution.EdgeValues)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SagaExecutionMutation) EdgeCleared(name string) bool {
	switch name {
	case sagaexecution.EdgeSaga:
		return m.clearedsaga
	case sagaexecution.EdgeExecutionData:
		return m.clearedexecution_data
	case sagaexecution.EdgeValues:
		return m.clearedvalues
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SagaExecutionMutation) ClearEdge(name string) error {
	switch name {
	case sagaexecution.EdgeSaga:
		m.ClearSaga()
		return nil
	case sagaexecution.EdgeExecutionData:
		m.ClearExecutionData()
		return nil
	}
	return fmt.Errorf("unknown SagaExecution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SagaExecutionMutation) ResetEdge(name string) error {
	switch name {
	case sagaexecution.EdgeSaga:
		m.ResetSaga()
		return nil
	case sagaexecution.EdgeExecutionData:
		m.ResetExecutionData()
		return nil
	case sagaexecution.EdgeValues:
		m.ResetValues()
		return nil
	}
	return fmt.Errorf("unknown SagaExecution edge %s", name)
}

// SagaExecutionDataMutation represents an operation that mutates the SagaExecutionData nodes in the graph.
type SagaExecutionDataMutation struct {
	config
	op               Op
	typ              string
	id               *schema.SagaExecutionDataID
	last_heartbeat   *time.Time
	step_index       *int
	addstep_index    *int
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	execution        *schema.SagaExecutionID
	clearedexecution bool
	values           map[schema.SagaValueID]struct{}
	removedvalues    map[schema.SagaValueID]struct{}
	clearedvalues    bool
	done             bool
	oldValue         func(context.Context) (*SagaExecutionData, error)
	predicates       []predicate.SagaExecutionData
}

var _ ent.Mutation = (*SagaExecutionDataMutation)(nil)

// sagaexecutiondataOption allows management of the mutation configuration using functional options.
type sagaexecutiondataOption func(*SagaExecutionDataMutation)

// newSagaExecutionDataMutation creates new mutation for the SagaExecutionData entity.
func newSagaExecutionDataMutation(c config, op Op, opts ...sagaexecutiondataOption) *SagaExecutionDataMutation {
	m := &SagaExecutionDataMutation{
		config:        c,
		op:            op,
		typ:           TypeSagaExecutionData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSagaExecutionDataID sets the ID field of the mutation.
func withSagaExecutionDataID(id schema.SagaExecutionDataID) sagaexecutiondataOption {
	return func(m *SagaExecutionDataMutation) {
		var (
			err   error
			once  sync.Once
			value *SagaExecutionData
		)
		m.oldValue = func(ctx context.Context) (*SagaExecutionData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SagaExecutionData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSagaExecutionData sets the old SagaExecutionData of the mutation.
func withSagaExecutionData(node *SagaExecutionData) sagaexecutiondataOption {
	return func(m *SagaExecutionDataMutation) {
		m.oldValue = func(context.Context) (*SagaExecutionData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SagaExecutionDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SagaExecutionDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SagaExecutionData entities.
func (m *SagaExecutionDataMutation) SetID(id schema.SagaExecutionDataID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SagaExecutionDataMutation) ID() (id schema.SagaExecutionDataID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SagaExecutionDataMutation) IDs(ctx context.Context) ([]schema.SagaExecutionDataID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []schema.SagaExecutionDataID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SagaExecutionData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExecutionID sets the "execution_id" field.
func (m *SagaExecutionDataMutation) SetExecutionID(sei schema.SagaExecutionID) {
	m.execution = &sei
}

// ExecutionID returns the value of the "execution_id" field in the mutation.
func (m *SagaExecutionDataMutation) ExecutionID() (r schema.SagaExecutionID, exists bool) {
	v := m.execution
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutionID returns the old "execution_id" field's value of the SagaExecutionData entity.
// If the SagaExecutionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaExecutionDataMutation) OldExecutionID(ctx context.Context) (v schema.SagaExecutionID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutionID: %w", err)
	}
	return oldValue.ExecutionID, nil
}

// ResetExecutionID resets all changes to the "execution_id" field.
func (m *SagaExecutionDataMutation) ResetExecutionID() {
	m.execution = nil
}

// SetLastHeartbeat sets the "last_heartbeat" field.
func (m *SagaExecutionDataMutation) SetLastHeartbeat(t time.Time) {
	m.last_heartbeat = &t
}

// LastHeartbeat returns the value of the "last_heartbeat" field in the mutation.
func (m *SagaExecutionDataMutation) LastHeartbeat() (r time.Time, exists bool) {
	v := m.last_heartbeat
	if v == nil {
		return
	}
	return *v, true
}

// OldLastHeartbeat returns the old "last_heartbeat" field's value of the SagaExecutionData entity.
// If the SagaExecutionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaExecutionDataMutation) OldLastHeartbeat(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastHeartbeat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastHeartbeat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastHeartbeat: %w", err)
	}
	return oldValue.LastHeartbeat, nil
}

// ClearLastHeartbeat clears the value of the "last_heartbeat" field.
func (m *SagaExecutionDataMutation) ClearLastHeartbeat() {
	m.last_heartbeat = nil
	m.clearedFields[sagaexecutiondata.FieldLastHeartbeat] = struct{}{}
}

// LastHeartbeatCleared returns if the "last_heartbeat" field was cleared in this mutation.
func (m *SagaExecutionDataMutation) LastHeartbeatCleared() bool {
	_, ok := m.clearedFields[sagaexecutiondata.FieldLastHeartbeat]
	return ok
}

// ResetLastHeartbeat resets all changes to the "last_heartbeat" field.
func (m *SagaExecutionDataMutation) ResetLastHeartbeat() {
	m.last_heartbeat = nil
	delete(m.clearedFields, sagaexecutiondata.FieldLastHeartbeat)
}

// SetStepIndex sets the "step_index" field.
func (m *SagaExecutionDataMutation) SetStepIndex(i int) {
	m.step_index = &i
	m.addstep_index = nil
}

// StepIndex returns the value of the "step_index" field in the mutation.
func (m *SagaExecutionDataMutation) StepIndex() (r int, exists bool) {
	v := m.step_index
	if v == nil {
		return
	}
	return *v, true
}

// OldStepIndex returns the old "step_index" field's value of the SagaExecutionData entity.
// If the SagaExecutionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaExecutionDataMutation) OldStepIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStepIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStepIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStepIndex: %w", err)
	}
	return oldValue.StepIndex, nil
}

// AddStepIndex adds i to the "step_index" field.
func (m *SagaExecutionDataMutation) AddStepIndex(i int) {
	if m.addstep_index != nil {
		*m.addstep_index += i
	} else {
		m.addstep_index = &i
	}
}

// AddedStepIndex returns the value that was added to the "step_index" field in this mutation.
func (m *SagaExecutionDataMutation) AddedStepIndex() (r int, exists bool) {
	v := m.addstep_index
	if v == nil {
		return
	}
	return *v, true
}

// ResetStepIndex resets all changes to the "step_index" field.
func (m *SagaExecutionDataMutation) ResetStepIndex() {
	m.step_index = nil
	m.addstep_index = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SagaExecutionDataMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SagaExecutionDataMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SagaExecutionData entity.
// If the SagaExecutionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaExecutionDataMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SagaExecutionDataMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SagaExecutionDataMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SagaExecutionDataMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SagaExecutionData entity.
// If the SagaExecutionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaExecutionDataMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SagaExecutionDataMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearExecution clears the "execution" edge to the SagaExecution entity.
func (m *SagaExecutionDataMutation) ClearExecution() {
	m.clearedexecution = true
	m.clearedFields[sagaexecutiondata.FieldExecutionID] = struct{}{}
}

// ExecutionCleared reports if the "execution" edge to the SagaExecution entity was cleared.
func (m *SagaExecutionDataMutation) ExecutionCleared() bool {
	return m.clearedexecution
}

// ExecutionIDs returns the "execution" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExecutionID instead. It exists only for internal usage by the builders.
func (m *SagaExecutionDataMutation) ExecutionIDs() (ids []schema.SagaExecutionID) {
	if id := m.execution; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExecution resets all changes to the "execution" edge.
func (m *SagaExecutionDataMutation) ResetExecution() {
	m.execution = nil
	m.clearedexecution = false
}

// AddValueIDs adds the "values" edge to the SagaValue entity by ids.
func (m *SagaExecutionDataMutation) AddValueIDs(ids ...schema.SagaValueID) {
	if m.values == nil {
		m.values = make(map[schema.SagaValueID]struct{})
	}
	for i := range ids {
		m.values[ids[i]] = struct{}{}
	}
}

// ClearValues clears the "values" edge to the SagaValue entity.
func (m *SagaExecutionDataMutation) ClearValues() {
	m.clearedvalues = true
}

// ValuesCleared reports if the "values" edge to the SagaValue entity was cleared.
func (m *SagaExecutionDataMutation) ValuesCleared() bool {
	return m.clearedvalues
}

// RemoveValueIDs removes the "values" edge to the SagaValue entity by IDs.
func (m *SagaExecutionDataMutation) RemoveValueIDs(ids ...schema.SagaValueID) {
	if m.removedvalues == nil {
		m.removedvalues = make(map[schema.SagaValueID]struct{})
	}
	for i := range ids {
		delete(m.values, ids[i])
		m.removedvalues[ids[i]] = struct{}{}
	}
}

// RemovedValues returns the removed IDs of the "values" edge to the SagaValue entity.
func (m *SagaExecutionDataMutation) RemovedValuesIDs() (ids []schema.SagaValueID) {
	for id := range m.removedvalues {
		ids = append(ids, id)
	}
	return
}

// ValuesIDs returns the "values" edge IDs in the mutation.
func (m *SagaExecutionDataMutation) ValuesIDs() (ids []schema.SagaValueID) {
	for id := range m.values {
		ids = append(ids, id)
	}
	return
}

// ResetValues resets all changes to the "values" edge.
func (m *SagaExecutionDataMutation) ResetValues() {
	m.values = nil
	m.clearedvalues = false
	m.removedvalues = nil
}

// Where appends a list predicates to the SagaExecutionDataMutation builder.
func (m *SagaExecutionDataMutation) Where(ps ...predicate.SagaExecutionData) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SagaExecutionDataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SagaExecutionDataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SagaExecutionData, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SagaExecutionDataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SagaExecutionDataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SagaExecutionData).
func (m *SagaExecutionDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SagaExecutionDataMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.execution != nil {
		fields = append(fields, sagaexecutiondata.FieldExecutionID)
	}
	if m.last_heartbeat != nil {
		fields = append(fields, sagaexecutiondata.FieldLastHeartbeat)
	}
	if m.step_index != nil {
		fields = append(fields, sagaexecutiondata.FieldStepIndex)
	}
	if m.created_at != nil {
		fields = append(fields, sagaexecutiondata.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sagaexecutiondata.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SagaExecutionDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sagaexecutiondata.FieldExecutionID:
		return m.ExecutionID()
	case sagaexecutiondata.FieldLastHeartbeat:
		return m.LastHeartbeat()
	case sagaexecutiondata.FieldStepIndex:
		return m.StepIndex()
	case sagaexecutiondata.FieldCreatedAt:
		return m.CreatedAt()
	case sagaexecutiondata.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SagaExecutionDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sagaexecutiondata.FieldExecutionID:
		return m.OldExecutionID(ctx)
	case sagaexecutiondata.FieldLastHeartbeat:
		return m.OldLastHeartbeat(ctx)
	case sagaexecutiondata.FieldStepIndex:
		return m.OldStepIndex(ctx)
	case sagaexecutiondata.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sagaexecutiondata.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SagaExecutionData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SagaExecutionDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sagaexecutiondata.FieldExecutionID:
		v, ok := value.(schema.SagaExecutionID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutionID(v)
		return nil
	case sagaexecutiondata.FieldLastHeartbeat:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastHeartbeat(v)
		return nil
	case sagaexecutiondata.FieldStepIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStepIndex(v)
		return nil
	case sagaexecutiondata.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sagaexecutiondata.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SagaExecutionData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SagaExecutionDataMutation) AddedFields() []string {
	var fields []string
	if m.addstep_index != nil {
		fields = append(fields, sagaexecutiondata.FieldStepIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SagaExecutionDataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sagaexecutiondata.FieldStepIndex:
		return m.AddedStepIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SagaExecutionDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sagaexecutiondata.FieldStepIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStepIndex(v)
		return nil
	}
	return fmt.Errorf("unknown SagaExecutionData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SagaExecutionDataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sagaexecutiondata.FieldLastHeartbeat) {
		fields = append(fields, sagaexecutiondata.FieldLastHeartbeat)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SagaExecutionDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SagaExecutionDataMutation) ClearField(name string) error {
	switch name {
	case sagaexecutiondata.FieldLastHeartbeat:
		m.ClearLastHeartbeat()
		return nil
	}
	return fmt.Errorf("unknown SagaExecutionData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SagaExecutionDataMutation) ResetField(name string) error {
	switch name {
	case sagaexecutiondata.FieldExecutionID:
		m.ResetExecutionID()
		return nil
	case sagaexecutiondata.FieldLastHeartbeat:
		m.ResetLastHeartbeat()
		return nil
	case sagaexecutiondata.FieldStepIndex:
		m.ResetStepIndex()
		return nil
	case sagaexecutiondata.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sagaexecutiondata.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SagaExecutionData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SagaExecutionDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.execution != nil {
		edges = append(edges, sagaexecutiondata.EdgeExecution)
	}
	if m.values != nil {
		edges = append(edges, sagaexecutiondata.EdgeValues)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SagaExecutionDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sagaexecutiondata.EdgeExecution:
		if id := m.execution; id != nil {
			return []ent.Value{*id}
		}
	case sagaexecutiondata.EdgeValues:
		ids := make([]ent.Value, 0, len(m.values))
		for id := range m.values {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SagaExecutionDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedvalues != nil {
		edges = append(edges, sagaexecutiondata.EdgeValues)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SagaExecutionDataMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sagaexecutiondata.EdgeValues:
		ids := make([]ent.Value, 0, len(m.removedvalues))
		for id := range m.removedvalues {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SagaExecutionDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedexecution {
		edges = append(edges, sagaexecutiondata.EdgeExecution)
	}
	if m.clearedvalues {
		edges = append(edges, sagaexecutiondata.EdgeValues)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SagaExecutionDataMutation) EdgeCleared(name string) bool {
	switch name {
	case sagaexecutiondata.EdgeExecution:
		return m.clearedexecution
	case sagaexecutiondata.EdgeValues:
		return m.clearedvalues
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SagaExecutionDataMutation) ClearEdge(name string) error {
	switch name {
	case sagaexecutiondata.EdgeExecution:
		m.ClearExecution()
		return nil
	}
	return fmt.Errorf("unknown SagaExecutionData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SagaExecutionDataMutation) ResetEdge(name string) error {
	switch name {
	case sagaexecutiondata.EdgeExecution:
		m.ResetExecution()
		return nil
	case sagaexecutiondata.EdgeValues:
		m.ResetValues()
		return nil
	}
	return fmt.Errorf("unknown SagaExecutionData edge %s", name)
}

// SagaValueMutation represents an operation that mutates the SagaValue nodes in the graph.
type SagaValueMutation struct {
	config
	op                    Op
	typ                   string
	id                    *schema.SagaValueID
	key                   *string
	value                 *[]byte
	saga_entity_id        *schema.SagaEntityID
	addsaga_entity_id     *schema.SagaEntityID
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	execution             *schema.SagaExecutionID
	clearedexecution      bool
	saga_data             *schema.SagaDataID
	clearedsaga_data      bool
	execution_data        *schema.SagaExecutionDataID
	clearedexecution_data bool
	done                  bool
	oldValue              func(context.Context) (*SagaValue, error)
	predicates            []predicate.SagaValue
}

var _ ent.Mutation = (*SagaValueMutation)(nil)

// sagavalueOption allows management of the mutation configuration using functional options.
type sagavalueOption func(*SagaValueMutation)

// newSagaValueMutation creates new mutation for the SagaValue entity.
func newSagaValueMutation(c config, op Op, opts ...sagavalueOption) *SagaValueMutation {
	m := &SagaValueMutation{
		config:        c,
		op:            op,
		typ:           TypeSagaValue,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSagaValueID sets the ID field of the mutation.
func withSagaValueID(id schema.SagaValueID) sagavalueOption {
	return func(m *SagaValueMutation) {
		var (
			err   error
			once  sync.Once
			value *SagaValue
		)
		m.oldValue = func(ctx context.Context) (*SagaValue, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SagaValue.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSagaValue sets the old SagaValue of the mutation.
func withSagaValue(node *SagaValue) sagavalueOption {
	return func(m *SagaValueMutation) {
		m.oldValue = func(context.Context) (*SagaValue, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SagaValueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SagaValueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SagaValue entities.
func (m *SagaValueMutation) SetID(id schema.SagaValueID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SagaValueMutation) ID() (id schema.SagaValueID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SagaValueMutation) IDs(ctx context.Context) ([]schema.SagaValueID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []schema.SagaValueID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SagaValue.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKey sets the "key" field.
func (m *SagaValueMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *SagaValueMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the SagaValue entity.
// If the SagaValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaValueMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *SagaValueMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *SagaValueMutation) SetValue(b []byte) {
	m.value = &b
}

// Value returns the value of the "value" field in the mutation.
func (m *SagaValueMutation) Value() (r []byte, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the SagaValue entity.
// If the SagaValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaValueMutation) OldValue(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *SagaValueMutation) ResetValue() {
	m.value = nil
}

// SetSagaEntityID sets the "saga_entity_id" field.
func (m *SagaValueMutation) SetSagaEntityID(sei schema.SagaEntityID) {
	m.saga_entity_id = &sei
	m.addsaga_entity_id = nil
}

// SagaEntityID returns the value of the "saga_entity_id" field in the mutation.
func (m *SagaValueMutation) SagaEntityID() (r schema.SagaEntityID, exists bool) {
	v := m.saga_entity_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSagaEntityID returns the old "saga_entity_id" field's value of the SagaValue entity.
// If the SagaValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaValueMutation) OldSagaEntityID(ctx context.Context) (v schema.SagaEntityID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSagaEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSagaEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSagaEntityID: %w", err)
	}
	return oldValue.SagaEntityID, nil
}

// AddSagaEntityID adds sei to the "saga_entity_id" field.
func (m *SagaValueMutation) AddSagaEntityID(sei schema.SagaEntityID) {
	if m.addsaga_entity_id != nil {
		*m.addsaga_entity_id += sei
	} else {
		m.addsaga_entity_id = &sei
	}
}

// AddedSagaEntityID returns the value that was added to the "saga_entity_id" field in this mutation.
func (m *SagaValueMutation) AddedSagaEntityID() (r schema.SagaEntityID, exists bool) {
	v := m.addsaga_entity_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSagaEntityID resets all changes to the "saga_entity_id" field.
func (m *SagaValueMutation) ResetSagaEntityID() {
	m.saga_entity_id = nil
	m.addsaga_entity_id = nil
}

// SetSagaExecutionID sets the "saga_execution_id" field.
func (m *SagaValueMutation) SetSagaExecutionID(sei schema.SagaExecutionID) {
	m.execution = &sei
}

// SagaExecutionID returns the value of the "saga_execution_id" field in the mutation.
func (m *SagaValueMutation) SagaExecutionID() (r schema.SagaExecutionID, exists bool) {
	v := m.execution
	if v == nil {
		return
	}
	return *v, true
}

// OldSagaExecutionID returns the old "saga_execution_id" field's value of the SagaValue entity.
// If the SagaValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaValueMutation) OldSagaExecutionID(ctx context.Context) (v schema.SagaExecutionID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSagaExecutionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSagaExecutionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSagaExecutionID: %w", err)
	}
	return oldValue.SagaExecutionID, nil
}

// ResetSagaExecutionID resets all changes to the "saga_execution_id" field.
func (m *SagaValueMutation) ResetSagaExecutionID() {
	m.execution = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SagaValueMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SagaValueMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SagaValue entity.
// If the SagaValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaValueMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SagaValueMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SagaValueMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SagaValueMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SagaValue entity.
// If the SagaValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaValueMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SagaValueMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetExecutionID sets the "execution" edge to the SagaExecution entity by id.
func (m *SagaValueMutation) SetExecutionID(id schema.SagaExecutionID) {
	m.execution = &id
}

// ClearExecution clears the "execution" edge to the SagaExecution entity.
func (m *SagaValueMutation) ClearExecution() {
	m.clearedexecution = true
	m.clearedFields[sagavalue.FieldSagaExecutionID] = struct{}{}
}

// ExecutionCleared reports if the "execution" edge to the SagaExecution entity was cleared.
func (m *SagaValueMutation) ExecutionCleared() bool {
	return m.clearedexecution
}

// ExecutionID returns the "execution" edge ID in the mutation.
func (m *SagaValueMutation) ExecutionID() (id schema.SagaExecutionID, exists bool) {
	if m.execution != nil {
		return *m.execution, true
	}
	return
}

// ExecutionIDs returns the "execution" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExecutionID instead. It exists only for internal usage by the builders.
func (m *SagaValueMutation) ExecutionIDs() (ids []schema.SagaExecutionID) {
	if id := m.execution; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExecution resets all changes to the "execution" edge.
func (m *SagaValueMutation) ResetExecution() {
	m.execution = nil
	m.clearedexecution = false
}

// SetSagaDataID sets the "saga_data" edge to the SagaData entity by id.
func (m *SagaValueMutation) SetSagaDataID(id schema.SagaDataID) {
	m.saga_data = &id
}

// ClearSagaData clears the "saga_data" edge to the SagaData entity.
func (m *SagaValueMutation) ClearSagaData() {
	m.clearedsaga_data = true
}

// SagaDataCleared reports if the "saga_data" edge to the SagaData entity was cleared.
func (m *SagaValueMutation) SagaDataCleared() bool {
	return m.clearedsaga_data
}

// SagaDataID returns the "saga_data" edge ID in the mutation.
func (m *SagaValueMutation) SagaDataID() (id schema.SagaDataID, exists bool) {
	if m.saga_data != nil {
		return *m.saga_data, true
	}
	return
}

// SagaDataIDs returns the "saga_data" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SagaDataID instead. It exists only for internal usage by the builders.
func (m *SagaValueMutation) SagaDataIDs() (ids []schema.SagaDataID) {
	if id := m.saga_data; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSagaData resets all changes to the "saga_data" edge.
func (m *SagaValueMutation) ResetSagaData() {
	m.saga_data = nil
	m.clearedsaga_data = false
}

// SetExecutionDataID sets the "execution_data" edge to the SagaExecutionData entity by id.
func (m *SagaValueMutation) SetExecutionDataID(id schema.SagaExecutionDataID) {
	m.execution_data = &id
}

// ClearExecutionData clears the "execution_data" edge to the SagaExecutionData entity.
func (m *SagaValueMutation) ClearExecutionData() {
	m.clearedexecution_data = true
}

// ExecutionDataCleared reports if the "execution_data" edge to the SagaExecutionData entity was cleared.
func (m *SagaValueMutation) ExecutionDataCleared() bool {
	return m.clearedexecution_data
}

// ExecutionDataID returns the "execution_data" edge ID in the mutation.
func (m *SagaValueMutation) ExecutionDataID() (id schema.SagaExecutionDataID, exists bool) {
	if m.execution_data != nil {
		return *m.execution_data, true
	}
	return
}

// ExecutionDataIDs returns the "execution_data" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExecutionDataID instead. It exists only for internal usage by the builders.
func (m *SagaValueMutation) ExecutionDataIDs() (ids []schema.SagaExecutionDataID) {
	if id := m.execution_data; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExecutionData resets all changes to the "execution_data" edge.
func (m *SagaValueMutation) ResetExecutionData() {
	m.execution_data = nil
	m.clearedexecution_data = false
}

// Where appends a list predicates to the SagaValueMutation builder.
func (m *SagaValueMutation) Where(ps ...predicate.SagaValue) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SagaValueMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SagaValueMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SagaValue, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SagaValueMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SagaValueMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SagaValue).
func (m *SagaValueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SagaValueMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.key != nil {
		fields = append(fields, sagavalue.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, sagavalue.FieldValue)
	}
	if m.saga_entity_id != nil {
		fields = append(fields, sagavalue.FieldSagaEntityID)
	}
	if m.execution != nil {
		fields = append(fields, sagavalue.FieldSagaExecutionID)
	}
	if m.created_at != nil {
		fields = append(fields, sagavalue.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sagavalue.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SagaValueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sagavalue.FieldKey:
		return m.Key()
	case sagavalue.FieldValue:
		return m.Value()
	case sagavalue.FieldSagaEntityID:
		return m.SagaEntityID()
	case sagavalue.FieldSagaExecutionID:
		return m.SagaExecutionID()
	case sagavalue.FieldCreatedAt:
		return m.CreatedAt()
	case sagavalue.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SagaValueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sagavalue.FieldKey:
		return m.OldKey(ctx)
	case sagavalue.FieldValue:
		return m.OldValue(ctx)
	case sagavalue.FieldSagaEntityID:
		return m.OldSagaEntityID(ctx)
	case sagavalue.FieldSagaExecutionID:
		return m.OldSagaExecutionID(ctx)
	case sagavalue.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sagavalue.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SagaValue field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SagaValueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sagavalue.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case sagavalue.FieldValue:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case sagavalue.FieldSagaEntityID:
		v, ok := value.(schema.SagaEntityID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSagaEntityID(v)
		return nil
	case sagavalue.FieldSagaExecutionID:
		v, ok := value.(schema.SagaExecutionID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSagaExecutionID(v)
		return nil
	case sagavalue.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sagavalue.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SagaValue field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SagaValueMutation) AddedFields() []string {
	var fields []string
	if m.addsaga_entity_id != nil {
		fields = append(fields, sagavalue.FieldSagaEntityID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SagaValueMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sagavalue.FieldSagaEntityID:
		return m.AddedSagaEntityID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SagaValueMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sagavalue.FieldSagaEntityID:
		v, ok := value.(schema.SagaEntityID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSagaEntityID(v)
		return nil
	}
	return fmt.Errorf("unknown SagaValue numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SagaValueMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SagaValueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SagaValueMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SagaValue nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SagaValueMutation) ResetField(name string) error {
	switch name {
	case sagavalue.FieldKey:
		m.ResetKey()
		return nil
	case sagavalue.FieldValue:
		m.ResetValue()
		return nil
	case sagavalue.FieldSagaEntityID:
		m.ResetSagaEntityID()
		return nil
	case sagavalue.FieldSagaExecutionID:
		m.ResetSagaExecutionID()
		return nil
	case sagavalue.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sagavalue.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SagaValue field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SagaValueMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.execution != nil {
		edges = append(edges, sagavalue.EdgeExecution)
	}
	if m.saga_data != nil {
		edges = append(edges, sagavalue.EdgeSagaData)
	}
	if m.execution_data != nil {
		edges = append(edges, sagavalue.EdgeExecutionData)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SagaValueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sagavalue.EdgeExecution:
		if id := m.execution; id != nil {
			return []ent.Value{*id}
		}
	case sagavalue.EdgeSagaData:
		if id := m.saga_data; id != nil {
			return []ent.Value{*id}
		}
	case sagavalue.EdgeExecutionData:
		if id := m.execution_data; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SagaValueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SagaValueMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SagaValueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedexecution {
		edges = append(edges, sagavalue.EdgeExecution)
	}
	if m.clearedsaga_data {
		edges = append(edges, sagavalue.EdgeSagaData)
	}
	if m.clearedexecution_data {
		edges = append(edges, sagavalue.EdgeExecutionData)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SagaValueMutation) EdgeCleared(name string) bool {
	switch name {
	case sagavalue.EdgeExecution:
		return m.clearedexecution
	case sagavalue.EdgeSagaData:
		return m.clearedsaga_data
	case sagavalue.EdgeExecutionData:
		return m.clearedexecution_data
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SagaValueMutation) ClearEdge(name string) error {
	switch name {
	case sagavalue.EdgeExecution:
		m.ClearExecution()
		return nil
	case sagavalue.EdgeSagaData:
		m.ClearSagaData()
		return nil
	case sagavalue.EdgeExecutionData:
		m.ClearExecutionData()
		return nil
	}
	return fmt.Errorf("unknown SagaValue unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SagaValueMutation) ResetEdge(name string) error {
	switch name {
	case sagavalue.EdgeExecution:
		m.ResetExecution()
		return nil
	case sagavalue.EdgeSagaData:
		m.ResetSagaData()
		return nil
	case sagavalue.EdgeExecutionData:
		m.ResetExecutionData()
		return nil
	}
	return fmt.Errorf("unknown SagaValue edge %s", name)
}

// SideEffectDataMutation represents an operation that mutates the SideEffectData nodes in the graph.
type SideEffectDataMutation struct {
	config
	op                 Op
	typ                string
	id                 *schema.SideEffectDataID
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	side_effect        *schema.SideEffectEntityID
	clearedside_effect bool
	done               bool
	oldValue           func(context.Context) (*SideEffectData, error)
	predicates         []predicate.SideEffectData
}

var _ ent.Mutation = (*SideEffectDataMutation)(nil)

// sideeffectdataOption allows management of the mutation configuration using functional options.
type sideeffectdataOption func(*SideEffectDataMutation)

// newSideEffectDataMutation creates new mutation for the SideEffectData entity.
func newSideEffectDataMutation(c config, op Op, opts ...sideeffectdataOption) *SideEffectDataMutation {
	m := &SideEffectDataMutation{
		config:        c,
		op:            op,
		typ:           TypeSideEffectData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSideEffectDataID sets the ID field of the mutation.
func withSideEffectDataID(id schema.SideEffectDataID) sideeffectdataOption {
	return func(m *SideEffectDataMutation) {
		var (
			err   error
			once  sync.Once
			value *SideEffectData
		)
		m.oldValue = func(ctx context.Context) (*SideEffectData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SideEffectData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSideEffectData sets the old SideEffectData of the mutation.
func withSideEffectData(node *SideEffectData) sideeffectdataOption {
	return func(m *SideEffectDataMutation) {
		m.oldValue = func(context.Context) (*SideEffectData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SideEffectDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SideEffectDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SideEffectData entities.
func (m *SideEffectDataMutation) SetID(id schema.SideEffectDataID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SideEffectDataMutation) ID() (id schema.SideEffectDataID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SideEffectDataMutation) IDs(ctx context.Context) ([]schema.SideEffectDataID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []schema.SideEffectDataID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SideEffectData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntityID sets the "entity_id" field.
func (m *SideEffectDataMutation) SetEntityID(seei schema.SideEffectEntityID) {
	m.side_effect = &seei
}

// EntityID returns the value of the "entity_id" field in the mutation.
func (m *SideEffectDataMutation) EntityID() (r schema.SideEffectEntityID, exists bool) {
	v := m.side_effect
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityID returns the old "entity_id" field's value of the SideEffectData entity.
// If the SideEffectData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectDataMutation) OldEntityID(ctx context.Context) (v schema.SideEffectEntityID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityID: %w", err)
	}
	return oldValue.EntityID, nil
}

// ResetEntityID resets all changes to the "entity_id" field.
func (m *SideEffectDataMutation) ResetEntityID() {
	m.side_effect = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SideEffectDataMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SideEffectDataMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SideEffectData entity.
// If the SideEffectData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectDataMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SideEffectDataMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SideEffectDataMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SideEffectDataMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SideEffectData entity.
// If the SideEffectData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectDataMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SideEffectDataMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSideEffectID sets the "side_effect" edge to the SideEffectEntity entity by id.
func (m *SideEffectDataMutation) SetSideEffectID(id schema.SideEffectEntityID) {
	m.side_effect = &id
}

// ClearSideEffect clears the "side_effect" edge to the SideEffectEntity entity.
func (m *SideEffectDataMutation) ClearSideEffect() {
	m.clearedside_effect = true
	m.clearedFields[sideeffectdata.FieldEntityID] = struct{}{}
}

// SideEffectCleared reports if the "side_effect" edge to the SideEffectEntity entity was cleared.
func (m *SideEffectDataMutation) SideEffectCleared() bool {
	return m.clearedside_effect
}

// SideEffectID returns the "side_effect" edge ID in the mutation.
func (m *SideEffectDataMutation) SideEffectID() (id schema.SideEffectEntityID, exists bool) {
	if m.side_effect != nil {
		return *m.side_effect, true
	}
	return
}

// SideEffectIDs returns the "side_effect" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SideEffectID instead. It exists only for internal usage by the builders.
func (m *SideEffectDataMutation) SideEffectIDs() (ids []schema.SideEffectEntityID) {
	if id := m.side_effect; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSideEffect resets all changes to the "side_effect" edge.
func (m *SideEffectDataMutation) ResetSideEffect() {
	m.side_effect = nil
	m.clearedside_effect = false
}

// Where appends a list predicates to the SideEffectDataMutation builder.
func (m *SideEffectDataMutation) Where(ps ...predicate.SideEffectData) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SideEffectDataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SideEffectDataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SideEffectData, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SideEffectDataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SideEffectDataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SideEffectData).
func (m *SideEffectDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SideEffectDataMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.side_effect != nil {
		fields = append(fields, sideeffectdata.FieldEntityID)
	}
	if m.created_at != nil {
		fields = append(fields, sideeffectdata.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sideeffectdata.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SideEffectDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sideeffectdata.FieldEntityID:
		return m.EntityID()
	case sideeffectdata.FieldCreatedAt:
		return m.CreatedAt()
	case sideeffectdata.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SideEffectDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sideeffectdata.FieldEntityID:
		return m.OldEntityID(ctx)
	case sideeffectdata.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sideeffectdata.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SideEffectData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SideEffectDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sideeffectdata.FieldEntityID:
		v, ok := value.(schema.SideEffectEntityID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityID(v)
		return nil
	case sideeffectdata.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sideeffectdata.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SideEffectData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SideEffectDataMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SideEffectDataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SideEffectDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SideEffectData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SideEffectDataMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SideEffectDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SideEffectDataMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SideEffectData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SideEffectDataMutation) ResetField(name string) error {
	switch name {
	case sideeffectdata.FieldEntityID:
		m.ResetEntityID()
		return nil
	case sideeffectdata.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sideeffectdata.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SideEffectData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SideEffectDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.side_effect != nil {
		edges = append(edges, sideeffectdata.EdgeSideEffect)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SideEffectDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sideeffectdata.EdgeSideEffect:
		if id := m.side_effect; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SideEffectDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SideEffectDataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SideEffectDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedside_effect {
		edges = append(edges, sideeffectdata.EdgeSideEffect)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SideEffectDataMutation) EdgeCleared(name string) bool {
	switch name {
	case sideeffectdata.EdgeSideEffect:
		return m.clearedside_effect
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SideEffectDataMutation) ClearEdge(name string) error {
	switch name {
	case sideeffectdata.EdgeSideEffect:
		m.ClearSideEffect()
		return nil
	}
	return fmt.Errorf("unknown SideEffectData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SideEffectDataMutation) ResetEdge(name string) error {
	switch name {
	case sideeffectdata.EdgeSideEffect:
		m.ResetSideEffect()
		return nil
	}
	return fmt.Errorf("unknown SideEffectData edge %s", name)
}

// SideEffectEntityMutation represents an operation that mutates the SideEffectEntity nodes in the graph.
type SideEffectEntityMutation struct {
	config
	op                      Op
	typ                     string
	id                      *schema.SideEffectEntityID
	handler_name            *string
	_type                   *schema.EntityType
	status                  *schema.EntityStatus
	step_id                 *schema.SideEffectStepID
	run_id                  *schema.RunID
	addrun_id               *schema.RunID
	retry_policy            *schema.RetryPolicy
	retry_state             *schema.RetryState
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	workflow                *schema.WorkflowEntityID
	clearedworkflow         bool
	side_effect_data        *schema.SideEffectDataID
	clearedside_effect_data bool
	executions              map[schema.SideEffectExecutionID]struct{}
	removedexecutions       map[schema.SideEffectExecutionID]struct{}
	clearedexecutions       bool
	done                    bool
	oldValue                func(context.Context) (*SideEffectEntity, error)
	predicates              []predicate.SideEffectEntity
}

var _ ent.Mutation = (*SideEffectEntityMutation)(nil)

// sideeffectentityOption allows management of the mutation configuration using functional options.
type sideeffectentityOption func(*SideEffectEntityMutation)

// newSideEffectEntityMutation creates new mutation for the SideEffectEntity entity.
func newSideEffectEntityMutation(c config, op Op, opts ...sideeffectentityOption) *SideEffectEntityMutation {
	m := &SideEffectEntityMutation{
		config:        c,
		op:            op,
		typ:           TypeSideEffectEntity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSideEffectEntityID sets the ID field of the mutation.
func withSideEffectEntityID(id schema.SideEffectEntityID) sideeffectentityOption {
	return func(m *SideEffectEntityMutation) {
		var (
			err   error
			once  sync.Once
			value *SideEffectEntity
		)
		m.oldValue = func(ctx context.Context) (*SideEffectEntity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SideEffectEntity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSideEffectEntity sets the old SideEffectEntity of the mutation.
func withSideEffectEntity(node *SideEffectEntity) sideeffectentityOption {
	return func(m *SideEffectEntityMutation) {
		m.oldValue = func(context.Context) (*SideEffectEntity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SideEffectEntityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SideEffectEntityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SideEffectEntity entities.
func (m *SideEffectEntityMutation) SetID(id schema.SideEffectEntityID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SideEffectEntityMutation) ID() (id schema.SideEffectEntityID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SideEffectEntityMutation) IDs(ctx context.Context) ([]schema.SideEffectEntityID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []schema.SideEffectEntityID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SideEffectEntity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHandlerName sets the "handler_name" field.
func (m *SideEffectEntityMutation) SetHandlerName(s string) {
	m.handler_name = &s
}

// HandlerName returns the value of the "handler_name" field in the mutation.
func (m *SideEffectEntityMutation) HandlerName() (r string, exists bool) {
	v := m.handler_name
	if v == nil {
		return
	}
	return *v, true
}

// OldHandlerName returns the old "handler_name" field's value of the SideEffectEntity entity.
// If the SideEffectEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectEntityMutation) OldHandlerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandlerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandlerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandlerName: %w", err)
	}
	return oldValue.HandlerName, nil
}

// ResetHandlerName resets all changes to the "handler_name" field.
func (m *SideEffectEntityMutation) ResetHandlerName() {
	m.handler_name = nil
}

// SetType sets the "type" field.
func (m *SideEffectEntityMutation) SetType(st schema.EntityType) {
	m._type = &st
}

// GetType returns the value of the "type" field in the mutation.
func (m *SideEffectEntityMutation) GetType() (r schema.EntityType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the SideEffectEntity entity.
// If the SideEffectEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectEntityMutation) OldType(ctx context.Context) (v schema.EntityType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *SideEffectEntityMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *SideEffectEntityMutation) SetStatus(ss schema.EntityStatus) {
	m.status = &ss
}

// Status returns the value of the "status" field in the mutation.
func (m *SideEffectEntityMutation) Status() (r schema.EntityStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SideEffectEntity entity.
// If the SideEffectEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectEntityMutation) OldStatus(ctx context.Context) (v schema.EntityStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SideEffectEntityMutation) ResetStatus() {
	m.status = nil
}

// SetStepID sets the "step_id" field.
func (m *SideEffectEntityMutation) SetStepID(sesi schema.SideEffectStepID) {
	m.step_id = &sesi
}

// StepID returns the value of the "step_id" field in the mutation.
func (m *SideEffectEntityMutation) StepID() (r schema.SideEffectStepID, exists bool) {
	v := m.step_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStepID returns the old "step_id" field's value of the SideEffectEntity entity.
// If the SideEffectEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectEntityMutation) OldStepID(ctx context.Context) (v schema.SideEffectStepID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStepID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStepID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStepID: %w", err)
	}
	return oldValue.StepID, nil
}

// ResetStepID resets all changes to the "step_id" field.
func (m *SideEffectEntityMutation) ResetStepID() {
	m.step_id = nil
}

// SetRunID sets the "run_id" field.
func (m *SideEffectEntityMutation) SetRunID(si schema.RunID) {
	m.run_id = &si
	m.addrun_id = nil
}

// RunID returns the value of the "run_id" field in the mutation.
func (m *SideEffectEntityMutation) RunID() (r schema.RunID, exists bool) {
	v := m.run_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRunID returns the old "run_id" field's value of the SideEffectEntity entity.
// If the SideEffectEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectEntityMutation) OldRunID(ctx context.Context) (v schema.RunID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunID: %w", err)
	}
	return oldValue.RunID, nil
}

// AddRunID adds si to the "run_id" field.
func (m *SideEffectEntityMutation) AddRunID(si schema.RunID) {
	if m.addrun_id != nil {
		*m.addrun_id += si
	} else {
		m.addrun_id = &si
	}
}

// AddedRunID returns the value that was added to the "run_id" field in this mutation.
func (m *SideEffectEntityMutation) AddedRunID() (r schema.RunID, exists bool) {
	v := m.addrun_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRunID resets all changes to the "run_id" field.
func (m *SideEffectEntityMutation) ResetRunID() {
	m.run_id = nil
	m.addrun_id = nil
}

// SetRetryPolicy sets the "retry_policy" field.
func (m *SideEffectEntityMutation) SetRetryPolicy(sp schema.RetryPolicy) {
	m.retry_policy = &sp
}

// RetryPolicy returns the value of the "retry_policy" field in the mutation.
func (m *SideEffectEntityMutation) RetryPolicy() (r schema.RetryPolicy, exists bool) {
	v := m.retry_policy
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryPolicy returns the old "retry_policy" field's value of the SideEffectEntity entity.
// If the SideEffectEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectEntityMutation) OldRetryPolicy(ctx context.Context) (v schema.RetryPolicy, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryPolicy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryPolicy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryPolicy: %w", err)
	}
	return oldValue.RetryPolicy, nil
}

// ResetRetryPolicy resets all changes to the "retry_policy" field.
func (m *SideEffectEntityMutation) ResetRetryPolicy() {
	m.retry_policy = nil
}

// SetRetryState sets the "retry_state" field.
func (m *SideEffectEntityMutation) SetRetryState(ss schema.RetryState) {
	m.retry_state = &ss
}

// RetryState returns the value of the "retry_state" field in the mutation.
func (m *SideEffectEntityMutation) RetryState() (r schema.RetryState, exists bool) {
	v := m.retry_state
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryState returns the old "retry_state" field's value of the SideEffectEntity entity.
// If the SideEffectEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectEntityMutation) OldRetryState(ctx context.Context) (v schema.RetryState, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryState: %w", err)
	}
	return oldValue.RetryState, nil
}

// ResetRetryState resets all changes to the "retry_state" field.
func (m *SideEffectEntityMutation) ResetRetryState() {
	m.retry_state = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SideEffectEntityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SideEffectEntityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SideEffectEntity entity.
// If the SideEffectEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectEntityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SideEffectEntityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SideEffectEntityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SideEffectEntityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SideEffectEntity entity.
// If the SideEffectEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectEntityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SideEffectEntityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetWorkflowID sets the "workflow" edge to the WorkflowEntity entity by id.
func (m *SideEffectEntityMutation) SetWorkflowID(id schema.WorkflowEntityID) {
	m.workflow = &id
}

// ClearWorkflow clears the "workflow" edge to the WorkflowEntity entity.
func (m *SideEffectEntityMutation) ClearWorkflow() {
	m.clearedworkflow = true
}

// WorkflowCleared reports if the "workflow" edge to the WorkflowEntity entity was cleared.
func (m *SideEffectEntityMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowID returns the "workflow" edge ID in the mutation.
func (m *SideEffectEntityMutation) WorkflowID() (id schema.WorkflowEntityID, exists bool) {
	if m.workflow != nil {
		return *m.workflow, true
	}
	return
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *SideEffectEntityMutation) WorkflowIDs() (ids []schema.WorkflowEntityID) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *SideEffectEntityMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// SetSideEffectDataID sets the "side_effect_data" edge to the SideEffectData entity by id.
func (m *SideEffectEntityMutation) SetSideEffectDataID(id schema.SideEffectDataID) {
	m.side_effect_data = &id
}

// ClearSideEffectData clears the "side_effect_data" edge to the SideEffectData entity.
func (m *SideEffectEntityMutation) ClearSideEffectData() {
	m.clearedside_effect_data = true
}

// SideEffectDataCleared reports if the "side_effect_data" edge to the SideEffectData entity was cleared.
func (m *SideEffectEntityMutation) SideEffectDataCleared() bool {
	return m.clearedside_effect_data
}

// SideEffectDataID returns the "side_effect_data" edge ID in the mutation.
func (m *SideEffectEntityMutation) SideEffectDataID() (id schema.SideEffectDataID, exists bool) {
	if m.side_effect_data != nil {
		return *m.side_effect_data, true
	}
	return
}

// SideEffectDataIDs returns the "side_effect_data" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SideEffectDataID instead. It exists only for internal usage by the builders.
func (m *SideEffectEntityMutation) SideEffectDataIDs() (ids []schema.SideEffectDataID) {
	if id := m.side_effect_data; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSideEffectData resets all changes to the "side_effect_data" edge.
func (m *SideEffectEntityMutation) ResetSideEffectData() {
	m.side_effect_data = nil
	m.clearedside_effect_data = false
}

// AddExecutionIDs adds the "executions" edge to the SideEffectExecution entity by ids.
func (m *SideEffectEntityMutation) AddExecutionIDs(ids ...schema.SideEffectExecutionID) {
	if m.executions == nil {
		m.executions = make(map[schema.SideEffectExecutionID]struct{})
	}
	for i := range ids {
		m.executions[ids[i]] = struct{}{}
	}
}

// ClearExecutions clears the "executions" edge to the SideEffectExecution entity.
func (m *SideEffectEntityMutation) ClearExecutions() {
	m.clearedexecutions = true
}

// ExecutionsCleared reports if the "executions" edge to the SideEffectExecution entity was cleared.
func (m *SideEffectEntityMutation) ExecutionsCleared() bool {
	return m.clearedexecutions
}

// RemoveExecutionIDs removes the "executions" edge to the SideEffectExecution entity by IDs.
func (m *SideEffectEntityMutation) RemoveExecutionIDs(ids ...schema.SideEffectExecutionID) {
	if m.removedexecutions == nil {
		m.removedexecutions = make(map[schema.SideEffectExecutionID]struct{})
	}
	for i := range ids {
		delete(m.executions, ids[i])
		m.removedexecutions[ids[i]] = struct{}{}
	}
}

// RemovedExecutions returns the removed IDs of the "executions" edge to the SideEffectExecution entity.
func (m *SideEffectEntityMutation) RemovedExecutionsIDs() (ids []schema.SideEffectExecutionID) {
	for id := range m.removedexecutions {
		ids = append(ids, id)
	}
	return
}

// ExecutionsIDs returns the "executions" edge IDs in the mutation.
func (m *SideEffectEntityMutation) ExecutionsIDs() (ids []schema.SideEffectExecutionID) {
	for id := range m.executions {
		ids = append(ids, id)
	}
	return
}

// ResetExecutions resets all changes to the "executions" edge.
func (m *SideEffectEntityMutation) ResetExecutions() {
	m.executions = nil
	m.clearedexecutions = false
	m.removedexecutions = nil
}

// Where appends a list predicates to the SideEffectEntityMutation builder.
func (m *SideEffectEntityMutation) Where(ps ...predicate.SideEffectEntity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SideEffectEntityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SideEffectEntityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SideEffectEntity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SideEffectEntityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SideEffectEntityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SideEffectEntity).
func (m *SideEffectEntityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SideEffectEntityMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.handler_name != nil {
		fields = append(fields, sideeffectentity.FieldHandlerName)
	}
	if m._type != nil {
		fields = append(fields, sideeffectentity.FieldType)
	}
	if m.status != nil {
		fields = append(fields, sideeffectentity.FieldStatus)
	}
	if m.step_id != nil {
		fields = append(fields, sideeffectentity.FieldStepID)
	}
	if m.run_id != nil {
		fields = append(fields, sideeffectentity.FieldRunID)
	}
	if m.retry_policy != nil {
		fields = append(fields, sideeffectentity.FieldRetryPolicy)
	}
	if m.retry_state != nil {
		fields = append(fields, sideeffectentity.FieldRetryState)
	}
	if m.created_at != nil {
		fields = append(fields, sideeffectentity.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sideeffectentity.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SideEffectEntityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sideeffectentity.FieldHandlerName:
		return m.HandlerName()
	case sideeffectentity.FieldType:
		return m.GetType()
	case sideeffectentity.FieldStatus:
		return m.Status()
	case sideeffectentity.FieldStepID:
		return m.StepID()
	case sideeffectentity.FieldRunID:
		return m.RunID()
	case sideeffectentity.FieldRetryPolicy:
		return m.RetryPolicy()
	case sideeffectentity.FieldRetryState:
		return m.RetryState()
	case sideeffectentity.FieldCreatedAt:
		return m.CreatedAt()
	case sideeffectentity.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SideEffectEntityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sideeffectentity.FieldHandlerName:
		return m.OldHandlerName(ctx)
	case sideeffectentity.FieldType:
		return m.OldType(ctx)
	case sideeffectentity.FieldStatus:
		return m.OldStatus(ctx)
	case sideeffectentity.FieldStepID:
		return m.OldStepID(ctx)
	case sideeffectentity.FieldRunID:
		return m.OldRunID(ctx)
	case sideeffectentity.FieldRetryPolicy:
		return m.OldRetryPolicy(ctx)
	case sideeffectentity.FieldRetryState:
		return m.OldRetryState(ctx)
	case sideeffectentity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sideeffectentity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SideEffectEntity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SideEffectEntityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sideeffectentity.FieldHandlerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandlerName(v)
		return nil
	case sideeffectentity.FieldType:
		v, ok := value.(schema.EntityType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case sideeffectentity.FieldStatus:
		v, ok := value.(schema.EntityStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case sideeffectentity.FieldStepID:
		v, ok := value.(schema.SideEffectStepID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStepID(v)
		return nil
	case sideeffectentity.FieldRunID:
		v, ok := value.(schema.RunID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunID(v)
		return nil
	case sideeffectentity.FieldRetryPolicy:
		v, ok := value.(schema.RetryPolicy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryPolicy(v)
		return nil
	case sideeffectentity.FieldRetryState:
		v, ok := value.(schema.RetryState)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryState(v)
		return nil
	case sideeffectentity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sideeffectentity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SideEffectEntity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SideEffectEntityMutation) AddedFields() []string {
	var fields []string
	if m.addrun_id != nil {
		fields = append(fields, sideeffectentity.FieldRunID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SideEffectEntityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sideeffectentity.FieldRunID:
		return m.AddedRunID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SideEffectEntityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sideeffectentity.FieldRunID:
		v, ok := value.(schema.RunID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRunID(v)
		return nil
	}
	return fmt.Errorf("unknown SideEffectEntity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SideEffectEntityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SideEffectEntityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SideEffectEntityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SideEffectEntity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SideEffectEntityMutation) ResetField(name string) error {
	switch name {
	case sideeffectentity.FieldHandlerName:
		m.ResetHandlerName()
		return nil
	case sideeffectentity.FieldType:
		m.ResetType()
		return nil
	case sideeffectentity.FieldStatus:
		m.ResetStatus()
		return nil
	case sideeffectentity.FieldStepID:
		m.ResetStepID()
		return nil
	case sideeffectentity.FieldRunID:
		m.ResetRunID()
		return nil
	case sideeffectentity.FieldRetryPolicy:
		m.ResetRetryPolicy()
		return nil
	case sideeffectentity.FieldRetryState:
		m.ResetRetryState()
		return nil
	case sideeffectentity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sideeffectentity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SideEffectEntity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SideEffectEntityMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.workflow != nil {
		edges = append(edges, sideeffectentity.EdgeWorkflow)
	}
	if m.side_effect_data != nil {
		edges = append(edges, sideeffectentity.EdgeSideEffectData)
	}
	if m.executions != nil {
		edges = append(edges, sideeffectentity.EdgeExecutions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SideEffectEntityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sideeffectentity.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	case sideeffectentity.EdgeSideEffectData:
		if id := m.side_effect_data; id != nil {
			return []ent.Value{*id}
		}
	case sideeffectentity.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.executions))
		for id := range m.executions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SideEffectEntityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedexecutions != nil {
		edges = append(edges, sideeffectentity.EdgeExecutions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SideEffectEntityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sideeffectentity.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.removedexecutions))
		for id := range m.removedexecutions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SideEffectEntityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedworkflow {
		edges = append(edges, sideeffectentity.EdgeWorkflow)
	}
	if m.clearedside_effect_data {
		edges = append(edges, sideeffectentity.EdgeSideEffectData)
	}
	if m.clearedexecutions {
		edges = append(edges, sideeffectentity.EdgeExecutions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SideEffectEntityMutation) EdgeCleared(name string) bool {
	switch name {
	case sideeffectentity.EdgeWorkflow:
		return m.clearedworkflow
	case sideeffectentity.EdgeSideEffectData:
		return m.clearedside_effect_data
	case sideeffectentity.EdgeExecutions:
		return m.clearedexecutions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SideEffectEntityMutation) ClearEdge(name string) error {
	switch name {
	case sideeffectentity.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	case sideeffectentity.EdgeSideEffectData:
		m.ClearSideEffectData()
		return nil
	}
	return fmt.Errorf("unknown SideEffectEntity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SideEffectEntityMutation) ResetEdge(name string) error {
	switch name {
	case sideeffectentity.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	case sideeffectentity.EdgeSideEffectData:
		m.ResetSideEffectData()
		return nil
	case sideeffectentity.EdgeExecutions:
		m.ResetExecutions()
		return nil
	}
	return fmt.Errorf("unknown SideEffectEntity edge %s", name)
}

// SideEffectExecutionMutation represents an operation that mutates the SideEffectExecution nodes in the graph.
type SideEffectExecutionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *schema.SideEffectExecutionID
	started_at            *time.Time
	completed_at          *time.Time
	status                *schema.ExecutionStatus
	error                 *string
	stack_trace           *string
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	side_effect           *schema.SideEffectEntityID
	clearedside_effect    bool
	execution_data        *schema.SideEffectExecutionDataID
	clearedexecution_data bool
	done                  bool
	oldValue              func(context.Context) (*SideEffectExecution, error)
	predicates            []predicate.SideEffectExecution
}

var _ ent.Mutation = (*SideEffectExecutionMutation)(nil)

// sideeffectexecutionOption allows management of the mutation configuration using functional options.
type sideeffectexecutionOption func(*SideEffectExecutionMutation)

// newSideEffectExecutionMutation creates new mutation for the SideEffectExecution entity.
func newSideEffectExecutionMutation(c config, op Op, opts ...sideeffectexecutionOption) *SideEffectExecutionMutation {
	m := &SideEffectExecutionMutation{
		config:        c,
		op:            op,
		typ:           TypeSideEffectExecution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSideEffectExecutionID sets the ID field of the mutation.
func withSideEffectExecutionID(id schema.SideEffectExecutionID) sideeffectexecutionOption {
	return func(m *SideEffectExecutionMutation) {
		var (
			err   error
			once  sync.Once
			value *SideEffectExecution
		)
		m.oldValue = func(ctx context.Context) (*SideEffectExecution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SideEffectExecution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSideEffectExecution sets the old SideEffectExecution of the mutation.
func withSideEffectExecution(node *SideEffectExecution) sideeffectexecutionOption {
	return func(m *SideEffectExecutionMutation) {
		m.oldValue = func(context.Context) (*SideEffectExecution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SideEffectExecutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SideEffectExecutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SideEffectExecution entities.
func (m *SideEffectExecutionMutation) SetID(id schema.SideEffectExecutionID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SideEffectExecutionMutation) ID() (id schema.SideEffectExecutionID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SideEffectExecutionMutation) IDs(ctx context.Context) ([]schema.SideEffectExecutionID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []schema.SideEffectExecutionID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SideEffectExecution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSideEffectEntityID sets the "side_effect_entity_id" field.
func (m *SideEffectExecutionMutation) SetSideEffectEntityID(seei schema.SideEffectEntityID) {
	m.side_effect = &seei
}

// SideEffectEntityID returns the value of the "side_effect_entity_id" field in the mutation.
func (m *SideEffectExecutionMutation) SideEffectEntityID() (r schema.SideEffectEntityID, exists bool) {
	v := m.side_effect
	if v == nil {
		return
	}
	return *v, true
}

// OldSideEffectEntityID returns the old "side_effect_entity_id" field's value of the SideEffectExecution entity.
// If the SideEffectExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectExecutionMutation) OldSideEffectEntityID(ctx context.Context) (v schema.SideEffectEntityID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSideEffectEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSideEffectEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSideEffectEntityID: %w", err)
	}
	return oldValue.SideEffectEntityID, nil
}

// ResetSideEffectEntityID resets all changes to the "side_effect_entity_id" field.
func (m *SideEffectExecutionMutation) ResetSideEffectEntityID() {
	m.side_effect = nil
}

// SetStartedAt sets the "started_at" field.
func (m *SideEffectExecutionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *SideEffectExecutionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the SideEffectExecution entity.
// If the SideEffectExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectExecutionMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *SideEffectExecutionMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetCompletedAt sets the "completed_at" field.
func (m *SideEffectExecutionMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *SideEffectExecutionMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the SideEffectExecution entity.
// If the SideEffectExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectExecutionMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *SideEffectExecutionMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[sideeffectexecution.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *SideEffectExecutionMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[sideeffectexecution.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *SideEffectExecutionMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, sideeffectexecution.FieldCompletedAt)
}

// SetStatus sets the "status" field.
func (m *SideEffectExecutionMutation) SetStatus(ss schema.ExecutionStatus) {
	m.status = &ss
}

// Status returns the value of the "status" field in the mutation.
func (m *SideEffectExecutionMutation) Status() (r schema.ExecutionStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SideEffectExecution entity.
// If the SideEffectExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectExecutionMutation) OldStatus(ctx context.Context) (v schema.ExecutionStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SideEffectExecutionMutation) ResetStatus() {
	m.status = nil
}

// SetError sets the "error" field.
func (m *SideEffectExecutionMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *SideEffectExecutionMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the SideEffectExecution entity.
// If the SideEffectExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectExecutionMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *SideEffectExecutionMutation) ClearError() {
	m.error = nil
	m.clearedFields[sideeffectexecution.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *SideEffectExecutionMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[sideeffectexecution.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *SideEffectExecutionMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, sideeffectexecution.FieldError)
}

// SetStackTrace sets the "stack_trace" field.
func (m *SideEffectExecutionMutation) SetStackTrace(s string) {
	m.stack_trace = &s
}

// StackTrace returns the value of the "stack_trace" field in the mutation.
func (m *SideEffectExecutionMutation) StackTrace() (r string, exists bool) {
	v := m.stack_trace
	if v == nil {
		return
	}
	return *v, true
}

// OldStackTrace returns the old "stack_trace" field's value of the SideEffectExecution entity.
// If the SideEffectExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectExecutionMutation) OldStackTrace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStackTrace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStackTrace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStackTrace: %w", err)
	}
	return oldValue.StackTrace, nil
}

// ClearStackTrace clears the value of the "stack_trace" field.
func (m *SideEffectExecutionMutation) ClearStackTrace() {
	m.stack_trace = nil
	m.clearedFields[sideeffectexecution.FieldStackTrace] = struct{}{}
}

// StackTraceCleared returns if the "stack_trace" field was cleared in this mutation.
func (m *SideEffectExecutionMutation) StackTraceCleared() bool {
	_, ok := m.clearedFields[sideeffectexecution.FieldStackTrace]
	return ok
}

// ResetStackTrace resets all changes to the "stack_trace" field.
func (m *SideEffectExecutionMutation) ResetStackTrace() {
	m.stack_trace = nil
	delete(m.clearedFields, sideeffectexecution.FieldStackTrace)
}

// SetCreatedAt sets the "created_at" field.
func (m *SideEffectExecutionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SideEffectExecutionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SideEffectExecution entity.
// If the SideEffectExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectExecutionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SideEffectExecutionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SideEffectExecutionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SideEffectExecutionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SideEffectExecution entity.
// If the SideEffectExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectExecutionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SideEffectExecutionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSideEffectID sets the "side_effect" edge to the SideEffectEntity entity by id.
func (m *SideEffectExecutionMutation) SetSideEffectID(id schema.SideEffectEntityID) {
	m.side_effect = &id
}

// ClearSideEffect clears the "side_effect" edge to the SideEffectEntity entity.
func (m *SideEffectExecutionMutation) ClearSideEffect() {
	m.clearedside_effect = true
	m.clearedFields[sideeffectexecution.FieldSideEffectEntityID] = struct{}{}
}

// SideEffectCleared reports if the "side_effect" edge to the SideEffectEntity entity was cleared.
func (m *SideEffectExecutionMutation) SideEffectCleared() bool {
	return m.clearedside_effect
}

// SideEffectID returns the "side_effect" edge ID in the mutation.
func (m *SideEffectExecutionMutation) SideEffectID() (id schema.SideEffectEntityID, exists bool) {
	if m.side_effect != nil {
		return *m.side_effect, true
	}
	return
}

// SideEffectIDs returns the "side_effect" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SideEffectID instead. It exists only for internal usage by the builders.
func (m *SideEffectExecutionMutation) SideEffectIDs() (ids []schema.SideEffectEntityID) {
	if id := m.side_effect; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSideEffect resets all changes to the "side_effect" edge.
func (m *SideEffectExecutionMutation) ResetSideEffect() {
	m.side_effect = nil
	m.clearedside_effect = false
}

// SetExecutionDataID sets the "execution_data" edge to the SideEffectExecutionData entity by id.
func (m *SideEffectExecutionMutation) SetExecutionDataID(id schema.SideEffectExecutionDataID) {
	m.execution_data = &id
}

// ClearExecutionData clears the "execution_data" edge to the SideEffectExecutionData entity.
func (m *SideEffectExecutionMutation) ClearExecutionData() {
	m.clearedexecution_data = true
}

// ExecutionDataCleared reports if the "execution_data" edge to the SideEffectExecutionData entity was cleared.
func (m *SideEffectExecutionMutation) ExecutionDataCleared() bool {
	return m.clearedexecution_data
}

// ExecutionDataID returns the "execution_data" edge ID in the mutation.
func (m *SideEffectExecutionMutation) ExecutionDataID() (id schema.SideEffectExecutionDataID, exists bool) {
	if m.execution_data != nil {
		return *m.execution_data, true
	}
	return
}

// ExecutionDataIDs returns the "execution_data" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExecutionDataID instead. It exists only for internal usage by the builders.
func (m *SideEffectExecutionMutation) ExecutionDataIDs() (ids []schema.SideEffectExecutionDataID) {
	if id := m.execution_data; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExecutionData resets all changes to the "execution_data" edge.
func (m *SideEffectExecutionMutation) ResetExecutionData() {
	m.execution_data = nil
	m.clearedexecution_data = false
}

// Where appends a list predicates to the SideEffectExecutionMutation builder.
func (m *SideEffectExecutionMutation) Where(ps ...predicate.SideEffectExecution) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SideEffectExecutionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SideEffectExecutionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SideEffectExecution, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SideEffectExecutionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SideEffectExecutionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SideEffectExecution).
func (m *SideEffectExecutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SideEffectExecutionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.side_effect != nil {
		fields = append(fields, sideeffectexecution.FieldSideEffectEntityID)
	}
	if m.started_at != nil {
		fields = append(fields, sideeffectexecution.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, sideeffectexecution.FieldCompletedAt)
	}
	if m.status != nil {
		fields = append(fields, sideeffectexecution.FieldStatus)
	}
	if m.error != nil {
		fields = append(fields, sideeffectexecution.FieldError)
	}
	if m.stack_trace != nil {
		fields = append(fields, sideeffectexecution.FieldStackTrace)
	}
	if m.created_at != nil {
		fields = append(fields, sideeffectexecution.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sideeffectexecution.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SideEffectExecutionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sideeffectexecution.FieldSideEffectEntityID:
		return m.SideEffectEntityID()
	case sideeffectexecution.FieldStartedAt:
		return m.StartedAt()
	case sideeffectexecution.FieldCompletedAt:
		return m.CompletedAt()
	case sideeffectexecution.FieldStatus:
		return m.Status()
	case sideeffectexecution.FieldError:
		return m.Error()
	case sideeffectexecution.FieldStackTrace:
		return m.StackTrace()
	case sideeffectexecution.FieldCreatedAt:
		return m.CreatedAt()
	case sideeffectexecution.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SideEffectExecutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sideeffectexecution.FieldSideEffectEntityID:
		return m.OldSideEffectEntityID(ctx)
	case sideeffectexecution.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case sideeffectexecution.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case sideeffectexecution.FieldStatus:
		return m.OldStatus(ctx)
	case sideeffectexecution.FieldError:
		return m.OldError(ctx)
	case sideeffectexecution.FieldStackTrace:
		return m.OldStackTrace(ctx)
	case sideeffectexecution.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sideeffectexecution.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SideEffectExecution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SideEffectExecutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sideeffectexecution.FieldSideEffectEntityID:
		v, ok := value.(schema.SideEffectEntityID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSideEffectEntityID(v)
		return nil
	case sideeffectexecution.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case sideeffectexecution.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case sideeffectexecution.FieldStatus:
		v, ok := value.(schema.ExecutionStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case sideeffectexecution.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case sideeffectexecution.FieldStackTrace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStackTrace(v)
		return nil
	case sideeffectexecution.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sideeffectexecution.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SideEffectExecution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SideEffectExecutionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SideEffectExecutionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SideEffectExecutionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SideEffectExecution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SideEffectExecutionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sideeffectexecution.FieldCompletedAt) {
		fields = append(fields, sideeffectexecution.FieldCompletedAt)
	}
	if m.FieldCleared(sideeffectexecution.FieldError) {
		fields = append(fields, sideeffectexecution.FieldError)
	}
	if m.FieldCleared(sideeffectexecution.FieldStackTrace) {
		fields = append(fields, sideeffectexecution.FieldStackTrace)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SideEffectExecutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SideEffectExecutionMutation) ClearField(name string) error {
	switch name {
	case sideeffectexecution.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	case sideeffectexecution.FieldError:
		m.ClearError()
		return nil
	case sideeffectexecution.FieldStackTrace:
		m.ClearStackTrace()
		return nil
	}
	return fmt.Errorf("unknown SideEffectExecution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SideEffectExecutionMutation) ResetField(name string) error {
	switch name {
	case sideeffectexecution.FieldSideEffectEntityID:
		m.ResetSideEffectEntityID()
		return nil
	case sideeffectexecution.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case sideeffectexecution.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case sideeffectexecution.FieldStatus:
		m.ResetStatus()
		return nil
	case sideeffectexecution.FieldError:
		m.ResetError()
		return nil
	case sideeffectexecution.FieldStackTrace:
		m.ResetStackTrace()
		return nil
	case sideeffectexecution.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sideeffectexecution.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SideEffectExecution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SideEffectExecutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.side_effect != nil {
		edges = append(edges, sideeffectexecution.EdgeSideEffect)
	}
	if m.execution_data != nil {
		edges = append(edges, sideeffectexecution.EdgeExecutionData)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SideEffectExecutionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sideeffectexecution.EdgeSideEffect:
		if id := m.side_effect; id != nil {
			return []ent.Value{*id}
		}
	case sideeffectexecution.EdgeExecutionData:
		if id := m.execution_data; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SideEffectExecutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SideEffectExecutionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SideEffectExecutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedside_effect {
		edges = append(edges, sideeffectexecution.EdgeSideEffect)
	}
	if m.clearedexecution_data {
		edges = append(edges, sideeffectexecution.EdgeExecutionData)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SideEffectExecutionMutation) EdgeCleared(name string) bool {
	switch name {
	case sideeffectexecution.EdgeSideEffect:
		return m.clearedside_effect
	case sideeffectexecution.EdgeExecutionData:
		return m.clearedexecution_data
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SideEffectExecutionMutation) ClearEdge(name string) error {
	switch name {
	case sideeffectexecution.EdgeSideEffect:
		m.ClearSideEffect()
		return nil
	case sideeffectexecution.EdgeExecutionData:
		m.ClearExecutionData()
		return nil
	}
	return fmt.Errorf("unknown SideEffectExecution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SideEffectExecutionMutation) ResetEdge(name string) error {
	switch name {
	case sideeffectexecution.EdgeSideEffect:
		m.ResetSideEffect()
		return nil
	case sideeffectexecution.EdgeExecutionData:
		m.ResetExecutionData()
		return nil
	}
	return fmt.Errorf("unknown SideEffectExecution edge %s", name)
}

// SideEffectExecutionDataMutation represents an operation that mutates the SideEffectExecutionData nodes in the graph.
type SideEffectExecutionDataMutation struct {
	config
	op               Op
	typ              string
	id               *schema.SideEffectExecutionDataID
	outputs          *[]byte
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	execution        *schema.SideEffectExecutionID
	clearedexecution bool
	done             bool
	oldValue         func(context.Context) (*SideEffectExecutionData, error)
	predicates       []predicate.SideEffectExecutionData
}

var _ ent.Mutation = (*SideEffectExecutionDataMutation)(nil)

// sideeffectexecutiondataOption allows management of the mutation configuration using functional options.
type sideeffectexecutiondataOption func(*SideEffectExecutionDataMutation)

// newSideEffectExecutionDataMutation creates new mutation for the SideEffectExecutionData entity.
func newSideEffectExecutionDataMutation(c config, op Op, opts ...sideeffectexecutiondataOption) *SideEffectExecutionDataMutation {
	m := &SideEffectExecutionDataMutation{
		config:        c,
		op:            op,
		typ:           TypeSideEffectExecutionData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSideEffectExecutionDataID sets the ID field of the mutation.
func withSideEffectExecutionDataID(id schema.SideEffectExecutionDataID) sideeffectexecutiondataOption {
	return func(m *SideEffectExecutionDataMutation) {
		var (
			err   error
			once  sync.Once
			value *SideEffectExecutionData
		)
		m.oldValue = func(ctx context.Context) (*SideEffectExecutionData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SideEffectExecutionData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSideEffectExecutionData sets the old SideEffectExecutionData of the mutation.
func withSideEffectExecutionData(node *SideEffectExecutionData) sideeffectexecutiondataOption {
	return func(m *SideEffectExecutionDataMutation) {
		m.oldValue = func(context.Context) (*SideEffectExecutionData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SideEffectExecutionDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SideEffectExecutionDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SideEffectExecutionData entities.
func (m *SideEffectExecutionDataMutation) SetID(id schema.SideEffectExecutionDataID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SideEffectExecutionDataMutation) ID() (id schema.SideEffectExecutionDataID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SideEffectExecutionDataMutation) IDs(ctx context.Context) ([]schema.SideEffectExecutionDataID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []schema.SideEffectExecutionDataID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SideEffectExecutionData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExecutionID sets the "execution_id" field.
func (m *SideEffectExecutionDataMutation) SetExecutionID(seei schema.SideEffectExecutionID) {
	m.execution = &seei
}

// ExecutionID returns the value of the "execution_id" field in the mutation.
func (m *SideEffectExecutionDataMutation) ExecutionID() (r schema.SideEffectExecutionID, exists bool) {
	v := m.execution
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutionID returns the old "execution_id" field's value of the SideEffectExecutionData entity.
// If the SideEffectExecutionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectExecutionDataMutation) OldExecutionID(ctx context.Context) (v schema.SideEffectExecutionID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutionID: %w", err)
	}
	return oldValue.ExecutionID, nil
}

// ResetExecutionID resets all changes to the "execution_id" field.
func (m *SideEffectExecutionDataMutation) ResetExecutionID() {
	m.execution = nil
}

// SetOutputs sets the "outputs" field.
func (m *SideEffectExecutionDataMutation) SetOutputs(b []byte) {
	m.outputs = &b
}

// Outputs returns the value of the "outputs" field in the mutation.
func (m *SideEffectExecutionDataMutation) Outputs() (r []byte, exists bool) {
	v := m.outputs
	if v == nil {
		return
	}
	return *v, true
}

// OldOutputs returns the old "outputs" field's value of the SideEffectExecutionData entity.
// If the SideEffectExecutionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectExecutionDataMutation) OldOutputs(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutputs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutputs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutputs: %w", err)
	}
	return oldValue.Outputs, nil
}

// ClearOutputs clears the value of the "outputs" field.
func (m *SideEffectExecutionDataMutation) ClearOutputs() {
	m.outputs = nil
	m.clearedFields[sideeffectexecutiondata.FieldOutputs] = struct{}{}
}

// OutputsCleared returns if the "outputs" field was cleared in this mutation.
func (m *SideEffectExecutionDataMutation) OutputsCleared() bool {
	_, ok := m.clearedFields[sideeffectexecutiondata.FieldOutputs]
	return ok
}

// ResetOutputs resets all changes to the "outputs" field.
func (m *SideEffectExecutionDataMutation) ResetOutputs() {
	m.outputs = nil
	delete(m.clearedFields, sideeffectexecutiondata.FieldOutputs)
}

// SetCreatedAt sets the "created_at" field.
func (m *SideEffectExecutionDataMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SideEffectExecutionDataMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SideEffectExecutionData entity.
// If the SideEffectExecutionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectExecutionDataMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SideEffectExecutionDataMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SideEffectExecutionDataMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SideEffectExecutionDataMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SideEffectExecutionData entity.
// If the SideEffectExecutionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectExecutionDataMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SideEffectExecutionDataMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearExecution clears the "execution" edge to the SideEffectExecution entity.
func (m *SideEffectExecutionDataMutation) ClearExecution() {
	m.clearedexecution = true
	m.clearedFields[sideeffectexecutiondata.FieldExecutionID] = struct{}{}
}

// ExecutionCleared reports if the "execution" edge to the SideEffectExecution entity was cleared.
func (m *SideEffectExecutionDataMutation) ExecutionCleared() bool {
	return m.clearedexecution
}

// ExecutionIDs returns the "execution" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExecutionID instead. It exists only for internal usage by the builders.
func (m *SideEffectExecutionDataMutation) ExecutionIDs() (ids []schema.SideEffectExecutionID) {
	if id := m.execution; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExecution resets all changes to the "execution" edge.
func (m *SideEffectExecutionDataMutation) ResetExecution() {
	m.execution = nil
	m.clearedexecution = false
}

// Where appends a list predicates to the SideEffectExecutionDataMutation builder.
func (m *SideEffectExecutionDataMutation) Where(ps ...predicate.SideEffectExecutionData) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SideEffectExecutionDataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SideEffectExecutionDataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SideEffectExecutionData, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SideEffectExecutionDataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SideEffectExecutionDataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SideEffectExecutionData).
func (m *SideEffectExecutionDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SideEffectExecutionDataMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.execution != nil {
		fields = append(fields, sideeffectexecutiondata.FieldExecutionID)
	}
	if m.outputs != nil {
		fields = append(fields, sideeffectexecutiondata.FieldOutputs)
	}
	if m.created_at != nil {
		fields = append(fields, sideeffectexecutiondata.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sideeffectexecutiondata.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SideEffectExecutionDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sideeffectexecutiondata.FieldExecutionID:
		return m.ExecutionID()
	case sideeffectexecutiondata.FieldOutputs:
		return m.Outputs()
	case sideeffectexecutiondata.FieldCreatedAt:
		return m.CreatedAt()
	case sideeffectexecutiondata.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SideEffectExecutionDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sideeffectexecutiondata.FieldExecutionID:
		return m.OldExecutionID(ctx)
	case sideeffectexecutiondata.FieldOutputs:
		return m.OldOutputs(ctx)
	case sideeffectexecutiondata.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sideeffectexecutiondata.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SideEffectExecutionData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SideEffectExecutionDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sideeffectexecutiondata.FieldExecutionID:
		v, ok := value.(schema.SideEffectExecutionID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutionID(v)
		return nil
	case sideeffectexecutiondata.FieldOutputs:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutputs(v)
		return nil
	case sideeffectexecutiondata.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sideeffectexecutiondata.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SideEffectExecutionData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SideEffectExecutionDataMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SideEffectExecutionDataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SideEffectExecutionDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SideEffectExecutionData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SideEffectExecutionDataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sideeffectexecutiondata.FieldOutputs) {
		fields = append(fields, sideeffectexecutiondata.FieldOutputs)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SideEffectExecutionDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SideEffectExecutionDataMutation) ClearField(name string) error {
	switch name {
	case sideeffectexecutiondata.FieldOutputs:
		m.ClearOutputs()
		return nil
	}
	return fmt.Errorf("unknown SideEffectExecutionData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SideEffectExecutionDataMutation) ResetField(name string) error {
	switch name {
	case sideeffectexecutiondata.FieldExecutionID:
		m.ResetExecutionID()
		return nil
	case sideeffectexecutiondata.FieldOutputs:
		m.ResetOutputs()
		return nil
	case sideeffectexecutiondata.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sideeffectexecutiondata.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SideEffectExecutionData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SideEffectExecutionDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.execution != nil {
		edges = append(edges, sideeffectexecutiondata.EdgeExecution)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SideEffectExecutionDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sideeffectexecutiondata.EdgeExecution:
		if id := m.execution; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SideEffectExecutionDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SideEffectExecutionDataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SideEffectExecutionDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedexecution {
		edges = append(edges, sideeffectexecutiondata.EdgeExecution)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SideEffectExecutionDataMutation) EdgeCleared(name string) bool {
	switch name {
	case sideeffectexecutiondata.EdgeExecution:
		return m.clearedexecution
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SideEffectExecutionDataMutation) ClearEdge(name string) error {
	switch name {
	case sideeffectexecutiondata.EdgeExecution:
		m.ClearExecution()
		return nil
	}
	return fmt.Errorf("unknown SideEffectExecutionData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SideEffectExecutionDataMutation) ResetEdge(name string) error {
	switch name {
	case sideeffectexecutiondata.EdgeExecution:
		m.ResetExecution()
		return nil
	}
	return fmt.Errorf("unknown SideEffectExecutionData edge %s", name)
}

// SignalDataMutation represents an operation that mutates the SignalData nodes in the graph.
type SignalDataMutation struct {
	config
	op            Op
	typ           string
	id            *schema.SignalDataID
	name          *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	signal        *schema.SignalEntityID
	clearedsignal bool
	done          bool
	oldValue      func(context.Context) (*SignalData, error)
	predicates    []predicate.SignalData
}

var _ ent.Mutation = (*SignalDataMutation)(nil)

// signaldataOption allows management of the mutation configuration using functional options.
type signaldataOption func(*SignalDataMutation)

// newSignalDataMutation creates new mutation for the SignalData entity.
func newSignalDataMutation(c config, op Op, opts ...signaldataOption) *SignalDataMutation {
	m := &SignalDataMutation{
		config:        c,
		op:            op,
		typ:           TypeSignalData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSignalDataID sets the ID field of the mutation.
func withSignalDataID(id schema.SignalDataID) signaldataOption {
	return func(m *SignalDataMutation) {
		var (
			err   error
			once  sync.Once
			value *SignalData
		)
		m.oldValue = func(ctx context.Context) (*SignalData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SignalData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSignalData sets the old SignalData of the mutation.
func withSignalData(node *SignalData) signaldataOption {
	return func(m *SignalDataMutation) {
		m.oldValue = func(context.Context) (*SignalData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SignalDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SignalDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SignalData entities.
func (m *SignalDataMutation) SetID(id schema.SignalDataID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SignalDataMutation) ID() (id schema.SignalDataID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SignalDataMutation) IDs(ctx context.Context) ([]schema.SignalDataID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []schema.SignalDataID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SignalData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntityID sets the "entity_id" field.
func (m *SignalDataMutation) SetEntityID(sei schema.SignalEntityID) {
	m.signal = &sei
}

// EntityID returns the value of the "entity_id" field in the mutation.
func (m *SignalDataMutation) EntityID() (r schema.SignalEntityID, exists bool) {
	v := m.signal
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityID returns the old "entity_id" field's value of the SignalData entity.
// If the SignalData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalDataMutation) OldEntityID(ctx context.Context) (v schema.SignalEntityID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityID: %w", err)
	}
	return oldValue.EntityID, nil
}

// ResetEntityID resets all changes to the "entity_id" field.
func (m *SignalDataMutation) ResetEntityID() {
	m.signal = nil
}

// SetName sets the "name" field.
func (m *SignalDataMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SignalDataMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SignalData entity.
// If the SignalData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalDataMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SignalDataMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SignalDataMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SignalDataMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SignalData entity.
// If the SignalData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalDataMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SignalDataMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SignalDataMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SignalDataMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SignalData entity.
// If the SignalData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalDataMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SignalDataMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSignalID sets the "signal" edge to the SignalEntity entity by id.
func (m *SignalDataMutation) SetSignalID(id schema.SignalEntityID) {
	m.signal = &id
}

// ClearSignal clears the "signal" edge to the SignalEntity entity.
func (m *SignalDataMutation) ClearSignal() {
	m.clearedsignal = true
	m.clearedFields[signaldata.FieldEntityID] = struct{}{}
}

// SignalCleared reports if the "signal" edge to the SignalEntity entity was cleared.
func (m *SignalDataMutation) SignalCleared() bool {
	return m.clearedsignal
}

// SignalID returns the "signal" edge ID in the mutation.
func (m *SignalDataMutation) SignalID() (id schema.SignalEntityID, exists bool) {
	if m.signal != nil {
		return *m.signal, true
	}
	return
}

// SignalIDs returns the "signal" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SignalID instead. It exists only for internal usage by the builders.
func (m *SignalDataMutation) SignalIDs() (ids []schema.SignalEntityID) {
	if id := m.signal; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSignal resets all changes to the "signal" edge.
func (m *SignalDataMutation) ResetSignal() {
	m.signal = nil
	m.clearedsignal = false
}

// Where appends a list predicates to the SignalDataMutation builder.
func (m *SignalDataMutation) Where(ps ...predicate.SignalData) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SignalDataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SignalDataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SignalData, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SignalDataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SignalDataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SignalData).
func (m *SignalDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SignalDataMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.signal != nil {
		fields = append(fields, signaldata.FieldEntityID)
	}
	if m.name != nil {
		fields = append(fields, signaldata.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, signaldata.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, signaldata.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SignalDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case signaldata.FieldEntityID:
		return m.EntityID()
	case signaldata.FieldName:
		return m.Name()
	case signaldata.FieldCreatedAt:
		return m.CreatedAt()
	case signaldata.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SignalDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case signaldata.FieldEntityID:
		return m.OldEntityID(ctx)
	case signaldata.FieldName:
		return m.OldName(ctx)
	case signaldata.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case signaldata.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SignalData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SignalDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case signaldata.FieldEntityID:
		v, ok := value.(schema.SignalEntityID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityID(v)
		return nil
	case signaldata.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case signaldata.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case signaldata.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SignalData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SignalDataMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SignalDataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SignalDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SignalData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SignalDataMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SignalDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SignalDataMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SignalData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SignalDataMutation) ResetField(name string) error {
	switch name {
	case signaldata.FieldEntityID:
		m.ResetEntityID()
		return nil
	case signaldata.FieldName:
		m.ResetName()
		return nil
	case signaldata.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case signaldata.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SignalData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SignalDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.signal != nil {
		edges = append(edges, signaldata.EdgeSignal)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SignalDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case signaldata.EdgeSignal:
		if id := m.signal; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SignalDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SignalDataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SignalDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsignal {
		edges = append(edges, signaldata.EdgeSignal)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SignalDataMutation) EdgeCleared(name string) bool {
	switch name {
	case signaldata.EdgeSignal:
		return m.clearedsignal
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SignalDataMutation) ClearEdge(name string) error {
	switch name {
	case signaldata.EdgeSignal:
		m.ClearSignal()
		return nil
	}
	return fmt.Errorf("unknown SignalData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SignalDataMutation) ResetEdge(name string) error {
	switch name {
	case signaldata.EdgeSignal:
		m.ResetSignal()
		return nil
	}
	return fmt.Errorf("unknown SignalData edge %s", name)
}

// SignalEntityMutation represents an operation that mutates the SignalEntity nodes in the graph.
type SignalEntityMutation struct {
	config
	op                 Op
	typ                string
	id                 *schema.SignalEntityID
	handler_name       *string
	_type              *schema.EntityType
	status             *schema.EntityStatus
	step_id            *schema.SignalStepID
	run_id             *schema.RunID
	addrun_id          *schema.RunID
	retry_policy       *schema.RetryPolicy
	retry_state        *schema.RetryState
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	signal_data        *schema.SignalDataID
	clearedsignal_data bool
	executions         map[schema.SignalExecutionID]struct{}
	removedexecutions  map[schema.SignalExecutionID]struct{}
	clearedexecutions  bool
	done               bool
	oldValue           func(context.Context) (*SignalEntity, error)
	predicates         []predicate.SignalEntity
}

var _ ent.Mutation = (*SignalEntityMutation)(nil)

// signalentityOption allows management of the mutation configuration using functional options.
type signalentityOption func(*SignalEntityMutation)

// newSignalEntityMutation creates new mutation for the SignalEntity entity.
func newSignalEntityMutation(c config, op Op, opts ...signalentityOption) *SignalEntityMutation {
	m := &SignalEntityMutation{
		config:        c,
		op:            op,
		typ:           TypeSignalEntity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSignalEntityID sets the ID field of the mutation.
func withSignalEntityID(id schema.SignalEntityID) signalentityOption {
	return func(m *SignalEntityMutation) {
		var (
			err   error
			once  sync.Once
			value *SignalEntity
		)
		m.oldValue = func(ctx context.Context) (*SignalEntity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SignalEntity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSignalEntity sets the old SignalEntity of the mutation.
func withSignalEntity(node *SignalEntity) signalentityOption {
	return func(m *SignalEntityMutation) {
		m.oldValue = func(context.Context) (*SignalEntity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SignalEntityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SignalEntityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SignalEntity entities.
func (m *SignalEntityMutation) SetID(id schema.SignalEntityID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SignalEntityMutation) ID() (id schema.SignalEntityID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SignalEntityMutation) IDs(ctx context.Context) ([]schema.SignalEntityID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []schema.SignalEntityID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SignalEntity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHandlerName sets the "handler_name" field.
func (m *SignalEntityMutation) SetHandlerName(s string) {
	m.handler_name = &s
}

// HandlerName returns the value of the "handler_name" field in the mutation.
func (m *SignalEntityMutation) HandlerName() (r string, exists bool) {
	v := m.handler_name
	if v == nil {
		return
	}
	return *v, true
}

// OldHandlerName returns the old "handler_name" field's value of the SignalEntity entity.
// If the SignalEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalEntityMutation) OldHandlerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandlerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandlerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandlerName: %w", err)
	}
	return oldValue.HandlerName, nil
}

// ResetHandlerName resets all changes to the "handler_name" field.
func (m *SignalEntityMutation) ResetHandlerName() {
	m.handler_name = nil
}

// SetType sets the "type" field.
func (m *SignalEntityMutation) SetType(st schema.EntityType) {
	m._type = &st
}

// GetType returns the value of the "type" field in the mutation.
func (m *SignalEntityMutation) GetType() (r schema.EntityType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the SignalEntity entity.
// If the SignalEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalEntityMutation) OldType(ctx context.Context) (v schema.EntityType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *SignalEntityMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *SignalEntityMutation) SetStatus(ss schema.EntityStatus) {
	m.status = &ss
}

// Status returns the value of the "status" field in the mutation.
func (m *SignalEntityMutation) Status() (r schema.EntityStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SignalEntity entity.
// If the SignalEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalEntityMutation) OldStatus(ctx context.Context) (v schema.EntityStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SignalEntityMutation) ResetStatus() {
	m.status = nil
}

// SetStepID sets the "step_id" field.
func (m *SignalEntityMutation) SetStepID(ssi schema.SignalStepID) {
	m.step_id = &ssi
}

// StepID returns the value of the "step_id" field in the mutation.
func (m *SignalEntityMutation) StepID() (r schema.SignalStepID, exists bool) {
	v := m.step_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStepID returns the old "step_id" field's value of the SignalEntity entity.
// If the SignalEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalEntityMutation) OldStepID(ctx context.Context) (v schema.SignalStepID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStepID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStepID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStepID: %w", err)
	}
	return oldValue.StepID, nil
}

// ResetStepID resets all changes to the "step_id" field.
func (m *SignalEntityMutation) ResetStepID() {
	m.step_id = nil
}

// SetRunID sets the "run_id" field.
func (m *SignalEntityMutation) SetRunID(si schema.RunID) {
	m.run_id = &si
	m.addrun_id = nil
}

// RunID returns the value of the "run_id" field in the mutation.
func (m *SignalEntityMutation) RunID() (r schema.RunID, exists bool) {
	v := m.run_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRunID returns the old "run_id" field's value of the SignalEntity entity.
// If the SignalEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalEntityMutation) OldRunID(ctx context.Context) (v schema.RunID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunID: %w", err)
	}
	return oldValue.RunID, nil
}

// AddRunID adds si to the "run_id" field.
func (m *SignalEntityMutation) AddRunID(si schema.RunID) {
	if m.addrun_id != nil {
		*m.addrun_id += si
	} else {
		m.addrun_id = &si
	}
}

// AddedRunID returns the value that was added to the "run_id" field in this mutation.
func (m *SignalEntityMutation) AddedRunID() (r schema.RunID, exists bool) {
	v := m.addrun_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRunID resets all changes to the "run_id" field.
func (m *SignalEntityMutation) ResetRunID() {
	m.run_id = nil
	m.addrun_id = nil
}

// SetRetryPolicy sets the "retry_policy" field.
func (m *SignalEntityMutation) SetRetryPolicy(sp schema.RetryPolicy) {
	m.retry_policy = &sp
}

// RetryPolicy returns the value of the "retry_policy" field in the mutation.
func (m *SignalEntityMutation) RetryPolicy() (r schema.RetryPolicy, exists bool) {
	v := m.retry_policy
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryPolicy returns the old "retry_policy" field's value of the SignalEntity entity.
// If the SignalEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalEntityMutation) OldRetryPolicy(ctx context.Context) (v schema.RetryPolicy, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryPolicy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryPolicy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryPolicy: %w", err)
	}
	return oldValue.RetryPolicy, nil
}

// ResetRetryPolicy resets all changes to the "retry_policy" field.
func (m *SignalEntityMutation) ResetRetryPolicy() {
	m.retry_policy = nil
}

// SetRetryState sets the "retry_state" field.
func (m *SignalEntityMutation) SetRetryState(ss schema.RetryState) {
	m.retry_state = &ss
}

// RetryState returns the value of the "retry_state" field in the mutation.
func (m *SignalEntityMutation) RetryState() (r schema.RetryState, exists bool) {
	v := m.retry_state
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryState returns the old "retry_state" field's value of the SignalEntity entity.
// If the SignalEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalEntityMutation) OldRetryState(ctx context.Context) (v schema.RetryState, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryState: %w", err)
	}
	return oldValue.RetryState, nil
}

// ResetRetryState resets all changes to the "retry_state" field.
func (m *SignalEntityMutation) ResetRetryState() {
	m.retry_state = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SignalEntityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SignalEntityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SignalEntity entity.
// If the SignalEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalEntityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SignalEntityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SignalEntityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SignalEntityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SignalEntity entity.
// If the SignalEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalEntityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SignalEntityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSignalDataID sets the "signal_data" edge to the SignalData entity by id.
func (m *SignalEntityMutation) SetSignalDataID(id schema.SignalDataID) {
	m.signal_data = &id
}

// ClearSignalData clears the "signal_data" edge to the SignalData entity.
func (m *SignalEntityMutation) ClearSignalData() {
	m.clearedsignal_data = true
}

// SignalDataCleared reports if the "signal_data" edge to the SignalData entity was cleared.
func (m *SignalEntityMutation) SignalDataCleared() bool {
	return m.clearedsignal_data
}

// SignalDataID returns the "signal_data" edge ID in the mutation.
func (m *SignalEntityMutation) SignalDataID() (id schema.SignalDataID, exists bool) {
	if m.signal_data != nil {
		return *m.signal_data, true
	}
	return
}

// SignalDataIDs returns the "signal_data" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SignalDataID instead. It exists only for internal usage by the builders.
func (m *SignalEntityMutation) SignalDataIDs() (ids []schema.SignalDataID) {
	if id := m.signal_data; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSignalData resets all changes to the "signal_data" edge.
func (m *SignalEntityMutation) ResetSignalData() {
	m.signal_data = nil
	m.clearedsignal_data = false
}

// AddExecutionIDs adds the "executions" edge to the SignalExecution entity by ids.
func (m *SignalEntityMutation) AddExecutionIDs(ids ...schema.SignalExecutionID) {
	if m.executions == nil {
		m.executions = make(map[schema.SignalExecutionID]struct{})
	}
	for i := range ids {
		m.executions[ids[i]] = struct{}{}
	}
}

// ClearExecutions clears the "executions" edge to the SignalExecution entity.
func (m *SignalEntityMutation) ClearExecutions() {
	m.clearedexecutions = true
}

// ExecutionsCleared reports if the "executions" edge to the SignalExecution entity was cleared.
func (m *SignalEntityMutation) ExecutionsCleared() bool {
	return m.clearedexecutions
}

// RemoveExecutionIDs removes the "executions" edge to the SignalExecution entity by IDs.
func (m *SignalEntityMutation) RemoveExecutionIDs(ids ...schema.SignalExecutionID) {
	if m.removedexecutions == nil {
		m.removedexecutions = make(map[schema.SignalExecutionID]struct{})
	}
	for i := range ids {
		delete(m.executions, ids[i])
		m.removedexecutions[ids[i]] = struct{}{}
	}
}

// RemovedExecutions returns the removed IDs of the "executions" edge to the SignalExecution entity.
func (m *SignalEntityMutation) RemovedExecutionsIDs() (ids []schema.SignalExecutionID) {
	for id := range m.removedexecutions {
		ids = append(ids, id)
	}
	return
}

// ExecutionsIDs returns the "executions" edge IDs in the mutation.
func (m *SignalEntityMutation) ExecutionsIDs() (ids []schema.SignalExecutionID) {
	for id := range m.executions {
		ids = append(ids, id)
	}
	return
}

// ResetExecutions resets all changes to the "executions" edge.
func (m *SignalEntityMutation) ResetExecutions() {
	m.executions = nil
	m.clearedexecutions = false
	m.removedexecutions = nil
}

// Where appends a list predicates to the SignalEntityMutation builder.
func (m *SignalEntityMutation) Where(ps ...predicate.SignalEntity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SignalEntityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SignalEntityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SignalEntity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SignalEntityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SignalEntityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SignalEntity).
func (m *SignalEntityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SignalEntityMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.handler_name != nil {
		fields = append(fields, signalentity.FieldHandlerName)
	}
	if m._type != nil {
		fields = append(fields, signalentity.FieldType)
	}
	if m.status != nil {
		fields = append(fields, signalentity.FieldStatus)
	}
	if m.step_id != nil {
		fields = append(fields, signalentity.FieldStepID)
	}
	if m.run_id != nil {
		fields = append(fields, signalentity.FieldRunID)
	}
	if m.retry_policy != nil {
		fields = append(fields, signalentity.FieldRetryPolicy)
	}
	if m.retry_state != nil {
		fields = append(fields, signalentity.FieldRetryState)
	}
	if m.created_at != nil {
		fields = append(fields, signalentity.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, signalentity.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SignalEntityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case signalentity.FieldHandlerName:
		return m.HandlerName()
	case signalentity.FieldType:
		return m.GetType()
	case signalentity.FieldStatus:
		return m.Status()
	case signalentity.FieldStepID:
		return m.StepID()
	case signalentity.FieldRunID:
		return m.RunID()
	case signalentity.FieldRetryPolicy:
		return m.RetryPolicy()
	case signalentity.FieldRetryState:
		return m.RetryState()
	case signalentity.FieldCreatedAt:
		return m.CreatedAt()
	case signalentity.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SignalEntityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case signalentity.FieldHandlerName:
		return m.OldHandlerName(ctx)
	case signalentity.FieldType:
		return m.OldType(ctx)
	case signalentity.FieldStatus:
		return m.OldStatus(ctx)
	case signalentity.FieldStepID:
		return m.OldStepID(ctx)
	case signalentity.FieldRunID:
		return m.OldRunID(ctx)
	case signalentity.FieldRetryPolicy:
		return m.OldRetryPolicy(ctx)
	case signalentity.FieldRetryState:
		return m.OldRetryState(ctx)
	case signalentity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case signalentity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SignalEntity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SignalEntityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case signalentity.FieldHandlerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandlerName(v)
		return nil
	case signalentity.FieldType:
		v, ok := value.(schema.EntityType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case signalentity.FieldStatus:
		v, ok := value.(schema.EntityStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case signalentity.FieldStepID:
		v, ok := value.(schema.SignalStepID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStepID(v)
		return nil
	case signalentity.FieldRunID:
		v, ok := value.(schema.RunID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunID(v)
		return nil
	case signalentity.FieldRetryPolicy:
		v, ok := value.(schema.RetryPolicy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryPolicy(v)
		return nil
	case signalentity.FieldRetryState:
		v, ok := value.(schema.RetryState)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryState(v)
		return nil
	case signalentity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case signalentity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SignalEntity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SignalEntityMutation) AddedFields() []string {
	var fields []string
	if m.addrun_id != nil {
		fields = append(fields, signalentity.FieldRunID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SignalEntityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case signalentity.FieldRunID:
		return m.AddedRunID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SignalEntityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case signalentity.FieldRunID:
		v, ok := value.(schema.RunID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRunID(v)
		return nil
	}
	return fmt.Errorf("unknown SignalEntity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SignalEntityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SignalEntityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SignalEntityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SignalEntity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SignalEntityMutation) ResetField(name string) error {
	switch name {
	case signalentity.FieldHandlerName:
		m.ResetHandlerName()
		return nil
	case signalentity.FieldType:
		m.ResetType()
		return nil
	case signalentity.FieldStatus:
		m.ResetStatus()
		return nil
	case signalentity.FieldStepID:
		m.ResetStepID()
		return nil
	case signalentity.FieldRunID:
		m.ResetRunID()
		return nil
	case signalentity.FieldRetryPolicy:
		m.ResetRetryPolicy()
		return nil
	case signalentity.FieldRetryState:
		m.ResetRetryState()
		return nil
	case signalentity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case signalentity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SignalEntity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SignalEntityMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.signal_data != nil {
		edges = append(edges, signalentity.EdgeSignalData)
	}
	if m.executions != nil {
		edges = append(edges, signalentity.EdgeExecutions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SignalEntityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case signalentity.EdgeSignalData:
		if id := m.signal_data; id != nil {
			return []ent.Value{*id}
		}
	case signalentity.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.executions))
		for id := range m.executions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SignalEntityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedexecutions != nil {
		edges = append(edges, signalentity.EdgeExecutions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SignalEntityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case signalentity.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.removedexecutions))
		for id := range m.removedexecutions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SignalEntityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsignal_data {
		edges = append(edges, signalentity.EdgeSignalData)
	}
	if m.clearedexecutions {
		edges = append(edges, signalentity.EdgeExecutions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SignalEntityMutation) EdgeCleared(name string) bool {
	switch name {
	case signalentity.EdgeSignalData:
		return m.clearedsignal_data
	case signalentity.EdgeExecutions:
		return m.clearedexecutions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SignalEntityMutation) ClearEdge(name string) error {
	switch name {
	case signalentity.EdgeSignalData:
		m.ClearSignalData()
		return nil
	}
	return fmt.Errorf("unknown SignalEntity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SignalEntityMutation) ResetEdge(name string) error {
	switch name {
	case signalentity.EdgeSignalData:
		m.ResetSignalData()
		return nil
	case signalentity.EdgeExecutions:
		m.ResetExecutions()
		return nil
	}
	return fmt.Errorf("unknown SignalEntity edge %s", name)
}

// SignalExecutionMutation represents an operation that mutates the SignalExecution nodes in the graph.
type SignalExecutionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *schema.SignalExecutionID
	started_at            *time.Time
	completed_at          *time.Time
	status                *schema.ExecutionStatus
	error                 *string
	stack_trace           *string
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	signal                *schema.SignalEntityID
	clearedsignal         bool
	execution_data        *schema.SignalExecutionDataID
	clearedexecution_data bool
	done                  bool
	oldValue              func(context.Context) (*SignalExecution, error)
	predicates            []predicate.SignalExecution
}

var _ ent.Mutation = (*SignalExecutionMutation)(nil)

// signalexecutionOption allows management of the mutation configuration using functional options.
type signalexecutionOption func(*SignalExecutionMutation)

// newSignalExecutionMutation creates new mutation for the SignalExecution entity.
func newSignalExecutionMutation(c config, op Op, opts ...signalexecutionOption) *SignalExecutionMutation {
	m := &SignalExecutionMutation{
		config:        c,
		op:            op,
		typ:           TypeSignalExecution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSignalExecutionID sets the ID field of the mutation.
func withSignalExecutionID(id schema.SignalExecutionID) signalexecutionOption {
	return func(m *SignalExecutionMutation) {
		var (
			err   error
			once  sync.Once
			value *SignalExecution
		)
		m.oldValue = func(ctx context.Context) (*SignalExecution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SignalExecution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSignalExecution sets the old SignalExecution of the mutation.
func withSignalExecution(node *SignalExecution) signalexecutionOption {
	return func(m *SignalExecutionMutation) {
		m.oldValue = func(context.Context) (*SignalExecution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SignalExecutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SignalExecutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SignalExecution entities.
func (m *SignalExecutionMutation) SetID(id schema.SignalExecutionID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SignalExecutionMutation) ID() (id schema.SignalExecutionID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SignalExecutionMutation) IDs(ctx context.Context) ([]schema.SignalExecutionID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []schema.SignalExecutionID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SignalExecution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntityID sets the "entity_id" field.
func (m *SignalExecutionMutation) SetEntityID(sei schema.SignalEntityID) {
	m.signal = &sei
}

// EntityID returns the value of the "entity_id" field in the mutation.
func (m *SignalExecutionMutation) EntityID() (r schema.SignalEntityID, exists bool) {
	v := m.signal
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityID returns the old "entity_id" field's value of the SignalExecution entity.
// If the SignalExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalExecutionMutation) OldEntityID(ctx context.Context) (v schema.SignalEntityID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityID: %w", err)
	}
	return oldValue.EntityID, nil
}

// ResetEntityID resets all changes to the "entity_id" field.
func (m *SignalExecutionMutation) ResetEntityID() {
	m.signal = nil
}

// SetStartedAt sets the "started_at" field.
func (m *SignalExecutionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *SignalExecutionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the SignalExecution entity.
// If the SignalExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalExecutionMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *SignalExecutionMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetCompletedAt sets the "completed_at" field.
func (m *SignalExecutionMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *SignalExecutionMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the SignalExecution entity.
// If the SignalExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalExecutionMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *SignalExecutionMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[signalexecution.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *SignalExecutionMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[signalexecution.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *SignalExecutionMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, signalexecution.FieldCompletedAt)
}

// SetStatus sets the "status" field.
func (m *SignalExecutionMutation) SetStatus(ss schema.ExecutionStatus) {
	m.status = &ss
}

// Status returns the value of the "status" field in the mutation.
func (m *SignalExecutionMutation) Status() (r schema.ExecutionStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SignalExecution entity.
// If the SignalExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalExecutionMutation) OldStatus(ctx context.Context) (v schema.ExecutionStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SignalExecutionMutation) ResetStatus() {
	m.status = nil
}

// SetError sets the "error" field.
func (m *SignalExecutionMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *SignalExecutionMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the SignalExecution entity.
// If the SignalExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalExecutionMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *SignalExecutionMutation) ClearError() {
	m.error = nil
	m.clearedFields[signalexecution.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *SignalExecutionMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[signalexecution.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *SignalExecutionMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, signalexecution.FieldError)
}

// SetStackTrace sets the "stack_trace" field.
func (m *SignalExecutionMutation) SetStackTrace(s string) {
	m.stack_trace = &s
}

// StackTrace returns the value of the "stack_trace" field in the mutation.
func (m *SignalExecutionMutation) StackTrace() (r string, exists bool) {
	v := m.stack_trace
	if v == nil {
		return
	}
	return *v, true
}

// OldStackTrace returns the old "stack_trace" field's value of the SignalExecution entity.
// If the SignalExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalExecutionMutation) OldStackTrace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStackTrace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStackTrace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStackTrace: %w", err)
	}
	return oldValue.StackTrace, nil
}

// ClearStackTrace clears the value of the "stack_trace" field.
func (m *SignalExecutionMutation) ClearStackTrace() {
	m.stack_trace = nil
	m.clearedFields[signalexecution.FieldStackTrace] = struct{}{}
}

// StackTraceCleared returns if the "stack_trace" field was cleared in this mutation.
func (m *SignalExecutionMutation) StackTraceCleared() bool {
	_, ok := m.clearedFields[signalexecution.FieldStackTrace]
	return ok
}

// ResetStackTrace resets all changes to the "stack_trace" field.
func (m *SignalExecutionMutation) ResetStackTrace() {
	m.stack_trace = nil
	delete(m.clearedFields, signalexecution.FieldStackTrace)
}

// SetCreatedAt sets the "created_at" field.
func (m *SignalExecutionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SignalExecutionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SignalExecution entity.
// If the SignalExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalExecutionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SignalExecutionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SignalExecutionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SignalExecutionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SignalExecution entity.
// If the SignalExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalExecutionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SignalExecutionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSignalID sets the "signal" edge to the SignalEntity entity by id.
func (m *SignalExecutionMutation) SetSignalID(id schema.SignalEntityID) {
	m.signal = &id
}

// ClearSignal clears the "signal" edge to the SignalEntity entity.
func (m *SignalExecutionMutation) ClearSignal() {
	m.clearedsignal = true
	m.clearedFields[signalexecution.FieldEntityID] = struct{}{}
}

// SignalCleared reports if the "signal" edge to the SignalEntity entity was cleared.
func (m *SignalExecutionMutation) SignalCleared() bool {
	return m.clearedsignal
}

// SignalID returns the "signal" edge ID in the mutation.
func (m *SignalExecutionMutation) SignalID() (id schema.SignalEntityID, exists bool) {
	if m.signal != nil {
		return *m.signal, true
	}
	return
}

// SignalIDs returns the "signal" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SignalID instead. It exists only for internal usage by the builders.
func (m *SignalExecutionMutation) SignalIDs() (ids []schema.SignalEntityID) {
	if id := m.signal; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSignal resets all changes to the "signal" edge.
func (m *SignalExecutionMutation) ResetSignal() {
	m.signal = nil
	m.clearedsignal = false
}

// SetExecutionDataID sets the "execution_data" edge to the SignalExecutionData entity by id.
func (m *SignalExecutionMutation) SetExecutionDataID(id schema.SignalExecutionDataID) {
	m.execution_data = &id
}

// ClearExecutionData clears the "execution_data" edge to the SignalExecutionData entity.
func (m *SignalExecutionMutation) ClearExecutionData() {
	m.clearedexecution_data = true
}

// ExecutionDataCleared reports if the "execution_data" edge to the SignalExecutionData entity was cleared.
func (m *SignalExecutionMutation) ExecutionDataCleared() bool {
	return m.clearedexecution_data
}

// ExecutionDataID returns the "execution_data" edge ID in the mutation.
func (m *SignalExecutionMutation) ExecutionDataID() (id schema.SignalExecutionDataID, exists bool) {
	if m.execution_data != nil {
		return *m.execution_data, true
	}
	return
}

// ExecutionDataIDs returns the "execution_data" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExecutionDataID instead. It exists only for internal usage by the builders.
func (m *SignalExecutionMutation) ExecutionDataIDs() (ids []schema.SignalExecutionDataID) {
	if id := m.execution_data; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExecutionData resets all changes to the "execution_data" edge.
func (m *SignalExecutionMutation) ResetExecutionData() {
	m.execution_data = nil
	m.clearedexecution_data = false
}

// Where appends a list predicates to the SignalExecutionMutation builder.
func (m *SignalExecutionMutation) Where(ps ...predicate.SignalExecution) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SignalExecutionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SignalExecutionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SignalExecution, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SignalExecutionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SignalExecutionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SignalExecution).
func (m *SignalExecutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SignalExecutionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.signal != nil {
		fields = append(fields, signalexecution.FieldEntityID)
	}
	if m.started_at != nil {
		fields = append(fields, signalexecution.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, signalexecution.FieldCompletedAt)
	}
	if m.status != nil {
		fields = append(fields, signalexecution.FieldStatus)
	}
	if m.error != nil {
		fields = append(fields, signalexecution.FieldError)
	}
	if m.stack_trace != nil {
		fields = append(fields, signalexecution.FieldStackTrace)
	}
	if m.created_at != nil {
		fields = append(fields, signalexecution.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, signalexecution.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SignalExecutionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case signalexecution.FieldEntityID:
		return m.EntityID()
	case signalexecution.FieldStartedAt:
		return m.StartedAt()
	case signalexecution.FieldCompletedAt:
		return m.CompletedAt()
	case signalexecution.FieldStatus:
		return m.Status()
	case signalexecution.FieldError:
		return m.Error()
	case signalexecution.FieldStackTrace:
		return m.StackTrace()
	case signalexecution.FieldCreatedAt:
		return m.CreatedAt()
	case signalexecution.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SignalExecutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case signalexecution.FieldEntityID:
		return m.OldEntityID(ctx)
	case signalexecution.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case signalexecution.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case signalexecution.FieldStatus:
		return m.OldStatus(ctx)
	case signalexecution.FieldError:
		return m.OldError(ctx)
	case signalexecution.FieldStackTrace:
		return m.OldStackTrace(ctx)
	case signalexecution.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case signalexecution.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SignalExecution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SignalExecutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case signalexecution.FieldEntityID:
		v, ok := value.(schema.SignalEntityID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityID(v)
		return nil
	case signalexecution.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case signalexecution.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case signalexecution.FieldStatus:
		v, ok := value.(schema.ExecutionStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case signalexecution.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case signalexecution.FieldStackTrace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStackTrace(v)
		return nil
	case signalexecution.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case signalexecution.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SignalExecution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SignalExecutionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SignalExecutionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SignalExecutionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SignalExecution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SignalExecutionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(signalexecution.FieldCompletedAt) {
		fields = append(fields, signalexecution.FieldCompletedAt)
	}
	if m.FieldCleared(signalexecution.FieldError) {
		fields = append(fields, signalexecution.FieldError)
	}
	if m.FieldCleared(signalexecution.FieldStackTrace) {
		fields = append(fields, signalexecution.FieldStackTrace)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SignalExecutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SignalExecutionMutation) ClearField(name string) error {
	switch name {
	case signalexecution.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	case signalexecution.FieldError:
		m.ClearError()
		return nil
	case signalexecution.FieldStackTrace:
		m.ClearStackTrace()
		return nil
	}
	return fmt.Errorf("unknown SignalExecution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SignalExecutionMutation) ResetField(name string) error {
	switch name {
	case signalexecution.FieldEntityID:
		m.ResetEntityID()
		return nil
	case signalexecution.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case signalexecution.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case signalexecution.FieldStatus:
		m.ResetStatus()
		return nil
	case signalexecution.FieldError:
		m.ResetError()
		return nil
	case signalexecution.FieldStackTrace:
		m.ResetStackTrace()
		return nil
	case signalexecution.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case signalexecution.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SignalExecution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SignalExecutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.signal != nil {
		edges = append(edges, signalexecution.EdgeSignal)
	}
	if m.execution_data != nil {
		edges = append(edges, signalexecution.EdgeExecutionData)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SignalExecutionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case signalexecution.EdgeSignal:
		if id := m.signal; id != nil {
			return []ent.Value{*id}
		}
	case signalexecution.EdgeExecutionData:
		if id := m.execution_data; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SignalExecutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SignalExecutionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SignalExecutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsignal {
		edges = append(edges, signalexecution.EdgeSignal)
	}
	if m.clearedexecution_data {
		edges = append(edges, signalexecution.EdgeExecutionData)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SignalExecutionMutation) EdgeCleared(name string) bool {
	switch name {
	case signalexecution.EdgeSignal:
		return m.clearedsignal
	case signalexecution.EdgeExecutionData:
		return m.clearedexecution_data
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SignalExecutionMutation) ClearEdge(name string) error {
	switch name {
	case signalexecution.EdgeSignal:
		m.ClearSignal()
		return nil
	case signalexecution.EdgeExecutionData:
		m.ClearExecutionData()
		return nil
	}
	return fmt.Errorf("unknown SignalExecution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SignalExecutionMutation) ResetEdge(name string) error {
	switch name {
	case signalexecution.EdgeSignal:
		m.ResetSignal()
		return nil
	case signalexecution.EdgeExecutionData:
		m.ResetExecutionData()
		return nil
	}
	return fmt.Errorf("unknown SignalExecution edge %s", name)
}

// SignalExecutionDataMutation represents an operation that mutates the SignalExecutionData nodes in the graph.
type SignalExecutionDataMutation struct {
	config
	op               Op
	typ              string
	id               *schema.SignalExecutionDataID
	value            *[]byte
	kind             *uint
	addkind          *int
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	execution        *schema.SignalExecutionID
	clearedexecution bool
	done             bool
	oldValue         func(context.Context) (*SignalExecutionData, error)
	predicates       []predicate.SignalExecutionData
}

var _ ent.Mutation = (*SignalExecutionDataMutation)(nil)

// signalexecutiondataOption allows management of the mutation configuration using functional options.
type signalexecutiondataOption func(*SignalExecutionDataMutation)

// newSignalExecutionDataMutation creates new mutation for the SignalExecutionData entity.
func newSignalExecutionDataMutation(c config, op Op, opts ...signalexecutiondataOption) *SignalExecutionDataMutation {
	m := &SignalExecutionDataMutation{
		config:        c,
		op:            op,
		typ:           TypeSignalExecutionData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSignalExecutionDataID sets the ID field of the mutation.
func withSignalExecutionDataID(id schema.SignalExecutionDataID) signalexecutiondataOption {
	return func(m *SignalExecutionDataMutation) {
		var (
			err   error
			once  sync.Once
			value *SignalExecutionData
		)
		m.oldValue = func(ctx context.Context) (*SignalExecutionData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SignalExecutionData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSignalExecutionData sets the old SignalExecutionData of the mutation.
func withSignalExecutionData(node *SignalExecutionData) signalexecutiondataOption {
	return func(m *SignalExecutionDataMutation) {
		m.oldValue = func(context.Context) (*SignalExecutionData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SignalExecutionDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SignalExecutionDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SignalExecutionData entities.
func (m *SignalExecutionDataMutation) SetID(id schema.SignalExecutionDataID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SignalExecutionDataMutation) ID() (id schema.SignalExecutionDataID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SignalExecutionDataMutation) IDs(ctx context.Context) ([]schema.SignalExecutionDataID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []schema.SignalExecutionDataID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SignalExecutionData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExecutionID sets the "execution_id" field.
func (m *SignalExecutionDataMutation) SetExecutionID(sei schema.SignalExecutionID) {
	m.execution = &sei
}

// ExecutionID returns the value of the "execution_id" field in the mutation.
func (m *SignalExecutionDataMutation) ExecutionID() (r schema.SignalExecutionID, exists bool) {
	v := m.execution
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutionID returns the old "execution_id" field's value of the SignalExecutionData entity.
// If the SignalExecutionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalExecutionDataMutation) OldExecutionID(ctx context.Context) (v schema.SignalExecutionID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutionID: %w", err)
	}
	return oldValue.ExecutionID, nil
}

// ResetExecutionID resets all changes to the "execution_id" field.
func (m *SignalExecutionDataMutation) ResetExecutionID() {
	m.execution = nil
}

// SetValue sets the "value" field.
func (m *SignalExecutionDataMutation) SetValue(b []byte) {
	m.value = &b
}

// Value returns the value of the "value" field in the mutation.
func (m *SignalExecutionDataMutation) Value() (r []byte, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the SignalExecutionData entity.
// If the SignalExecutionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalExecutionDataMutation) OldValue(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ClearValue clears the value of the "value" field.
func (m *SignalExecutionDataMutation) ClearValue() {
	m.value = nil
	m.clearedFields[signalexecutiondata.FieldValue] = struct{}{}
}

// ValueCleared returns if the "value" field was cleared in this mutation.
func (m *SignalExecutionDataMutation) ValueCleared() bool {
	_, ok := m.clearedFields[signalexecutiondata.FieldValue]
	return ok
}

// ResetValue resets all changes to the "value" field.
func (m *SignalExecutionDataMutation) ResetValue() {
	m.value = nil
	delete(m.clearedFields, signalexecutiondata.FieldValue)
}

// SetKind sets the "kind" field.
func (m *SignalExecutionDataMutation) SetKind(u uint) {
	m.kind = &u
	m.addkind = nil
}

// Kind returns the value of the "kind" field in the mutation.
func (m *SignalExecutionDataMutation) Kind() (r uint, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the SignalExecutionData entity.
// If the SignalExecutionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalExecutionDataMutation) OldKind(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// AddKind adds u to the "kind" field.
func (m *SignalExecutionDataMutation) AddKind(u int) {
	if m.addkind != nil {
		*m.addkind += u
	} else {
		m.addkind = &u
	}
}

// AddedKind returns the value that was added to the "kind" field in this mutation.
func (m *SignalExecutionDataMutation) AddedKind() (r int, exists bool) {
	v := m.addkind
	if v == nil {
		return
	}
	return *v, true
}

// ResetKind resets all changes to the "kind" field.
func (m *SignalExecutionDataMutation) ResetKind() {
	m.kind = nil
	m.addkind = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SignalExecutionDataMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SignalExecutionDataMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SignalExecutionData entity.
// If the SignalExecutionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalExecutionDataMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SignalExecutionDataMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SignalExecutionDataMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SignalExecutionDataMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SignalExecutionData entity.
// If the SignalExecutionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalExecutionDataMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SignalExecutionDataMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearExecution clears the "execution" edge to the SignalExecution entity.
func (m *SignalExecutionDataMutation) ClearExecution() {
	m.clearedexecution = true
	m.clearedFields[signalexecutiondata.FieldExecutionID] = struct{}{}
}

// ExecutionCleared reports if the "execution" edge to the SignalExecution entity was cleared.
func (m *SignalExecutionDataMutation) ExecutionCleared() bool {
	return m.clearedexecution
}

// ExecutionIDs returns the "execution" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExecutionID instead. It exists only for internal usage by the builders.
func (m *SignalExecutionDataMutation) ExecutionIDs() (ids []schema.SignalExecutionID) {
	if id := m.execution; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExecution resets all changes to the "execution" edge.
func (m *SignalExecutionDataMutation) ResetExecution() {
	m.execution = nil
	m.clearedexecution = false
}

// Where appends a list predicates to the SignalExecutionDataMutation builder.
func (m *SignalExecutionDataMutation) Where(ps ...predicate.SignalExecutionData) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SignalExecutionDataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SignalExecutionDataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SignalExecutionData, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SignalExecutionDataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SignalExecutionDataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SignalExecutionData).
func (m *SignalExecutionDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SignalExecutionDataMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.execution != nil {
		fields = append(fields, signalexecutiondata.FieldExecutionID)
	}
	if m.value != nil {
		fields = append(fields, signalexecutiondata.FieldValue)
	}
	if m.kind != nil {
		fields = append(fields, signalexecutiondata.FieldKind)
	}
	if m.created_at != nil {
		fields = append(fields, signalexecutiondata.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, signalexecutiondata.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SignalExecutionDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case signalexecutiondata.FieldExecutionID:
		return m.ExecutionID()
	case signalexecutiondata.FieldValue:
		return m.Value()
	case signalexecutiondata.FieldKind:
		return m.Kind()
	case signalexecutiondata.FieldCreatedAt:
		return m.CreatedAt()
	case signalexecutiondata.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SignalExecutionDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case signalexecutiondata.FieldExecutionID:
		return m.OldExecutionID(ctx)
	case signalexecutiondata.FieldValue:
		return m.OldValue(ctx)
	case signalexecutiondata.FieldKind:
		return m.OldKind(ctx)
	case signalexecutiondata.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case signalexecutiondata.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SignalExecutionData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SignalExecutionDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case signalexecutiondata.FieldExecutionID:
		v, ok := value.(schema.SignalExecutionID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutionID(v)
		return nil
	case signalexecutiondata.FieldValue:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case signalexecutiondata.FieldKind:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case signalexecutiondata.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case signalexecutiondata.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SignalExecutionData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SignalExecutionDataMutation) AddedFields() []string {
	var fields []string
	if m.addkind != nil {
		fields = append(fields, signalexecutiondata.FieldKind)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SignalExecutionDataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case signalexecutiondata.FieldKind:
		return m.AddedKind()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SignalExecutionDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	case signalexecutiondata.FieldKind:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddKind(v)
		return nil
	}
	return fmt.Errorf("unknown SignalExecutionData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SignalExecutionDataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(signalexecutiondata.FieldValue) {
		fields = append(fields, signalexecutiondata.FieldValue)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SignalExecutionDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SignalExecutionDataMutation) ClearField(name string) error {
	switch name {
	case signalexecutiondata.FieldValue:
		m.ClearValue()
		return nil
	}
	return fmt.Errorf("unknown SignalExecutionData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SignalExecutionDataMutation) ResetField(name string) error {
	switch name {
	case signalexecutiondata.FieldExecutionID:
		m.ResetExecutionID()
		return nil
	case signalexecutiondata.FieldValue:
		m.ResetValue()
		return nil
	case signalexecutiondata.FieldKind:
		m.ResetKind()
		return nil
	case signalexecutiondata.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case signalexecutiondata.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SignalExecutionData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SignalExecutionDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.execution != nil {
		edges = append(edges, signalexecutiondata.EdgeExecution)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SignalExecutionDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case signalexecutiondata.EdgeExecution:
		if id := m.execution; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SignalExecutionDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SignalExecutionDataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SignalExecutionDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedexecution {
		edges = append(edges, signalexecutiondata.EdgeExecution)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SignalExecutionDataMutation) EdgeCleared(name string) bool {
	switch name {
	case signalexecutiondata.EdgeExecution:
		return m.clearedexecution
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SignalExecutionDataMutation) ClearEdge(name string) error {
	switch name {
	case signalexecutiondata.EdgeExecution:
		m.ClearExecution()
		return nil
	}
	return fmt.Errorf("unknown SignalExecutionData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SignalExecutionDataMutation) ResetEdge(name string) error {
	switch name {
	case signalexecutiondata.EdgeExecution:
		m.ResetExecution()
		return nil
	}
	return fmt.Errorf("unknown SignalExecutionData edge %s", name)
}

// VersionMutation represents an operation that mutates the Version nodes in the graph.
type VersionMutation struct {
	config
	op              Op
	typ             string
	id              *schema.VersionID
	change_id       *schema.VersionChange
	version         *schema.VersionNumber
	addversion      *schema.VersionNumber
	data            *map[string]interface{}
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	workflow        *schema.WorkflowEntityID
	clearedworkflow bool
	done            bool
	oldValue        func(context.Context) (*Version, error)
	predicates      []predicate.Version
}

var _ ent.Mutation = (*VersionMutation)(nil)

// versionOption allows management of the mutation configuration using functional options.
type versionOption func(*VersionMutation)

// newVersionMutation creates new mutation for the Version entity.
func newVersionMutation(c config, op Op, opts ...versionOption) *VersionMutation {
	m := &VersionMutation{
		config:        c,
		op:            op,
		typ:           TypeVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVersionID sets the ID field of the mutation.
func withVersionID(id schema.VersionID) versionOption {
	return func(m *VersionMutation) {
		var (
			err   error
			once  sync.Once
			value *Version
		)
		m.oldValue = func(ctx context.Context) (*Version, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Version.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVersion sets the old Version of the mutation.
func withVersion(node *Version) versionOption {
	return func(m *VersionMutation) {
		m.oldValue = func(context.Context) (*Version, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Version entities.
func (m *VersionMutation) SetID(id schema.VersionID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VersionMutation) ID() (id schema.VersionID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VersionMutation) IDs(ctx context.Context) ([]schema.VersionID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []schema.VersionID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Version.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntityID sets the "entity_id" field.
func (m *VersionMutation) SetEntityID(sei schema.WorkflowEntityID) {
	m.workflow = &sei
}

// EntityID returns the value of the "entity_id" field in the mutation.
func (m *VersionMutation) EntityID() (r schema.WorkflowEntityID, exists bool) {
	v := m.workflow
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityID returns the old "entity_id" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldEntityID(ctx context.Context) (v schema.WorkflowEntityID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityID: %w", err)
	}
	return oldValue.EntityID, nil
}

// ResetEntityID resets all changes to the "entity_id" field.
func (m *VersionMutation) ResetEntityID() {
	m.workflow = nil
}

// SetChangeID sets the "change_id" field.
func (m *VersionMutation) SetChangeID(sc schema.VersionChange) {
	m.change_id = &sc
}

// ChangeID returns the value of the "change_id" field in the mutation.
func (m *VersionMutation) ChangeID() (r schema.VersionChange, exists bool) {
	v := m.change_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChangeID returns the old "change_id" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldChangeID(ctx context.Context) (v schema.VersionChange, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChangeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChangeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChangeID: %w", err)
	}
	return oldValue.ChangeID, nil
}

// ResetChangeID resets all changes to the "change_id" field.
func (m *VersionMutation) ResetChangeID() {
	m.change_id = nil
}

// SetVersion sets the "version" field.
func (m *VersionMutation) SetVersion(sn schema.VersionNumber) {
	m.version = &sn
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *VersionMutation) Version() (r schema.VersionNumber, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldVersion(ctx context.Context) (v schema.VersionNumber, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds sn to the "version" field.
func (m *VersionMutation) AddVersion(sn schema.VersionNumber) {
	if m.addversion != nil {
		*m.addversion += sn
	} else {
		m.addversion = &sn
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *VersionMutation) AddedVersion() (r schema.VersionNumber, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *VersionMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetData sets the "data" field.
func (m *VersionMutation) SetData(value map[string]interface{}) {
	m.data = &value
}

// Data returns the value of the "data" field in the mutation.
func (m *VersionMutation) Data() (r map[string]interface{}, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *VersionMutation) ResetData() {
	m.data = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *VersionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VersionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VersionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VersionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VersionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VersionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetWorkflowID sets the "workflow" edge to the WorkflowEntity entity by id.
func (m *VersionMutation) SetWorkflowID(id schema.WorkflowEntityID) {
	m.workflow = &id
}

// ClearWorkflow clears the "workflow" edge to the WorkflowEntity entity.
func (m *VersionMutation) ClearWorkflow() {
	m.clearedworkflow = true
	m.clearedFields[version.FieldEntityID] = struct{}{}
}

// WorkflowCleared reports if the "workflow" edge to the WorkflowEntity entity was cleared.
func (m *VersionMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowID returns the "workflow" edge ID in the mutation.
func (m *VersionMutation) WorkflowID() (id schema.WorkflowEntityID, exists bool) {
	if m.workflow != nil {
		return *m.workflow, true
	}
	return
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *VersionMutation) WorkflowIDs() (ids []schema.WorkflowEntityID) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *VersionMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// Where appends a list predicates to the VersionMutation builder.
func (m *VersionMutation) Where(ps ...predicate.Version) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Version, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Version).
func (m *VersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VersionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.workflow != nil {
		fields = append(fields, version.FieldEntityID)
	}
	if m.change_id != nil {
		fields = append(fields, version.FieldChangeID)
	}
	if m.version != nil {
		fields = append(fields, version.FieldVersion)
	}
	if m.data != nil {
		fields = append(fields, version.FieldData)
	}
	if m.created_at != nil {
		fields = append(fields, version.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, version.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case version.FieldEntityID:
		return m.EntityID()
	case version.FieldChangeID:
		return m.ChangeID()
	case version.FieldVersion:
		return m.Version()
	case version.FieldData:
		return m.Data()
	case version.FieldCreatedAt:
		return m.CreatedAt()
	case version.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case version.FieldEntityID:
		return m.OldEntityID(ctx)
	case version.FieldChangeID:
		return m.OldChangeID(ctx)
	case version.FieldVersion:
		return m.OldVersion(ctx)
	case version.FieldData:
		return m.OldData(ctx)
	case version.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case version.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Version field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case version.FieldEntityID:
		v, ok := value.(schema.WorkflowEntityID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityID(v)
		return nil
	case version.FieldChangeID:
		v, ok := value.(schema.VersionChange)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChangeID(v)
		return nil
	case version.FieldVersion:
		v, ok := value.(schema.VersionNumber)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case version.FieldData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case version.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case version.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Version field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VersionMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, version.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VersionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case version.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case version.FieldVersion:
		v, ok := value.(schema.VersionNumber)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Version numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VersionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VersionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Version nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VersionMutation) ResetField(name string) error {
	switch name {
	case version.FieldEntityID:
		m.ResetEntityID()
		return nil
	case version.FieldChangeID:
		m.ResetChangeID()
		return nil
	case version.FieldVersion:
		m.ResetVersion()
		return nil
	case version.FieldData:
		m.ResetData()
		return nil
	case version.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case version.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Version field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.workflow != nil {
		edges = append(edges, version.EdgeWorkflow)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VersionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case version.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VersionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedworkflow {
		edges = append(edges, version.EdgeWorkflow)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VersionMutation) EdgeCleared(name string) bool {
	switch name {
	case version.EdgeWorkflow:
		return m.clearedworkflow
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VersionMutation) ClearEdge(name string) error {
	switch name {
	case version.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	}
	return fmt.Errorf("unknown Version unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VersionMutation) ResetEdge(name string) error {
	switch name {
	case version.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	}
	return fmt.Errorf("unknown Version edge %s", name)
}

// WorkflowDataMutation represents an operation that mutates the WorkflowData nodes in the graph.
type WorkflowDataMutation struct {
	config
	op                          Op
	typ                         string
	id                          *schema.WorkflowDataID
	duration                    *string
	paused                      *bool
	resumable                   *bool
	is_root                     *bool
	inputs                      *[][]uint8
	appendinputs                [][]uint8
	continued_from              *schema.WorkflowEntityID
	addcontinued_from           *schema.WorkflowEntityID
	continued_execution_from    *schema.WorkflowExecutionID
	addcontinued_execution_from *schema.WorkflowExecutionID
	workflow_step_id            *string
	workflow_from               *schema.WorkflowEntityID
	addworkflow_from            *schema.WorkflowEntityID
	workflow_execution_from     *schema.WorkflowExecutionID
	addworkflow_execution_from  *schema.WorkflowExecutionID
	created_at                  *time.Time
	updated_at                  *time.Time
	clearedFields               map[string]struct{}
	workflow                    *schema.WorkflowEntityID
	clearedworkflow             bool
	done                        bool
	oldValue                    func(context.Context) (*WorkflowData, error)
	predicates                  []predicate.WorkflowData
}

var _ ent.Mutation = (*WorkflowDataMutation)(nil)

// workflowdataOption allows management of the mutation configuration using functional options.
type workflowdataOption func(*WorkflowDataMutation)

// newWorkflowDataMutation creates new mutation for the WorkflowData entity.
func newWorkflowDataMutation(c config, op Op, opts ...workflowdataOption) *WorkflowDataMutation {
	m := &WorkflowDataMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflowData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowDataID sets the ID field of the mutation.
func withWorkflowDataID(id schema.WorkflowDataID) workflowdataOption {
	return func(m *WorkflowDataMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkflowData
		)
		m.oldValue = func(ctx context.Context) (*WorkflowData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkflowData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflowData sets the old WorkflowData of the mutation.
func withWorkflowData(node *WorkflowData) workflowdataOption {
	return func(m *WorkflowDataMutation) {
		m.oldValue = func(context.Context) (*WorkflowData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkflowData entities.
func (m *WorkflowDataMutation) SetID(id schema.WorkflowDataID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowDataMutation) ID() (id schema.WorkflowDataID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowDataMutation) IDs(ctx context.Context) ([]schema.WorkflowDataID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []schema.WorkflowDataID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkflowData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntityID sets the "entity_id" field.
func (m *WorkflowDataMutation) SetEntityID(sei schema.WorkflowEntityID) {
	m.workflow = &sei
}

// EntityID returns the value of the "entity_id" field in the mutation.
func (m *WorkflowDataMutation) EntityID() (r schema.WorkflowEntityID, exists bool) {
	v := m.workflow
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityID returns the old "entity_id" field's value of the WorkflowData entity.
// If the WorkflowData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDataMutation) OldEntityID(ctx context.Context) (v schema.WorkflowEntityID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityID: %w", err)
	}
	return oldValue.EntityID, nil
}

// ResetEntityID resets all changes to the "entity_id" field.
func (m *WorkflowDataMutation) ResetEntityID() {
	m.workflow = nil
}

// SetDuration sets the "duration" field.
func (m *WorkflowDataMutation) SetDuration(s string) {
	m.duration = &s
}

// Duration returns the value of the "duration" field in the mutation.
func (m *WorkflowDataMutation) Duration() (r string, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the WorkflowData entity.
// If the WorkflowData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDataMutation) OldDuration(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// ClearDuration clears the value of the "duration" field.
func (m *WorkflowDataMutation) ClearDuration() {
	m.duration = nil
	m.clearedFields[workflowdata.FieldDuration] = struct{}{}
}

// DurationCleared returns if the "duration" field was cleared in this mutation.
func (m *WorkflowDataMutation) DurationCleared() bool {
	_, ok := m.clearedFields[workflowdata.FieldDuration]
	return ok
}

// ResetDuration resets all changes to the "duration" field.
func (m *WorkflowDataMutation) ResetDuration() {
	m.duration = nil
	delete(m.clearedFields, workflowdata.FieldDuration)
}

// SetPaused sets the "paused" field.
func (m *WorkflowDataMutation) SetPaused(b bool) {
	m.paused = &b
}

// Paused returns the value of the "paused" field in the mutation.
func (m *WorkflowDataMutation) Paused() (r bool, exists bool) {
	v := m.paused
	if v == nil {
		return
	}
	return *v, true
}

// OldPaused returns the old "paused" field's value of the WorkflowData entity.
// If the WorkflowData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDataMutation) OldPaused(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaused is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaused requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaused: %w", err)
	}
	return oldValue.Paused, nil
}

// ResetPaused resets all changes to the "paused" field.
func (m *WorkflowDataMutation) ResetPaused() {
	m.paused = nil
}

// SetResumable sets the "resumable" field.
func (m *WorkflowDataMutation) SetResumable(b bool) {
	m.resumable = &b
}

// Resumable returns the value of the "resumable" field in the mutation.
func (m *WorkflowDataMutation) Resumable() (r bool, exists bool) {
	v := m.resumable
	if v == nil {
		return
	}
	return *v, true
}

// OldResumable returns the old "resumable" field's value of the WorkflowData entity.
// If the WorkflowData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDataMutation) OldResumable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResumable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResumable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResumable: %w", err)
	}
	return oldValue.Resumable, nil
}

// ResetResumable resets all changes to the "resumable" field.
func (m *WorkflowDataMutation) ResetResumable() {
	m.resumable = nil
}

// SetIsRoot sets the "is_root" field.
func (m *WorkflowDataMutation) SetIsRoot(b bool) {
	m.is_root = &b
}

// IsRoot returns the value of the "is_root" field in the mutation.
func (m *WorkflowDataMutation) IsRoot() (r bool, exists bool) {
	v := m.is_root
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRoot returns the old "is_root" field's value of the WorkflowData entity.
// If the WorkflowData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDataMutation) OldIsRoot(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRoot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRoot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRoot: %w", err)
	}
	return oldValue.IsRoot, nil
}

// ResetIsRoot resets all changes to the "is_root" field.
func (m *WorkflowDataMutation) ResetIsRoot() {
	m.is_root = nil
}

// SetInputs sets the "inputs" field.
func (m *WorkflowDataMutation) SetInputs(u [][]uint8) {
	m.inputs = &u
	m.appendinputs = nil
}

// Inputs returns the value of the "inputs" field in the mutation.
func (m *WorkflowDataMutation) Inputs() (r [][]uint8, exists bool) {
	v := m.inputs
	if v == nil {
		return
	}
	return *v, true
}

// OldInputs returns the old "inputs" field's value of the WorkflowData entity.
// If the WorkflowData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDataMutation) OldInputs(ctx context.Context) (v [][]uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInputs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInputs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInputs: %w", err)
	}
	return oldValue.Inputs, nil
}

// AppendInputs adds u to the "inputs" field.
func (m *WorkflowDataMutation) AppendInputs(u [][]uint8) {
	m.appendinputs = append(m.appendinputs, u...)
}

// AppendedInputs returns the list of values that were appended to the "inputs" field in this mutation.
func (m *WorkflowDataMutation) AppendedInputs() ([][]uint8, bool) {
	if len(m.appendinputs) == 0 {
		return nil, false
	}
	return m.appendinputs, true
}

// ClearInputs clears the value of the "inputs" field.
func (m *WorkflowDataMutation) ClearInputs() {
	m.inputs = nil
	m.appendinputs = nil
	m.clearedFields[workflowdata.FieldInputs] = struct{}{}
}

// InputsCleared returns if the "inputs" field was cleared in this mutation.
func (m *WorkflowDataMutation) InputsCleared() bool {
	_, ok := m.clearedFields[workflowdata.FieldInputs]
	return ok
}

// ResetInputs resets all changes to the "inputs" field.
func (m *WorkflowDataMutation) ResetInputs() {
	m.inputs = nil
	m.appendinputs = nil
	delete(m.clearedFields, workflowdata.FieldInputs)
}

// SetContinuedFrom sets the "continued_from" field.
func (m *WorkflowDataMutation) SetContinuedFrom(sei schema.WorkflowEntityID) {
	m.continued_from = &sei
	m.addcontinued_from = nil
}

// ContinuedFrom returns the value of the "continued_from" field in the mutation.
func (m *WorkflowDataMutation) ContinuedFrom() (r schema.WorkflowEntityID, exists bool) {
	v := m.continued_from
	if v == nil {
		return
	}
	return *v, true
}

// OldContinuedFrom returns the old "continued_from" field's value of the WorkflowData entity.
// If the WorkflowData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDataMutation) OldContinuedFrom(ctx context.Context) (v *schema.WorkflowEntityID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContinuedFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContinuedFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContinuedFrom: %w", err)
	}
	return oldValue.ContinuedFrom, nil
}

// AddContinuedFrom adds sei to the "continued_from" field.
func (m *WorkflowDataMutation) AddContinuedFrom(sei schema.WorkflowEntityID) {
	if m.addcontinued_from != nil {
		*m.addcontinued_from += sei
	} else {
		m.addcontinued_from = &sei
	}
}

// AddedContinuedFrom returns the value that was added to the "continued_from" field in this mutation.
func (m *WorkflowDataMutation) AddedContinuedFrom() (r schema.WorkflowEntityID, exists bool) {
	v := m.addcontinued_from
	if v == nil {
		return
	}
	return *v, true
}

// ClearContinuedFrom clears the value of the "continued_from" field.
func (m *WorkflowDataMutation) ClearContinuedFrom() {
	m.continued_from = nil
	m.addcontinued_from = nil
	m.clearedFields[workflowdata.FieldContinuedFrom] = struct{}{}
}

// ContinuedFromCleared returns if the "continued_from" field was cleared in this mutation.
func (m *WorkflowDataMutation) ContinuedFromCleared() bool {
	_, ok := m.clearedFields[workflowdata.FieldContinuedFrom]
	return ok
}

// ResetContinuedFrom resets all changes to the "continued_from" field.
func (m *WorkflowDataMutation) ResetContinuedFrom() {
	m.continued_from = nil
	m.addcontinued_from = nil
	delete(m.clearedFields, workflowdata.FieldContinuedFrom)
}

// SetContinuedExecutionFrom sets the "continued_execution_from" field.
func (m *WorkflowDataMutation) SetContinuedExecutionFrom(sei schema.WorkflowExecutionID) {
	m.continued_execution_from = &sei
	m.addcontinued_execution_from = nil
}

// ContinuedExecutionFrom returns the value of the "continued_execution_from" field in the mutation.
func (m *WorkflowDataMutation) ContinuedExecutionFrom() (r schema.WorkflowExecutionID, exists bool) {
	v := m.continued_execution_from
	if v == nil {
		return
	}
	return *v, true
}

// OldContinuedExecutionFrom returns the old "continued_execution_from" field's value of the WorkflowData entity.
// If the WorkflowData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDataMutation) OldContinuedExecutionFrom(ctx context.Context) (v *schema.WorkflowExecutionID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContinuedExecutionFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContinuedExecutionFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContinuedExecutionFrom: %w", err)
	}
	return oldValue.ContinuedExecutionFrom, nil
}

// AddContinuedExecutionFrom adds sei to the "continued_execution_from" field.
func (m *WorkflowDataMutation) AddContinuedExecutionFrom(sei schema.WorkflowExecutionID) {
	if m.addcontinued_execution_from != nil {
		*m.addcontinued_execution_from += sei
	} else {
		m.addcontinued_execution_from = &sei
	}
}

// AddedContinuedExecutionFrom returns the value that was added to the "continued_execution_from" field in this mutation.
func (m *WorkflowDataMutation) AddedContinuedExecutionFrom() (r schema.WorkflowExecutionID, exists bool) {
	v := m.addcontinued_execution_from
	if v == nil {
		return
	}
	return *v, true
}

// ClearContinuedExecutionFrom clears the value of the "continued_execution_from" field.
func (m *WorkflowDataMutation) ClearContinuedExecutionFrom() {
	m.continued_execution_from = nil
	m.addcontinued_execution_from = nil
	m.clearedFields[workflowdata.FieldContinuedExecutionFrom] = struct{}{}
}

// ContinuedExecutionFromCleared returns if the "continued_execution_from" field was cleared in this mutation.
func (m *WorkflowDataMutation) ContinuedExecutionFromCleared() bool {
	_, ok := m.clearedFields[workflowdata.FieldContinuedExecutionFrom]
	return ok
}

// ResetContinuedExecutionFrom resets all changes to the "continued_execution_from" field.
func (m *WorkflowDataMutation) ResetContinuedExecutionFrom() {
	m.continued_execution_from = nil
	m.addcontinued_execution_from = nil
	delete(m.clearedFields, workflowdata.FieldContinuedExecutionFrom)
}

// SetWorkflowStepID sets the "workflow_step_id" field.
func (m *WorkflowDataMutation) SetWorkflowStepID(s string) {
	m.workflow_step_id = &s
}

// WorkflowStepID returns the value of the "workflow_step_id" field in the mutation.
func (m *WorkflowDataMutation) WorkflowStepID() (r string, exists bool) {
	v := m.workflow_step_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowStepID returns the old "workflow_step_id" field's value of the WorkflowData entity.
// If the WorkflowData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDataMutation) OldWorkflowStepID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowStepID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowStepID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowStepID: %w", err)
	}
	return oldValue.WorkflowStepID, nil
}

// ClearWorkflowStepID clears the value of the "workflow_step_id" field.
func (m *WorkflowDataMutation) ClearWorkflowStepID() {
	m.workflow_step_id = nil
	m.clearedFields[workflowdata.FieldWorkflowStepID] = struct{}{}
}

// WorkflowStepIDCleared returns if the "workflow_step_id" field was cleared in this mutation.
func (m *WorkflowDataMutation) WorkflowStepIDCleared() bool {
	_, ok := m.clearedFields[workflowdata.FieldWorkflowStepID]
	return ok
}

// ResetWorkflowStepID resets all changes to the "workflow_step_id" field.
func (m *WorkflowDataMutation) ResetWorkflowStepID() {
	m.workflow_step_id = nil
	delete(m.clearedFields, workflowdata.FieldWorkflowStepID)
}

// SetWorkflowFrom sets the "workflow_from" field.
func (m *WorkflowDataMutation) SetWorkflowFrom(sei schema.WorkflowEntityID) {
	m.workflow_from = &sei
	m.addworkflow_from = nil
}

// WorkflowFrom returns the value of the "workflow_from" field in the mutation.
func (m *WorkflowDataMutation) WorkflowFrom() (r schema.WorkflowEntityID, exists bool) {
	v := m.workflow_from
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowFrom returns the old "workflow_from" field's value of the WorkflowData entity.
// If the WorkflowData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDataMutation) OldWorkflowFrom(ctx context.Context) (v *schema.WorkflowEntityID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowFrom: %w", err)
	}
	return oldValue.WorkflowFrom, nil
}

// AddWorkflowFrom adds sei to the "workflow_from" field.
func (m *WorkflowDataMutation) AddWorkflowFrom(sei schema.WorkflowEntityID) {
	if m.addworkflow_from != nil {
		*m.addworkflow_from += sei
	} else {
		m.addworkflow_from = &sei
	}
}

// AddedWorkflowFrom returns the value that was added to the "workflow_from" field in this mutation.
func (m *WorkflowDataMutation) AddedWorkflowFrom() (r schema.WorkflowEntityID, exists bool) {
	v := m.addworkflow_from
	if v == nil {
		return
	}
	return *v, true
}

// ClearWorkflowFrom clears the value of the "workflow_from" field.
func (m *WorkflowDataMutation) ClearWorkflowFrom() {
	m.workflow_from = nil
	m.addworkflow_from = nil
	m.clearedFields[workflowdata.FieldWorkflowFrom] = struct{}{}
}

// WorkflowFromCleared returns if the "workflow_from" field was cleared in this mutation.
func (m *WorkflowDataMutation) WorkflowFromCleared() bool {
	_, ok := m.clearedFields[workflowdata.FieldWorkflowFrom]
	return ok
}

// ResetWorkflowFrom resets all changes to the "workflow_from" field.
func (m *WorkflowDataMutation) ResetWorkflowFrom() {
	m.workflow_from = nil
	m.addworkflow_from = nil
	delete(m.clearedFields, workflowdata.FieldWorkflowFrom)
}

// SetWorkflowExecutionFrom sets the "workflow_execution_from" field.
func (m *WorkflowDataMutation) SetWorkflowExecutionFrom(sei schema.WorkflowExecutionID) {
	m.workflow_execution_from = &sei
	m.addworkflow_execution_from = nil
}

// WorkflowExecutionFrom returns the value of the "workflow_execution_from" field in the mutation.
func (m *WorkflowDataMutation) WorkflowExecutionFrom() (r schema.WorkflowExecutionID, exists bool) {
	v := m.workflow_execution_from
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowExecutionFrom returns the old "workflow_execution_from" field's value of the WorkflowData entity.
// If the WorkflowData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDataMutation) OldWorkflowExecutionFrom(ctx context.Context) (v *schema.WorkflowExecutionID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowExecutionFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowExecutionFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowExecutionFrom: %w", err)
	}
	return oldValue.WorkflowExecutionFrom, nil
}

// AddWorkflowExecutionFrom adds sei to the "workflow_execution_from" field.
func (m *WorkflowDataMutation) AddWorkflowExecutionFrom(sei schema.WorkflowExecutionID) {
	if m.addworkflow_execution_from != nil {
		*m.addworkflow_execution_from += sei
	} else {
		m.addworkflow_execution_from = &sei
	}
}

// AddedWorkflowExecutionFrom returns the value that was added to the "workflow_execution_from" field in this mutation.
func (m *WorkflowDataMutation) AddedWorkflowExecutionFrom() (r schema.WorkflowExecutionID, exists bool) {
	v := m.addworkflow_execution_from
	if v == nil {
		return
	}
	return *v, true
}

// ClearWorkflowExecutionFrom clears the value of the "workflow_execution_from" field.
func (m *WorkflowDataMutation) ClearWorkflowExecutionFrom() {
	m.workflow_execution_from = nil
	m.addworkflow_execution_from = nil
	m.clearedFields[workflowdata.FieldWorkflowExecutionFrom] = struct{}{}
}

// WorkflowExecutionFromCleared returns if the "workflow_execution_from" field was cleared in this mutation.
func (m *WorkflowDataMutation) WorkflowExecutionFromCleared() bool {
	_, ok := m.clearedFields[workflowdata.FieldWorkflowExecutionFrom]
	return ok
}

// ResetWorkflowExecutionFrom resets all changes to the "workflow_execution_from" field.
func (m *WorkflowDataMutation) ResetWorkflowExecutionFrom() {
	m.workflow_execution_from = nil
	m.addworkflow_execution_from = nil
	delete(m.clearedFields, workflowdata.FieldWorkflowExecutionFrom)
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkflowDataMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkflowDataMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WorkflowData entity.
// If the WorkflowData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDataMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkflowDataMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkflowDataMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkflowDataMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WorkflowData entity.
// If the WorkflowData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowDataMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkflowDataMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetWorkflowID sets the "workflow" edge to the WorkflowEntity entity by id.
func (m *WorkflowDataMutation) SetWorkflowID(id schema.WorkflowEntityID) {
	m.workflow = &id
}

// ClearWorkflow clears the "workflow" edge to the WorkflowEntity entity.
func (m *WorkflowDataMutation) ClearWorkflow() {
	m.clearedworkflow = true
	m.clearedFields[workflowdata.FieldEntityID] = struct{}{}
}

// WorkflowCleared reports if the "workflow" edge to the WorkflowEntity entity was cleared.
func (m *WorkflowDataMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowID returns the "workflow" edge ID in the mutation.
func (m *WorkflowDataMutation) WorkflowID() (id schema.WorkflowEntityID, exists bool) {
	if m.workflow != nil {
		return *m.workflow, true
	}
	return
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *WorkflowDataMutation) WorkflowIDs() (ids []schema.WorkflowEntityID) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *WorkflowDataMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// Where appends a list predicates to the WorkflowDataMutation builder.
func (m *WorkflowDataMutation) Where(ps ...predicate.WorkflowData) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowDataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowDataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkflowData, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowDataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowDataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkflowData).
func (m *WorkflowDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowDataMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.workflow != nil {
		fields = append(fields, workflowdata.FieldEntityID)
	}
	if m.duration != nil {
		fields = append(fields, workflowdata.FieldDuration)
	}
	if m.paused != nil {
		fields = append(fields, workflowdata.FieldPaused)
	}
	if m.resumable != nil {
		fields = append(fields, workflowdata.FieldResumable)
	}
	if m.is_root != nil {
		fields = append(fields, workflowdata.FieldIsRoot)
	}
	if m.inputs != nil {
		fields = append(fields, workflowdata.FieldInputs)
	}
	if m.continued_from != nil {
		fields = append(fields, workflowdata.FieldContinuedFrom)
	}
	if m.continued_execution_from != nil {
		fields = append(fields, workflowdata.FieldContinuedExecutionFrom)
	}
	if m.workflow_step_id != nil {
		fields = append(fields, workflowdata.FieldWorkflowStepID)
	}
	if m.workflow_from != nil {
		fields = append(fields, workflowdata.FieldWorkflowFrom)
	}
	if m.workflow_execution_from != nil {
		fields = append(fields, workflowdata.FieldWorkflowExecutionFrom)
	}
	if m.created_at != nil {
		fields = append(fields, workflowdata.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workflowdata.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflowdata.FieldEntityID:
		return m.EntityID()
	case workflowdata.FieldDuration:
		return m.Duration()
	case workflowdata.FieldPaused:
		return m.Paused()
	case workflowdata.FieldResumable:
		return m.Resumable()
	case workflowdata.FieldIsRoot:
		return m.IsRoot()
	case workflowdata.FieldInputs:
		return m.Inputs()
	case workflowdata.FieldContinuedFrom:
		return m.ContinuedFrom()
	case workflowdata.FieldContinuedExecutionFrom:
		return m.ContinuedExecutionFrom()
	case workflowdata.FieldWorkflowStepID:
		return m.WorkflowStepID()
	case workflowdata.FieldWorkflowFrom:
		return m.WorkflowFrom()
	case workflowdata.FieldWorkflowExecutionFrom:
		return m.WorkflowExecutionFrom()
	case workflowdata.FieldCreatedAt:
		return m.CreatedAt()
	case workflowdata.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflowdata.FieldEntityID:
		return m.OldEntityID(ctx)
	case workflowdata.FieldDuration:
		return m.OldDuration(ctx)
	case workflowdata.FieldPaused:
		return m.OldPaused(ctx)
	case workflowdata.FieldResumable:
		return m.OldResumable(ctx)
	case workflowdata.FieldIsRoot:
		return m.OldIsRoot(ctx)
	case workflowdata.FieldInputs:
		return m.OldInputs(ctx)
	case workflowdata.FieldContinuedFrom:
		return m.OldContinuedFrom(ctx)
	case workflowdata.FieldContinuedExecutionFrom:
		return m.OldContinuedExecutionFrom(ctx)
	case workflowdata.FieldWorkflowStepID:
		return m.OldWorkflowStepID(ctx)
	case workflowdata.FieldWorkflowFrom:
		return m.OldWorkflowFrom(ctx)
	case workflowdata.FieldWorkflowExecutionFrom:
		return m.OldWorkflowExecutionFrom(ctx)
	case workflowdata.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workflowdata.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown WorkflowData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflowdata.FieldEntityID:
		v, ok := value.(schema.WorkflowEntityID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityID(v)
		return nil
	case workflowdata.FieldDuration:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case workflowdata.FieldPaused:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaused(v)
		return nil
	case workflowdata.FieldResumable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResumable(v)
		return nil
	case workflowdata.FieldIsRoot:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRoot(v)
		return nil
	case workflowdata.FieldInputs:
		v, ok := value.([][]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInputs(v)
		return nil
	case workflowdata.FieldContinuedFrom:
		v, ok := value.(schema.WorkflowEntityID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContinuedFrom(v)
		return nil
	case workflowdata.FieldContinuedExecutionFrom:
		v, ok := value.(schema.WorkflowExecutionID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContinuedExecutionFrom(v)
		return nil
	case workflowdata.FieldWorkflowStepID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowStepID(v)
		return nil
	case workflowdata.FieldWorkflowFrom:
		v, ok := value.(schema.WorkflowEntityID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowFrom(v)
		return nil
	case workflowdata.FieldWorkflowExecutionFrom:
		v, ok := value.(schema.WorkflowExecutionID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowExecutionFrom(v)
		return nil
	case workflowdata.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workflowdata.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowDataMutation) AddedFields() []string {
	var fields []string
	if m.addcontinued_from != nil {
		fields = append(fields, workflowdata.FieldContinuedFrom)
	}
	if m.addcontinued_execution_from != nil {
		fields = append(fields, workflowdata.FieldContinuedExecutionFrom)
	}
	if m.addworkflow_from != nil {
		fields = append(fields, workflowdata.FieldWorkflowFrom)
	}
	if m.addworkflow_execution_from != nil {
		fields = append(fields, workflowdata.FieldWorkflowExecutionFrom)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowDataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workflowdata.FieldContinuedFrom:
		return m.AddedContinuedFrom()
	case workflowdata.FieldContinuedExecutionFrom:
		return m.AddedContinuedExecutionFrom()
	case workflowdata.FieldWorkflowFrom:
		return m.AddedWorkflowFrom()
	case workflowdata.FieldWorkflowExecutionFrom:
		return m.AddedWorkflowExecutionFrom()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workflowdata.FieldContinuedFrom:
		v, ok := value.(schema.WorkflowEntityID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContinuedFrom(v)
		return nil
	case workflowdata.FieldContinuedExecutionFrom:
		v, ok := value.(schema.WorkflowExecutionID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContinuedExecutionFrom(v)
		return nil
	case workflowdata.FieldWorkflowFrom:
		v, ok := value.(schema.WorkflowEntityID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWorkflowFrom(v)
		return nil
	case workflowdata.FieldWorkflowExecutionFrom:
		v, ok := value.(schema.WorkflowExecutionID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWorkflowExecutionFrom(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowDataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflowdata.FieldDuration) {
		fields = append(fields, workflowdata.FieldDuration)
	}
	if m.FieldCleared(workflowdata.FieldInputs) {
		fields = append(fields, workflowdata.FieldInputs)
	}
	if m.FieldCleared(workflowdata.FieldContinuedFrom) {
		fields = append(fields, workflowdata.FieldContinuedFrom)
	}
	if m.FieldCleared(workflowdata.FieldContinuedExecutionFrom) {
		fields = append(fields, workflowdata.FieldContinuedExecutionFrom)
	}
	if m.FieldCleared(workflowdata.FieldWorkflowStepID) {
		fields = append(fields, workflowdata.FieldWorkflowStepID)
	}
	if m.FieldCleared(workflowdata.FieldWorkflowFrom) {
		fields = append(fields, workflowdata.FieldWorkflowFrom)
	}
	if m.FieldCleared(workflowdata.FieldWorkflowExecutionFrom) {
		fields = append(fields, workflowdata.FieldWorkflowExecutionFrom)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowDataMutation) ClearField(name string) error {
	switch name {
	case workflowdata.FieldDuration:
		m.ClearDuration()
		return nil
	case workflowdata.FieldInputs:
		m.ClearInputs()
		return nil
	case workflowdata.FieldContinuedFrom:
		m.ClearContinuedFrom()
		return nil
	case workflowdata.FieldContinuedExecutionFrom:
		m.ClearContinuedExecutionFrom()
		return nil
	case workflowdata.FieldWorkflowStepID:
		m.ClearWorkflowStepID()
		return nil
	case workflowdata.FieldWorkflowFrom:
		m.ClearWorkflowFrom()
		return nil
	case workflowdata.FieldWorkflowExecutionFrom:
		m.ClearWorkflowExecutionFrom()
		return nil
	}
	return fmt.Errorf("unknown WorkflowData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowDataMutation) ResetField(name string) error {
	switch name {
	case workflowdata.FieldEntityID:
		m.ResetEntityID()
		return nil
	case workflowdata.FieldDuration:
		m.ResetDuration()
		return nil
	case workflowdata.FieldPaused:
		m.ResetPaused()
		return nil
	case workflowdata.FieldResumable:
		m.ResetResumable()
		return nil
	case workflowdata.FieldIsRoot:
		m.ResetIsRoot()
		return nil
	case workflowdata.FieldInputs:
		m.ResetInputs()
		return nil
	case workflowdata.FieldContinuedFrom:
		m.ResetContinuedFrom()
		return nil
	case workflowdata.FieldContinuedExecutionFrom:
		m.ResetContinuedExecutionFrom()
		return nil
	case workflowdata.FieldWorkflowStepID:
		m.ResetWorkflowStepID()
		return nil
	case workflowdata.FieldWorkflowFrom:
		m.ResetWorkflowFrom()
		return nil
	case workflowdata.FieldWorkflowExecutionFrom:
		m.ResetWorkflowExecutionFrom()
		return nil
	case workflowdata.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workflowdata.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown WorkflowData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.workflow != nil {
		edges = append(edges, workflowdata.EdgeWorkflow)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workflowdata.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowDataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedworkflow {
		edges = append(edges, workflowdata.EdgeWorkflow)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowDataMutation) EdgeCleared(name string) bool {
	switch name {
	case workflowdata.EdgeWorkflow:
		return m.clearedworkflow
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowDataMutation) ClearEdge(name string) error {
	switch name {
	case workflowdata.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	}
	return fmt.Errorf("unknown WorkflowData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowDataMutation) ResetEdge(name string) error {
	switch name {
	case workflowdata.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	}
	return fmt.Errorf("unknown WorkflowData edge %s", name)
}

// WorkflowEntityMutation represents an operation that mutates the WorkflowEntity nodes in the graph.
type WorkflowEntityMutation struct {
	config
	op                          Op
	typ                         string
	id                          *schema.WorkflowEntityID
	handler_name                *string
	_type                       *schema.EntityType
	status                      *schema.EntityStatus
	step_id                     *schema.WorkflowStepID
	retry_policy                *schema.RetryPolicy
	retry_state                 *schema.RetryState
	created_at                  *time.Time
	updated_at                  *time.Time
	clearedFields               map[string]struct{}
	queue                       *schema.QueueID
	clearedqueue                bool
	run                         *schema.RunID
	clearedrun                  bool
	versions                    map[schema.VersionID]struct{}
	removedversions             map[schema.VersionID]struct{}
	clearedversions             bool
	workflow_data               *schema.WorkflowDataID
	clearedworkflow_data        bool
	activity_children           map[schema.ActivityEntityID]struct{}
	removedactivity_children    map[schema.ActivityEntityID]struct{}
	clearedactivity_children    bool
	saga_children               map[schema.SagaEntityID]struct{}
	removedsaga_children        map[schema.SagaEntityID]struct{}
	clearedsaga_children        bool
	side_effect_children        map[schema.SideEffectEntityID]struct{}
	removedside_effect_children map[schema.SideEffectEntityID]struct{}
	clearedside_effect_children bool
	executions                  map[schema.WorkflowExecutionID]struct{}
	removedexecutions           map[schema.WorkflowExecutionID]struct{}
	clearedexecutions           bool
	done                        bool
	oldValue                    func(context.Context) (*WorkflowEntity, error)
	predicates                  []predicate.WorkflowEntity
}

var _ ent.Mutation = (*WorkflowEntityMutation)(nil)

// workflowentityOption allows management of the mutation configuration using functional options.
type workflowentityOption func(*WorkflowEntityMutation)

// newWorkflowEntityMutation creates new mutation for the WorkflowEntity entity.
func newWorkflowEntityMutation(c config, op Op, opts ...workflowentityOption) *WorkflowEntityMutation {
	m := &WorkflowEntityMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflowEntity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowEntityID sets the ID field of the mutation.
func withWorkflowEntityID(id schema.WorkflowEntityID) workflowentityOption {
	return func(m *WorkflowEntityMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkflowEntity
		)
		m.oldValue = func(ctx context.Context) (*WorkflowEntity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkflowEntity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflowEntity sets the old WorkflowEntity of the mutation.
func withWorkflowEntity(node *WorkflowEntity) workflowentityOption {
	return func(m *WorkflowEntityMutation) {
		m.oldValue = func(context.Context) (*WorkflowEntity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowEntityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowEntityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkflowEntity entities.
func (m *WorkflowEntityMutation) SetID(id schema.WorkflowEntityID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowEntityMutation) ID() (id schema.WorkflowEntityID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowEntityMutation) IDs(ctx context.Context) ([]schema.WorkflowEntityID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []schema.WorkflowEntityID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkflowEntity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHandlerName sets the "handler_name" field.
func (m *WorkflowEntityMutation) SetHandlerName(s string) {
	m.handler_name = &s
}

// HandlerName returns the value of the "handler_name" field in the mutation.
func (m *WorkflowEntityMutation) HandlerName() (r string, exists bool) {
	v := m.handler_name
	if v == nil {
		return
	}
	return *v, true
}

// OldHandlerName returns the old "handler_name" field's value of the WorkflowEntity entity.
// If the WorkflowEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowEntityMutation) OldHandlerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandlerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandlerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandlerName: %w", err)
	}
	return oldValue.HandlerName, nil
}

// ResetHandlerName resets all changes to the "handler_name" field.
func (m *WorkflowEntityMutation) ResetHandlerName() {
	m.handler_name = nil
}

// SetType sets the "type" field.
func (m *WorkflowEntityMutation) SetType(st schema.EntityType) {
	m._type = &st
}

// GetType returns the value of the "type" field in the mutation.
func (m *WorkflowEntityMutation) GetType() (r schema.EntityType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the WorkflowEntity entity.
// If the WorkflowEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowEntityMutation) OldType(ctx context.Context) (v schema.EntityType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *WorkflowEntityMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *WorkflowEntityMutation) SetStatus(ss schema.EntityStatus) {
	m.status = &ss
}

// Status returns the value of the "status" field in the mutation.
func (m *WorkflowEntityMutation) Status() (r schema.EntityStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the WorkflowEntity entity.
// If the WorkflowEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowEntityMutation) OldStatus(ctx context.Context) (v schema.EntityStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *WorkflowEntityMutation) ResetStatus() {
	m.status = nil
}

// SetStepID sets the "step_id" field.
func (m *WorkflowEntityMutation) SetStepID(ssi schema.WorkflowStepID) {
	m.step_id = &ssi
}

// StepID returns the value of the "step_id" field in the mutation.
func (m *WorkflowEntityMutation) StepID() (r schema.WorkflowStepID, exists bool) {
	v := m.step_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStepID returns the old "step_id" field's value of the WorkflowEntity entity.
// If the WorkflowEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowEntityMutation) OldStepID(ctx context.Context) (v schema.WorkflowStepID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStepID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStepID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStepID: %w", err)
	}
	return oldValue.StepID, nil
}

// ResetStepID resets all changes to the "step_id" field.
func (m *WorkflowEntityMutation) ResetStepID() {
	m.step_id = nil
}

// SetRunID sets the "run_id" field.
func (m *WorkflowEntityMutation) SetRunID(si schema.RunID) {
	m.run = &si
}

// RunID returns the value of the "run_id" field in the mutation.
func (m *WorkflowEntityMutation) RunID() (r schema.RunID, exists bool) {
	v := m.run
	if v == nil {
		return
	}
	return *v, true
}

// OldRunID returns the old "run_id" field's value of the WorkflowEntity entity.
// If the WorkflowEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowEntityMutation) OldRunID(ctx context.Context) (v schema.RunID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunID: %w", err)
	}
	return oldValue.RunID, nil
}

// ResetRunID resets all changes to the "run_id" field.
func (m *WorkflowEntityMutation) ResetRunID() {
	m.run = nil
}

// SetRetryPolicy sets the "retry_policy" field.
func (m *WorkflowEntityMutation) SetRetryPolicy(sp schema.RetryPolicy) {
	m.retry_policy = &sp
}

// RetryPolicy returns the value of the "retry_policy" field in the mutation.
func (m *WorkflowEntityMutation) RetryPolicy() (r schema.RetryPolicy, exists bool) {
	v := m.retry_policy
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryPolicy returns the old "retry_policy" field's value of the WorkflowEntity entity.
// If the WorkflowEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowEntityMutation) OldRetryPolicy(ctx context.Context) (v schema.RetryPolicy, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryPolicy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryPolicy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryPolicy: %w", err)
	}
	return oldValue.RetryPolicy, nil
}

// ResetRetryPolicy resets all changes to the "retry_policy" field.
func (m *WorkflowEntityMutation) ResetRetryPolicy() {
	m.retry_policy = nil
}

// SetRetryState sets the "retry_state" field.
func (m *WorkflowEntityMutation) SetRetryState(ss schema.RetryState) {
	m.retry_state = &ss
}

// RetryState returns the value of the "retry_state" field in the mutation.
func (m *WorkflowEntityMutation) RetryState() (r schema.RetryState, exists bool) {
	v := m.retry_state
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryState returns the old "retry_state" field's value of the WorkflowEntity entity.
// If the WorkflowEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowEntityMutation) OldRetryState(ctx context.Context) (v schema.RetryState, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryState: %w", err)
	}
	return oldValue.RetryState, nil
}

// ResetRetryState resets all changes to the "retry_state" field.
func (m *WorkflowEntityMutation) ResetRetryState() {
	m.retry_state = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkflowEntityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkflowEntityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WorkflowEntity entity.
// If the WorkflowEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowEntityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkflowEntityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkflowEntityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkflowEntityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WorkflowEntity entity.
// If the WorkflowEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowEntityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkflowEntityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetQueueID sets the "queue" edge to the Queue entity by id.
func (m *WorkflowEntityMutation) SetQueueID(id schema.QueueID) {
	m.queue = &id
}

// ClearQueue clears the "queue" edge to the Queue entity.
func (m *WorkflowEntityMutation) ClearQueue() {
	m.clearedqueue = true
}

// QueueCleared reports if the "queue" edge to the Queue entity was cleared.
func (m *WorkflowEntityMutation) QueueCleared() bool {
	return m.clearedqueue
}

// QueueID returns the "queue" edge ID in the mutation.
func (m *WorkflowEntityMutation) QueueID() (id schema.QueueID, exists bool) {
	if m.queue != nil {
		return *m.queue, true
	}
	return
}

// QueueIDs returns the "queue" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// QueueID instead. It exists only for internal usage by the builders.
func (m *WorkflowEntityMutation) QueueIDs() (ids []schema.QueueID) {
	if id := m.queue; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetQueue resets all changes to the "queue" edge.
func (m *WorkflowEntityMutation) ResetQueue() {
	m.queue = nil
	m.clearedqueue = false
}

// ClearRun clears the "run" edge to the Run entity.
func (m *WorkflowEntityMutation) ClearRun() {
	m.clearedrun = true
	m.clearedFields[workflowentity.FieldRunID] = struct{}{}
}

// RunCleared reports if the "run" edge to the Run entity was cleared.
func (m *WorkflowEntityMutation) RunCleared() bool {
	return m.clearedrun
}

// RunIDs returns the "run" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RunID instead. It exists only for internal usage by the builders.
func (m *WorkflowEntityMutation) RunIDs() (ids []schema.RunID) {
	if id := m.run; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRun resets all changes to the "run" edge.
func (m *WorkflowEntityMutation) ResetRun() {
	m.run = nil
	m.clearedrun = false
}

// AddVersionIDs adds the "versions" edge to the Version entity by ids.
func (m *WorkflowEntityMutation) AddVersionIDs(ids ...schema.VersionID) {
	if m.versions == nil {
		m.versions = make(map[schema.VersionID]struct{})
	}
	for i := range ids {
		m.versions[ids[i]] = struct{}{}
	}
}

// ClearVersions clears the "versions" edge to the Version entity.
func (m *WorkflowEntityMutation) ClearVersions() {
	m.clearedversions = true
}

// VersionsCleared reports if the "versions" edge to the Version entity was cleared.
func (m *WorkflowEntityMutation) VersionsCleared() bool {
	return m.clearedversions
}

// RemoveVersionIDs removes the "versions" edge to the Version entity by IDs.
func (m *WorkflowEntityMutation) RemoveVersionIDs(ids ...schema.VersionID) {
	if m.removedversions == nil {
		m.removedversions = make(map[schema.VersionID]struct{})
	}
	for i := range ids {
		delete(m.versions, ids[i])
		m.removedversions[ids[i]] = struct{}{}
	}
}

// RemovedVersions returns the removed IDs of the "versions" edge to the Version entity.
func (m *WorkflowEntityMutation) RemovedVersionsIDs() (ids []schema.VersionID) {
	for id := range m.removedversions {
		ids = append(ids, id)
	}
	return
}

// VersionsIDs returns the "versions" edge IDs in the mutation.
func (m *WorkflowEntityMutation) VersionsIDs() (ids []schema.VersionID) {
	for id := range m.versions {
		ids = append(ids, id)
	}
	return
}

// ResetVersions resets all changes to the "versions" edge.
func (m *WorkflowEntityMutation) ResetVersions() {
	m.versions = nil
	m.clearedversions = false
	m.removedversions = nil
}

// SetWorkflowDataID sets the "workflow_data" edge to the WorkflowData entity by id.
func (m *WorkflowEntityMutation) SetWorkflowDataID(id schema.WorkflowDataID) {
	m.workflow_data = &id
}

// ClearWorkflowData clears the "workflow_data" edge to the WorkflowData entity.
func (m *WorkflowEntityMutation) ClearWorkflowData() {
	m.clearedworkflow_data = true
}

// WorkflowDataCleared reports if the "workflow_data" edge to the WorkflowData entity was cleared.
func (m *WorkflowEntityMutation) WorkflowDataCleared() bool {
	return m.clearedworkflow_data
}

// WorkflowDataID returns the "workflow_data" edge ID in the mutation.
func (m *WorkflowEntityMutation) WorkflowDataID() (id schema.WorkflowDataID, exists bool) {
	if m.workflow_data != nil {
		return *m.workflow_data, true
	}
	return
}

// WorkflowDataIDs returns the "workflow_data" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowDataID instead. It exists only for internal usage by the builders.
func (m *WorkflowEntityMutation) WorkflowDataIDs() (ids []schema.WorkflowDataID) {
	if id := m.workflow_data; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflowData resets all changes to the "workflow_data" edge.
func (m *WorkflowEntityMutation) ResetWorkflowData() {
	m.workflow_data = nil
	m.clearedworkflow_data = false
}

// AddActivityChildIDs adds the "activity_children" edge to the ActivityEntity entity by ids.
func (m *WorkflowEntityMutation) AddActivityChildIDs(ids ...schema.ActivityEntityID) {
	if m.activity_children == nil {
		m.activity_children = make(map[schema.ActivityEntityID]struct{})
	}
	for i := range ids {
		m.activity_children[ids[i]] = struct{}{}
	}
}

// ClearActivityChildren clears the "activity_children" edge to the ActivityEntity entity.
func (m *WorkflowEntityMutation) ClearActivityChildren() {
	m.clearedactivity_children = true
}

// ActivityChildrenCleared reports if the "activity_children" edge to the ActivityEntity entity was cleared.
func (m *WorkflowEntityMutation) ActivityChildrenCleared() bool {
	return m.clearedactivity_children
}

// RemoveActivityChildIDs removes the "activity_children" edge to the ActivityEntity entity by IDs.
func (m *WorkflowEntityMutation) RemoveActivityChildIDs(ids ...schema.ActivityEntityID) {
	if m.removedactivity_children == nil {
		m.removedactivity_children = make(map[schema.ActivityEntityID]struct{})
	}
	for i := range ids {
		delete(m.activity_children, ids[i])
		m.removedactivity_children[ids[i]] = struct{}{}
	}
}

// RemovedActivityChildren returns the removed IDs of the "activity_children" edge to the ActivityEntity entity.
func (m *WorkflowEntityMutation) RemovedActivityChildrenIDs() (ids []schema.ActivityEntityID) {
	for id := range m.removedactivity_children {
		ids = append(ids, id)
	}
	return
}

// ActivityChildrenIDs returns the "activity_children" edge IDs in the mutation.
func (m *WorkflowEntityMutation) ActivityChildrenIDs() (ids []schema.ActivityEntityID) {
	for id := range m.activity_children {
		ids = append(ids, id)
	}
	return
}

// ResetActivityChildren resets all changes to the "activity_children" edge.
func (m *WorkflowEntityMutation) ResetActivityChildren() {
	m.activity_children = nil
	m.clearedactivity_children = false
	m.removedactivity_children = nil
}

// AddSagaChildIDs adds the "saga_children" edge to the SagaEntity entity by ids.
func (m *WorkflowEntityMutation) AddSagaChildIDs(ids ...schema.SagaEntityID) {
	if m.saga_children == nil {
		m.saga_children = make(map[schema.SagaEntityID]struct{})
	}
	for i := range ids {
		m.saga_children[ids[i]] = struct{}{}
	}
}

// ClearSagaChildren clears the "saga_children" edge to the SagaEntity entity.
func (m *WorkflowEntityMutation) ClearSagaChildren() {
	m.clearedsaga_children = true
}

// SagaChildrenCleared reports if the "saga_children" edge to the SagaEntity entity was cleared.
func (m *WorkflowEntityMutation) SagaChildrenCleared() bool {
	return m.clearedsaga_children
}

// RemoveSagaChildIDs removes the "saga_children" edge to the SagaEntity entity by IDs.
func (m *WorkflowEntityMutation) RemoveSagaChildIDs(ids ...schema.SagaEntityID) {
	if m.removedsaga_children == nil {
		m.removedsaga_children = make(map[schema.SagaEntityID]struct{})
	}
	for i := range ids {
		delete(m.saga_children, ids[i])
		m.removedsaga_children[ids[i]] = struct{}{}
	}
}

// RemovedSagaChildren returns the removed IDs of the "saga_children" edge to the SagaEntity entity.
func (m *WorkflowEntityMutation) RemovedSagaChildrenIDs() (ids []schema.SagaEntityID) {
	for id := range m.removedsaga_children {
		ids = append(ids, id)
	}
	return
}

// SagaChildrenIDs returns the "saga_children" edge IDs in the mutation.
func (m *WorkflowEntityMutation) SagaChildrenIDs() (ids []schema.SagaEntityID) {
	for id := range m.saga_children {
		ids = append(ids, id)
	}
	return
}

// ResetSagaChildren resets all changes to the "saga_children" edge.
func (m *WorkflowEntityMutation) ResetSagaChildren() {
	m.saga_children = nil
	m.clearedsaga_children = false
	m.removedsaga_children = nil
}

// AddSideEffectChildIDs adds the "side_effect_children" edge to the SideEffectEntity entity by ids.
func (m *WorkflowEntityMutation) AddSideEffectChildIDs(ids ...schema.SideEffectEntityID) {
	if m.side_effect_children == nil {
		m.side_effect_children = make(map[schema.SideEffectEntityID]struct{})
	}
	for i := range ids {
		m.side_effect_children[ids[i]] = struct{}{}
	}
}

// ClearSideEffectChildren clears the "side_effect_children" edge to the SideEffectEntity entity.
func (m *WorkflowEntityMutation) ClearSideEffectChildren() {
	m.clearedside_effect_children = true
}

// SideEffectChildrenCleared reports if the "side_effect_children" edge to the SideEffectEntity entity was cleared.
func (m *WorkflowEntityMutation) SideEffectChildrenCleared() bool {
	return m.clearedside_effect_children
}

// RemoveSideEffectChildIDs removes the "side_effect_children" edge to the SideEffectEntity entity by IDs.
func (m *WorkflowEntityMutation) RemoveSideEffectChildIDs(ids ...schema.SideEffectEntityID) {
	if m.removedside_effect_children == nil {
		m.removedside_effect_children = make(map[schema.SideEffectEntityID]struct{})
	}
	for i := range ids {
		delete(m.side_effect_children, ids[i])
		m.removedside_effect_children[ids[i]] = struct{}{}
	}
}

// RemovedSideEffectChildren returns the removed IDs of the "side_effect_children" edge to the SideEffectEntity entity.
func (m *WorkflowEntityMutation) RemovedSideEffectChildrenIDs() (ids []schema.SideEffectEntityID) {
	for id := range m.removedside_effect_children {
		ids = append(ids, id)
	}
	return
}

// SideEffectChildrenIDs returns the "side_effect_children" edge IDs in the mutation.
func (m *WorkflowEntityMutation) SideEffectChildrenIDs() (ids []schema.SideEffectEntityID) {
	for id := range m.side_effect_children {
		ids = append(ids, id)
	}
	return
}

// ResetSideEffectChildren resets all changes to the "side_effect_children" edge.
func (m *WorkflowEntityMutation) ResetSideEffectChildren() {
	m.side_effect_children = nil
	m.clearedside_effect_children = false
	m.removedside_effect_children = nil
}

// AddExecutionIDs adds the "executions" edge to the WorkflowExecution entity by ids.
func (m *WorkflowEntityMutation) AddExecutionIDs(ids ...schema.WorkflowExecutionID) {
	if m.executions == nil {
		m.executions = make(map[schema.WorkflowExecutionID]struct{})
	}
	for i := range ids {
		m.executions[ids[i]] = struct{}{}
	}
}

// ClearExecutions clears the "executions" edge to the WorkflowExecution entity.
func (m *WorkflowEntityMutation) ClearExecutions() {
	m.clearedexecutions = true
}

// ExecutionsCleared reports if the "executions" edge to the WorkflowExecution entity was cleared.
func (m *WorkflowEntityMutation) ExecutionsCleared() bool {
	return m.clearedexecutions
}

// RemoveExecutionIDs removes the "executions" edge to the WorkflowExecution entity by IDs.
func (m *WorkflowEntityMutation) RemoveExecutionIDs(ids ...schema.WorkflowExecutionID) {
	if m.removedexecutions == nil {
		m.removedexecutions = make(map[schema.WorkflowExecutionID]struct{})
	}
	for i := range ids {
		delete(m.executions, ids[i])
		m.removedexecutions[ids[i]] = struct{}{}
	}
}

// RemovedExecutions returns the removed IDs of the "executions" edge to the WorkflowExecution entity.
func (m *WorkflowEntityMutation) RemovedExecutionsIDs() (ids []schema.WorkflowExecutionID) {
	for id := range m.removedexecutions {
		ids = append(ids, id)
	}
	return
}

// ExecutionsIDs returns the "executions" edge IDs in the mutation.
func (m *WorkflowEntityMutation) ExecutionsIDs() (ids []schema.WorkflowExecutionID) {
	for id := range m.executions {
		ids = append(ids, id)
	}
	return
}

// ResetExecutions resets all changes to the "executions" edge.
func (m *WorkflowEntityMutation) ResetExecutions() {
	m.executions = nil
	m.clearedexecutions = false
	m.removedexecutions = nil
}

// Where appends a list predicates to the WorkflowEntityMutation builder.
func (m *WorkflowEntityMutation) Where(ps ...predicate.WorkflowEntity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowEntityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowEntityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkflowEntity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowEntityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowEntityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkflowEntity).
func (m *WorkflowEntityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowEntityMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.handler_name != nil {
		fields = append(fields, workflowentity.FieldHandlerName)
	}
	if m._type != nil {
		fields = append(fields, workflowentity.FieldType)
	}
	if m.status != nil {
		fields = append(fields, workflowentity.FieldStatus)
	}
	if m.step_id != nil {
		fields = append(fields, workflowentity.FieldStepID)
	}
	if m.run != nil {
		fields = append(fields, workflowentity.FieldRunID)
	}
	if m.retry_policy != nil {
		fields = append(fields, workflowentity.FieldRetryPolicy)
	}
	if m.retry_state != nil {
		fields = append(fields, workflowentity.FieldRetryState)
	}
	if m.created_at != nil {
		fields = append(fields, workflowentity.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workflowentity.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowEntityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflowentity.FieldHandlerName:
		return m.HandlerName()
	case workflowentity.FieldType:
		return m.GetType()
	case workflowentity.FieldStatus:
		return m.Status()
	case workflowentity.FieldStepID:
		return m.StepID()
	case workflowentity.FieldRunID:
		return m.RunID()
	case workflowentity.FieldRetryPolicy:
		return m.RetryPolicy()
	case workflowentity.FieldRetryState:
		return m.RetryState()
	case workflowentity.FieldCreatedAt:
		return m.CreatedAt()
	case workflowentity.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowEntityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflowentity.FieldHandlerName:
		return m.OldHandlerName(ctx)
	case workflowentity.FieldType:
		return m.OldType(ctx)
	case workflowentity.FieldStatus:
		return m.OldStatus(ctx)
	case workflowentity.FieldStepID:
		return m.OldStepID(ctx)
	case workflowentity.FieldRunID:
		return m.OldRunID(ctx)
	case workflowentity.FieldRetryPolicy:
		return m.OldRetryPolicy(ctx)
	case workflowentity.FieldRetryState:
		return m.OldRetryState(ctx)
	case workflowentity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workflowentity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown WorkflowEntity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowEntityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflowentity.FieldHandlerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandlerName(v)
		return nil
	case workflowentity.FieldType:
		v, ok := value.(schema.EntityType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case workflowentity.FieldStatus:
		v, ok := value.(schema.EntityStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case workflowentity.FieldStepID:
		v, ok := value.(schema.WorkflowStepID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStepID(v)
		return nil
	case workflowentity.FieldRunID:
		v, ok := value.(schema.RunID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunID(v)
		return nil
	case workflowentity.FieldRetryPolicy:
		v, ok := value.(schema.RetryPolicy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryPolicy(v)
		return nil
	case workflowentity.FieldRetryState:
		v, ok := value.(schema.RetryState)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryState(v)
		return nil
	case workflowentity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workflowentity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowEntity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowEntityMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowEntityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowEntityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkflowEntity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowEntityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowEntityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowEntityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WorkflowEntity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowEntityMutation) ResetField(name string) error {
	switch name {
	case workflowentity.FieldHandlerName:
		m.ResetHandlerName()
		return nil
	case workflowentity.FieldType:
		m.ResetType()
		return nil
	case workflowentity.FieldStatus:
		m.ResetStatus()
		return nil
	case workflowentity.FieldStepID:
		m.ResetStepID()
		return nil
	case workflowentity.FieldRunID:
		m.ResetRunID()
		return nil
	case workflowentity.FieldRetryPolicy:
		m.ResetRetryPolicy()
		return nil
	case workflowentity.FieldRetryState:
		m.ResetRetryState()
		return nil
	case workflowentity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workflowentity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown WorkflowEntity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowEntityMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.queue != nil {
		edges = append(edges, workflowentity.EdgeQueue)
	}
	if m.run != nil {
		edges = append(edges, workflowentity.EdgeRun)
	}
	if m.versions != nil {
		edges = append(edges, workflowentity.EdgeVersions)
	}
	if m.workflow_data != nil {
		edges = append(edges, workflowentity.EdgeWorkflowData)
	}
	if m.activity_children != nil {
		edges = append(edges, workflowentity.EdgeActivityChildren)
	}
	if m.saga_children != nil {
		edges = append(edges, workflowentity.EdgeSagaChildren)
	}
	if m.side_effect_children != nil {
		edges = append(edges, workflowentity.EdgeSideEffectChildren)
	}
	if m.executions != nil {
		edges = append(edges, workflowentity.EdgeExecutions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowEntityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workflowentity.EdgeQueue:
		if id := m.queue; id != nil {
			return []ent.Value{*id}
		}
	case workflowentity.EdgeRun:
		if id := m.run; id != nil {
			return []ent.Value{*id}
		}
	case workflowentity.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.versions))
		for id := range m.versions {
			ids = append(ids, id)
		}
		return ids
	case workflowentity.EdgeWorkflowData:
		if id := m.workflow_data; id != nil {
			return []ent.Value{*id}
		}
	case workflowentity.EdgeActivityChildren:
		ids := make([]ent.Value, 0, len(m.activity_children))
		for id := range m.activity_children {
			ids = append(ids, id)
		}
		return ids
	case workflowentity.EdgeSagaChildren:
		ids := make([]ent.Value, 0, len(m.saga_children))
		for id := range m.saga_children {
			ids = append(ids, id)
		}
		return ids
	case workflowentity.EdgeSideEffectChildren:
		ids := make([]ent.Value, 0, len(m.side_effect_children))
		for id := range m.side_effect_children {
			ids = append(ids, id)
		}
		return ids
	case workflowentity.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.executions))
		for id := range m.executions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowEntityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedversions != nil {
		edges = append(edges, workflowentity.EdgeVersions)
	}
	if m.removedactivity_children != nil {
		edges = append(edges, workflowentity.EdgeActivityChildren)
	}
	if m.removedsaga_children != nil {
		edges = append(edges, workflowentity.EdgeSagaChildren)
	}
	if m.removedside_effect_children != nil {
		edges = append(edges, workflowentity.EdgeSideEffectChildren)
	}
	if m.removedexecutions != nil {
		edges = append(edges, workflowentity.EdgeExecutions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowEntityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workflowentity.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.removedversions))
		for id := range m.removedversions {
			ids = append(ids, id)
		}
		return ids
	case workflowentity.EdgeActivityChildren:
		ids := make([]ent.Value, 0, len(m.removedactivity_children))
		for id := range m.removedactivity_children {
			ids = append(ids, id)
		}
		return ids
	case workflowentity.EdgeSagaChildren:
		ids := make([]ent.Value, 0, len(m.removedsaga_children))
		for id := range m.removedsaga_children {
			ids = append(ids, id)
		}
		return ids
	case workflowentity.EdgeSideEffectChildren:
		ids := make([]ent.Value, 0, len(m.removedside_effect_children))
		for id := range m.removedside_effect_children {
			ids = append(ids, id)
		}
		return ids
	case workflowentity.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.removedexecutions))
		for id := range m.removedexecutions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowEntityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedqueue {
		edges = append(edges, workflowentity.EdgeQueue)
	}
	if m.clearedrun {
		edges = append(edges, workflowentity.EdgeRun)
	}
	if m.clearedversions {
		edges = append(edges, workflowentity.EdgeVersions)
	}
	if m.clearedworkflow_data {
		edges = append(edges, workflowentity.EdgeWorkflowData)
	}
	if m.clearedactivity_children {
		edges = append(edges, workflowentity.EdgeActivityChildren)
	}
	if m.clearedsaga_children {
		edges = append(edges, workflowentity.EdgeSagaChildren)
	}
	if m.clearedside_effect_children {
		edges = append(edges, workflowentity.EdgeSideEffectChildren)
	}
	if m.clearedexecutions {
		edges = append(edges, workflowentity.EdgeExecutions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowEntityMutation) EdgeCleared(name string) bool {
	switch name {
	case workflowentity.EdgeQueue:
		return m.clearedqueue
	case workflowentity.EdgeRun:
		return m.clearedrun
	case workflowentity.EdgeVersions:
		return m.clearedversions
	case workflowentity.EdgeWorkflowData:
		return m.clearedworkflow_data
	case workflowentity.EdgeActivityChildren:
		return m.clearedactivity_children
	case workflowentity.EdgeSagaChildren:
		return m.clearedsaga_children
	case workflowentity.EdgeSideEffectChildren:
		return m.clearedside_effect_children
	case workflowentity.EdgeExecutions:
		return m.clearedexecutions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowEntityMutation) ClearEdge(name string) error {
	switch name {
	case workflowentity.EdgeQueue:
		m.ClearQueue()
		return nil
	case workflowentity.EdgeRun:
		m.ClearRun()
		return nil
	case workflowentity.EdgeWorkflowData:
		m.ClearWorkflowData()
		return nil
	}
	return fmt.Errorf("unknown WorkflowEntity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowEntityMutation) ResetEdge(name string) error {
	switch name {
	case workflowentity.EdgeQueue:
		m.ResetQueue()
		return nil
	case workflowentity.EdgeRun:
		m.ResetRun()
		return nil
	case workflowentity.EdgeVersions:
		m.ResetVersions()
		return nil
	case workflowentity.EdgeWorkflowData:
		m.ResetWorkflowData()
		return nil
	case workflowentity.EdgeActivityChildren:
		m.ResetActivityChildren()
		return nil
	case workflowentity.EdgeSagaChildren:
		m.ResetSagaChildren()
		return nil
	case workflowentity.EdgeSideEffectChildren:
		m.ResetSideEffectChildren()
		return nil
	case workflowentity.EdgeExecutions:
		m.ResetExecutions()
		return nil
	}
	return fmt.Errorf("unknown WorkflowEntity edge %s", name)
}

// WorkflowExecutionMutation represents an operation that mutates the WorkflowExecution nodes in the graph.
type WorkflowExecutionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *schema.WorkflowExecutionID
	started_at            *time.Time
	completed_at          *time.Time
	status                *schema.ExecutionStatus
	error                 *string
	stack_trace           *string
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	workflow              *schema.WorkflowEntityID
	clearedworkflow       bool
	execution_data        *schema.WorkflowExecutionDataID
	clearedexecution_data bool
	done                  bool
	oldValue              func(context.Context) (*WorkflowExecution, error)
	predicates            []predicate.WorkflowExecution
}

var _ ent.Mutation = (*WorkflowExecutionMutation)(nil)

// workflowexecutionOption allows management of the mutation configuration using functional options.
type workflowexecutionOption func(*WorkflowExecutionMutation)

// newWorkflowExecutionMutation creates new mutation for the WorkflowExecution entity.
func newWorkflowExecutionMutation(c config, op Op, opts ...workflowexecutionOption) *WorkflowExecutionMutation {
	m := &WorkflowExecutionMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflowExecution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowExecutionID sets the ID field of the mutation.
func withWorkflowExecutionID(id schema.WorkflowExecutionID) workflowexecutionOption {
	return func(m *WorkflowExecutionMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkflowExecution
		)
		m.oldValue = func(ctx context.Context) (*WorkflowExecution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkflowExecution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflowExecution sets the old WorkflowExecution of the mutation.
func withWorkflowExecution(node *WorkflowExecution) workflowexecutionOption {
	return func(m *WorkflowExecutionMutation) {
		m.oldValue = func(context.Context) (*WorkflowExecution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowExecutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowExecutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkflowExecution entities.
func (m *WorkflowExecutionMutation) SetID(id schema.WorkflowExecutionID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowExecutionMutation) ID() (id schema.WorkflowExecutionID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowExecutionMutation) IDs(ctx context.Context) ([]schema.WorkflowExecutionID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []schema.WorkflowExecutionID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkflowExecution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWorkflowEntityID sets the "workflow_entity_id" field.
func (m *WorkflowExecutionMutation) SetWorkflowEntityID(sei schema.WorkflowEntityID) {
	m.workflow = &sei
}

// WorkflowEntityID returns the value of the "workflow_entity_id" field in the mutation.
func (m *WorkflowExecutionMutation) WorkflowEntityID() (r schema.WorkflowEntityID, exists bool) {
	v := m.workflow
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowEntityID returns the old "workflow_entity_id" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldWorkflowEntityID(ctx context.Context) (v schema.WorkflowEntityID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowEntityID: %w", err)
	}
	return oldValue.WorkflowEntityID, nil
}

// ResetWorkflowEntityID resets all changes to the "workflow_entity_id" field.
func (m *WorkflowExecutionMutation) ResetWorkflowEntityID() {
	m.workflow = nil
}

// SetStartedAt sets the "started_at" field.
func (m *WorkflowExecutionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *WorkflowExecutionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *WorkflowExecutionMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetCompletedAt sets the "completed_at" field.
func (m *WorkflowExecutionMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *WorkflowExecutionMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *WorkflowExecutionMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[workflowexecution.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *WorkflowExecutionMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[workflowexecution.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *WorkflowExecutionMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, workflowexecution.FieldCompletedAt)
}

// SetStatus sets the "status" field.
func (m *WorkflowExecutionMutation) SetStatus(ss schema.ExecutionStatus) {
	m.status = &ss
}

// Status returns the value of the "status" field in the mutation.
func (m *WorkflowExecutionMutation) Status() (r schema.ExecutionStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldStatus(ctx context.Context) (v schema.ExecutionStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *WorkflowExecutionMutation) ResetStatus() {
	m.status = nil
}

// SetError sets the "error" field.
func (m *WorkflowExecutionMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *WorkflowExecutionMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *WorkflowExecutionMutation) ClearError() {
	m.error = nil
	m.clearedFields[workflowexecution.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *WorkflowExecutionMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[workflowexecution.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *WorkflowExecutionMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, workflowexecution.FieldError)
}

// SetStackTrace sets the "stack_trace" field.
func (m *WorkflowExecutionMutation) SetStackTrace(s string) {
	m.stack_trace = &s
}

// StackTrace returns the value of the "stack_trace" field in the mutation.
func (m *WorkflowExecutionMutation) StackTrace() (r string, exists bool) {
	v := m.stack_trace
	if v == nil {
		return
	}
	return *v, true
}

// OldStackTrace returns the old "stack_trace" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldStackTrace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStackTrace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStackTrace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStackTrace: %w", err)
	}
	return oldValue.StackTrace, nil
}

// ClearStackTrace clears the value of the "stack_trace" field.
func (m *WorkflowExecutionMutation) ClearStackTrace() {
	m.stack_trace = nil
	m.clearedFields[workflowexecution.FieldStackTrace] = struct{}{}
}

// StackTraceCleared returns if the "stack_trace" field was cleared in this mutation.
func (m *WorkflowExecutionMutation) StackTraceCleared() bool {
	_, ok := m.clearedFields[workflowexecution.FieldStackTrace]
	return ok
}

// ResetStackTrace resets all changes to the "stack_trace" field.
func (m *WorkflowExecutionMutation) ResetStackTrace() {
	m.stack_trace = nil
	delete(m.clearedFields, workflowexecution.FieldStackTrace)
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkflowExecutionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkflowExecutionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkflowExecutionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkflowExecutionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkflowExecutionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkflowExecutionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetWorkflowID sets the "workflow" edge to the WorkflowEntity entity by id.
func (m *WorkflowExecutionMutation) SetWorkflowID(id schema.WorkflowEntityID) {
	m.workflow = &id
}

// ClearWorkflow clears the "workflow" edge to the WorkflowEntity entity.
func (m *WorkflowExecutionMutation) ClearWorkflow() {
	m.clearedworkflow = true
	m.clearedFields[workflowexecution.FieldWorkflowEntityID] = struct{}{}
}

// WorkflowCleared reports if the "workflow" edge to the WorkflowEntity entity was cleared.
func (m *WorkflowExecutionMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowID returns the "workflow" edge ID in the mutation.
func (m *WorkflowExecutionMutation) WorkflowID() (id schema.WorkflowEntityID, exists bool) {
	if m.workflow != nil {
		return *m.workflow, true
	}
	return
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *WorkflowExecutionMutation) WorkflowIDs() (ids []schema.WorkflowEntityID) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *WorkflowExecutionMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// SetExecutionDataID sets the "execution_data" edge to the WorkflowExecutionData entity by id.
func (m *WorkflowExecutionMutation) SetExecutionDataID(id schema.WorkflowExecutionDataID) {
	m.execution_data = &id
}

// ClearExecutionData clears the "execution_data" edge to the WorkflowExecutionData entity.
func (m *WorkflowExecutionMutation) ClearExecutionData() {
	m.clearedexecution_data = true
}

// ExecutionDataCleared reports if the "execution_data" edge to the WorkflowExecutionData entity was cleared.
func (m *WorkflowExecutionMutation) ExecutionDataCleared() bool {
	return m.clearedexecution_data
}

// ExecutionDataID returns the "execution_data" edge ID in the mutation.
func (m *WorkflowExecutionMutation) ExecutionDataID() (id schema.WorkflowExecutionDataID, exists bool) {
	if m.execution_data != nil {
		return *m.execution_data, true
	}
	return
}

// ExecutionDataIDs returns the "execution_data" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExecutionDataID instead. It exists only for internal usage by the builders.
func (m *WorkflowExecutionMutation) ExecutionDataIDs() (ids []schema.WorkflowExecutionDataID) {
	if id := m.execution_data; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExecutionData resets all changes to the "execution_data" edge.
func (m *WorkflowExecutionMutation) ResetExecutionData() {
	m.execution_data = nil
	m.clearedexecution_data = false
}

// Where appends a list predicates to the WorkflowExecutionMutation builder.
func (m *WorkflowExecutionMutation) Where(ps ...predicate.WorkflowExecution) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowExecutionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowExecutionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkflowExecution, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowExecutionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowExecutionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkflowExecution).
func (m *WorkflowExecutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowExecutionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.workflow != nil {
		fields = append(fields, workflowexecution.FieldWorkflowEntityID)
	}
	if m.started_at != nil {
		fields = append(fields, workflowexecution.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, workflowexecution.FieldCompletedAt)
	}
	if m.status != nil {
		fields = append(fields, workflowexecution.FieldStatus)
	}
	if m.error != nil {
		fields = append(fields, workflowexecution.FieldError)
	}
	if m.stack_trace != nil {
		fields = append(fields, workflowexecution.FieldStackTrace)
	}
	if m.created_at != nil {
		fields = append(fields, workflowexecution.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workflowexecution.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowExecutionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflowexecution.FieldWorkflowEntityID:
		return m.WorkflowEntityID()
	case workflowexecution.FieldStartedAt:
		return m.StartedAt()
	case workflowexecution.FieldCompletedAt:
		return m.CompletedAt()
	case workflowexecution.FieldStatus:
		return m.Status()
	case workflowexecution.FieldError:
		return m.Error()
	case workflowexecution.FieldStackTrace:
		return m.StackTrace()
	case workflowexecution.FieldCreatedAt:
		return m.CreatedAt()
	case workflowexecution.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowExecutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflowexecution.FieldWorkflowEntityID:
		return m.OldWorkflowEntityID(ctx)
	case workflowexecution.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case workflowexecution.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case workflowexecution.FieldStatus:
		return m.OldStatus(ctx)
	case workflowexecution.FieldError:
		return m.OldError(ctx)
	case workflowexecution.FieldStackTrace:
		return m.OldStackTrace(ctx)
	case workflowexecution.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workflowexecution.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown WorkflowExecution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowExecutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflowexecution.FieldWorkflowEntityID:
		v, ok := value.(schema.WorkflowEntityID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowEntityID(v)
		return nil
	case workflowexecution.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case workflowexecution.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case workflowexecution.FieldStatus:
		v, ok := value.(schema.ExecutionStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case workflowexecution.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case workflowexecution.FieldStackTrace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStackTrace(v)
		return nil
	case workflowexecution.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workflowexecution.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowExecutionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowExecutionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowExecutionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkflowExecution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowExecutionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflowexecution.FieldCompletedAt) {
		fields = append(fields, workflowexecution.FieldCompletedAt)
	}
	if m.FieldCleared(workflowexecution.FieldError) {
		fields = append(fields, workflowexecution.FieldError)
	}
	if m.FieldCleared(workflowexecution.FieldStackTrace) {
		fields = append(fields, workflowexecution.FieldStackTrace)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowExecutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowExecutionMutation) ClearField(name string) error {
	switch name {
	case workflowexecution.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	case workflowexecution.FieldError:
		m.ClearError()
		return nil
	case workflowexecution.FieldStackTrace:
		m.ClearStackTrace()
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowExecutionMutation) ResetField(name string) error {
	switch name {
	case workflowexecution.FieldWorkflowEntityID:
		m.ResetWorkflowEntityID()
		return nil
	case workflowexecution.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case workflowexecution.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case workflowexecution.FieldStatus:
		m.ResetStatus()
		return nil
	case workflowexecution.FieldError:
		m.ResetError()
		return nil
	case workflowexecution.FieldStackTrace:
		m.ResetStackTrace()
		return nil
	case workflowexecution.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workflowexecution.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowExecutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.workflow != nil {
		edges = append(edges, workflowexecution.EdgeWorkflow)
	}
	if m.execution_data != nil {
		edges = append(edges, workflowexecution.EdgeExecutionData)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowExecutionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workflowexecution.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	case workflowexecution.EdgeExecutionData:
		if id := m.execution_data; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowExecutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowExecutionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowExecutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedworkflow {
		edges = append(edges, workflowexecution.EdgeWorkflow)
	}
	if m.clearedexecution_data {
		edges = append(edges, workflowexecution.EdgeExecutionData)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowExecutionMutation) EdgeCleared(name string) bool {
	switch name {
	case workflowexecution.EdgeWorkflow:
		return m.clearedworkflow
	case workflowexecution.EdgeExecutionData:
		return m.clearedexecution_data
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowExecutionMutation) ClearEdge(name string) error {
	switch name {
	case workflowexecution.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	case workflowexecution.EdgeExecutionData:
		m.ClearExecutionData()
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowExecutionMutation) ResetEdge(name string) error {
	switch name {
	case workflowexecution.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	case workflowexecution.EdgeExecutionData:
		m.ResetExecutionData()
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecution edge %s", name)
}

// WorkflowExecutionDataMutation represents an operation that mutates the WorkflowExecutionData nodes in the graph.
type WorkflowExecutionDataMutation struct {
	config
	op               Op
	typ              string
	id               *schema.WorkflowExecutionDataID
	last_heartbeat   *time.Time
	outputs          *[]byte
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	execution        *schema.WorkflowExecutionID
	clearedexecution bool
	done             bool
	oldValue         func(context.Context) (*WorkflowExecutionData, error)
	predicates       []predicate.WorkflowExecutionData
}

var _ ent.Mutation = (*WorkflowExecutionDataMutation)(nil)

// workflowexecutiondataOption allows management of the mutation configuration using functional options.
type workflowexecutiondataOption func(*WorkflowExecutionDataMutation)

// newWorkflowExecutionDataMutation creates new mutation for the WorkflowExecutionData entity.
func newWorkflowExecutionDataMutation(c config, op Op, opts ...workflowexecutiondataOption) *WorkflowExecutionDataMutation {
	m := &WorkflowExecutionDataMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflowExecutionData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowExecutionDataID sets the ID field of the mutation.
func withWorkflowExecutionDataID(id schema.WorkflowExecutionDataID) workflowexecutiondataOption {
	return func(m *WorkflowExecutionDataMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkflowExecutionData
		)
		m.oldValue = func(ctx context.Context) (*WorkflowExecutionData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkflowExecutionData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflowExecutionData sets the old WorkflowExecutionData of the mutation.
func withWorkflowExecutionData(node *WorkflowExecutionData) workflowexecutiondataOption {
	return func(m *WorkflowExecutionDataMutation) {
		m.oldValue = func(context.Context) (*WorkflowExecutionData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowExecutionDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowExecutionDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkflowExecutionData entities.
func (m *WorkflowExecutionDataMutation) SetID(id schema.WorkflowExecutionDataID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowExecutionDataMutation) ID() (id schema.WorkflowExecutionDataID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowExecutionDataMutation) IDs(ctx context.Context) ([]schema.WorkflowExecutionDataID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []schema.WorkflowExecutionDataID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkflowExecutionData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExecutionID sets the "execution_id" field.
func (m *WorkflowExecutionDataMutation) SetExecutionID(sei schema.WorkflowExecutionID) {
	m.execution = &sei
}

// ExecutionID returns the value of the "execution_id" field in the mutation.
func (m *WorkflowExecutionDataMutation) ExecutionID() (r schema.WorkflowExecutionID, exists bool) {
	v := m.execution
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutionID returns the old "execution_id" field's value of the WorkflowExecutionData entity.
// If the WorkflowExecutionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionDataMutation) OldExecutionID(ctx context.Context) (v schema.WorkflowExecutionID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutionID: %w", err)
	}
	return oldValue.ExecutionID, nil
}

// ResetExecutionID resets all changes to the "execution_id" field.
func (m *WorkflowExecutionDataMutation) ResetExecutionID() {
	m.execution = nil
}

// SetLastHeartbeat sets the "last_heartbeat" field.
func (m *WorkflowExecutionDataMutation) SetLastHeartbeat(t time.Time) {
	m.last_heartbeat = &t
}

// LastHeartbeat returns the value of the "last_heartbeat" field in the mutation.
func (m *WorkflowExecutionDataMutation) LastHeartbeat() (r time.Time, exists bool) {
	v := m.last_heartbeat
	if v == nil {
		return
	}
	return *v, true
}

// OldLastHeartbeat returns the old "last_heartbeat" field's value of the WorkflowExecutionData entity.
// If the WorkflowExecutionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionDataMutation) OldLastHeartbeat(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastHeartbeat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastHeartbeat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastHeartbeat: %w", err)
	}
	return oldValue.LastHeartbeat, nil
}

// ClearLastHeartbeat clears the value of the "last_heartbeat" field.
func (m *WorkflowExecutionDataMutation) ClearLastHeartbeat() {
	m.last_heartbeat = nil
	m.clearedFields[workflowexecutiondata.FieldLastHeartbeat] = struct{}{}
}

// LastHeartbeatCleared returns if the "last_heartbeat" field was cleared in this mutation.
func (m *WorkflowExecutionDataMutation) LastHeartbeatCleared() bool {
	_, ok := m.clearedFields[workflowexecutiondata.FieldLastHeartbeat]
	return ok
}

// ResetLastHeartbeat resets all changes to the "last_heartbeat" field.
func (m *WorkflowExecutionDataMutation) ResetLastHeartbeat() {
	m.last_heartbeat = nil
	delete(m.clearedFields, workflowexecutiondata.FieldLastHeartbeat)
}

// SetOutputs sets the "outputs" field.
func (m *WorkflowExecutionDataMutation) SetOutputs(b []byte) {
	m.outputs = &b
}

// Outputs returns the value of the "outputs" field in the mutation.
func (m *WorkflowExecutionDataMutation) Outputs() (r []byte, exists bool) {
	v := m.outputs
	if v == nil {
		return
	}
	return *v, true
}

// OldOutputs returns the old "outputs" field's value of the WorkflowExecutionData entity.
// If the WorkflowExecutionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionDataMutation) OldOutputs(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutputs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutputs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutputs: %w", err)
	}
	return oldValue.Outputs, nil
}

// ClearOutputs clears the value of the "outputs" field.
func (m *WorkflowExecutionDataMutation) ClearOutputs() {
	m.outputs = nil
	m.clearedFields[workflowexecutiondata.FieldOutputs] = struct{}{}
}

// OutputsCleared returns if the "outputs" field was cleared in this mutation.
func (m *WorkflowExecutionDataMutation) OutputsCleared() bool {
	_, ok := m.clearedFields[workflowexecutiondata.FieldOutputs]
	return ok
}

// ResetOutputs resets all changes to the "outputs" field.
func (m *WorkflowExecutionDataMutation) ResetOutputs() {
	m.outputs = nil
	delete(m.clearedFields, workflowexecutiondata.FieldOutputs)
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkflowExecutionDataMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkflowExecutionDataMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WorkflowExecutionData entity.
// If the WorkflowExecutionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionDataMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkflowExecutionDataMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkflowExecutionDataMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkflowExecutionDataMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WorkflowExecutionData entity.
// If the WorkflowExecutionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionDataMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkflowExecutionDataMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearExecution clears the "execution" edge to the WorkflowExecution entity.
func (m *WorkflowExecutionDataMutation) ClearExecution() {
	m.clearedexecution = true
	m.clearedFields[workflowexecutiondata.FieldExecutionID] = struct{}{}
}

// ExecutionCleared reports if the "execution" edge to the WorkflowExecution entity was cleared.
func (m *WorkflowExecutionDataMutation) ExecutionCleared() bool {
	return m.clearedexecution
}

// ExecutionIDs returns the "execution" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExecutionID instead. It exists only for internal usage by the builders.
func (m *WorkflowExecutionDataMutation) ExecutionIDs() (ids []schema.WorkflowExecutionID) {
	if id := m.execution; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExecution resets all changes to the "execution" edge.
func (m *WorkflowExecutionDataMutation) ResetExecution() {
	m.execution = nil
	m.clearedexecution = false
}

// Where appends a list predicates to the WorkflowExecutionDataMutation builder.
func (m *WorkflowExecutionDataMutation) Where(ps ...predicate.WorkflowExecutionData) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowExecutionDataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowExecutionDataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkflowExecutionData, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowExecutionDataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowExecutionDataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkflowExecutionData).
func (m *WorkflowExecutionDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowExecutionDataMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.execution != nil {
		fields = append(fields, workflowexecutiondata.FieldExecutionID)
	}
	if m.last_heartbeat != nil {
		fields = append(fields, workflowexecutiondata.FieldLastHeartbeat)
	}
	if m.outputs != nil {
		fields = append(fields, workflowexecutiondata.FieldOutputs)
	}
	if m.created_at != nil {
		fields = append(fields, workflowexecutiondata.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workflowexecutiondata.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowExecutionDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflowexecutiondata.FieldExecutionID:
		return m.ExecutionID()
	case workflowexecutiondata.FieldLastHeartbeat:
		return m.LastHeartbeat()
	case workflowexecutiondata.FieldOutputs:
		return m.Outputs()
	case workflowexecutiondata.FieldCreatedAt:
		return m.CreatedAt()
	case workflowexecutiondata.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowExecutionDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflowexecutiondata.FieldExecutionID:
		return m.OldExecutionID(ctx)
	case workflowexecutiondata.FieldLastHeartbeat:
		return m.OldLastHeartbeat(ctx)
	case workflowexecutiondata.FieldOutputs:
		return m.OldOutputs(ctx)
	case workflowexecutiondata.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workflowexecutiondata.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown WorkflowExecutionData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowExecutionDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflowexecutiondata.FieldExecutionID:
		v, ok := value.(schema.WorkflowExecutionID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutionID(v)
		return nil
	case workflowexecutiondata.FieldLastHeartbeat:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastHeartbeat(v)
		return nil
	case workflowexecutiondata.FieldOutputs:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutputs(v)
		return nil
	case workflowexecutiondata.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workflowexecutiondata.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecutionData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowExecutionDataMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowExecutionDataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowExecutionDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkflowExecutionData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowExecutionDataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflowexecutiondata.FieldLastHeartbeat) {
		fields = append(fields, workflowexecutiondata.FieldLastHeartbeat)
	}
	if m.FieldCleared(workflowexecutiondata.FieldOutputs) {
		fields = append(fields, workflowexecutiondata.FieldOutputs)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowExecutionDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowExecutionDataMutation) ClearField(name string) error {
	switch name {
	case workflowexecutiondata.FieldLastHeartbeat:
		m.ClearLastHeartbeat()
		return nil
	case workflowexecutiondata.FieldOutputs:
		m.ClearOutputs()
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecutionData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowExecutionDataMutation) ResetField(name string) error {
	switch name {
	case workflowexecutiondata.FieldExecutionID:
		m.ResetExecutionID()
		return nil
	case workflowexecutiondata.FieldLastHeartbeat:
		m.ResetLastHeartbeat()
		return nil
	case workflowexecutiondata.FieldOutputs:
		m.ResetOutputs()
		return nil
	case workflowexecutiondata.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workflowexecutiondata.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecutionData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowExecutionDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.execution != nil {
		edges = append(edges, workflowexecutiondata.EdgeExecution)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowExecutionDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workflowexecutiondata.EdgeExecution:
		if id := m.execution; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowExecutionDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowExecutionDataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowExecutionDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedexecution {
		edges = append(edges, workflowexecutiondata.EdgeExecution)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowExecutionDataMutation) EdgeCleared(name string) bool {
	switch name {
	case workflowexecutiondata.EdgeExecution:
		return m.clearedexecution
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowExecutionDataMutation) ClearEdge(name string) error {
	switch name {
	case workflowexecutiondata.EdgeExecution:
		m.ClearExecution()
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecutionData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowExecutionDataMutation) ResetEdge(name string) error {
	switch name {
	case workflowexecutiondata.EdgeExecution:
		m.ResetExecution()
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecutionData edge %s", name)
}
