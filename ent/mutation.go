// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/davidroman0O/tempolite/ent/activity"
	"github.com/davidroman0O/tempolite/ent/activityexecution"
	"github.com/davidroman0O/tempolite/ent/executionrelationship"
	"github.com/davidroman0O/tempolite/ent/featureflagversion"
	"github.com/davidroman0O/tempolite/ent/predicate"
	"github.com/davidroman0O/tempolite/ent/run"
	"github.com/davidroman0O/tempolite/ent/saga"
	"github.com/davidroman0O/tempolite/ent/sagaexecution"
	"github.com/davidroman0O/tempolite/ent/schema"
	"github.com/davidroman0O/tempolite/ent/sideeffect"
	"github.com/davidroman0O/tempolite/ent/sideeffectexecution"
	"github.com/davidroman0O/tempolite/ent/signal"
	"github.com/davidroman0O/tempolite/ent/signalexecution"
	"github.com/davidroman0O/tempolite/ent/workflow"
	"github.com/davidroman0O/tempolite/ent/workflowexecution"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeActivity              = "Activity"
	TypeActivityExecution     = "ActivityExecution"
	TypeExecutionRelationship = "ExecutionRelationship"
	TypeFeatureFlagVersion    = "FeatureFlagVersion"
	TypeRun                   = "Run"
	TypeSaga                  = "Saga"
	TypeSagaExecution         = "SagaExecution"
	TypeSideEffect            = "SideEffect"
	TypeSideEffectExecution   = "SideEffectExecution"
	TypeSignal                = "Signal"
	TypeSignalExecution       = "SignalExecution"
	TypeWorkflow              = "Workflow"
	TypeWorkflowExecution     = "WorkflowExecution"
)

// ActivityMutation represents an operation that mutates the Activity nodes in the graph.
type ActivityMutation struct {
	config
	op                Op
	typ               string
	id                *string
	identity          *string
	step_id           *string
	status            *activity.Status
	queue_name        *string
	handler_name      *string
	input             *[][]uint8
	appendinput       [][]uint8
	retry_policy      *schema.RetryPolicy
	timeout           *time.Time
	created_at        *time.Time
	clearedFields     map[string]struct{}
	executions        map[string]struct{}
	removedexecutions map[string]struct{}
	clearedexecutions bool
	done              bool
	oldValue          func(context.Context) (*Activity, error)
	predicates        []predicate.Activity
}

var _ ent.Mutation = (*ActivityMutation)(nil)

// activityOption allows management of the mutation configuration using functional options.
type activityOption func(*ActivityMutation)

// newActivityMutation creates new mutation for the Activity entity.
func newActivityMutation(c config, op Op, opts ...activityOption) *ActivityMutation {
	m := &ActivityMutation{
		config:        c,
		op:            op,
		typ:           TypeActivity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActivityID sets the ID field of the mutation.
func withActivityID(id string) activityOption {
	return func(m *ActivityMutation) {
		var (
			err   error
			once  sync.Once
			value *Activity
		)
		m.oldValue = func(ctx context.Context) (*Activity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Activity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActivity sets the old Activity of the mutation.
func withActivity(node *Activity) activityOption {
	return func(m *ActivityMutation) {
		m.oldValue = func(context.Context) (*Activity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActivityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActivityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Activity entities.
func (m *ActivityMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActivityMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActivityMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Activity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIdentity sets the "identity" field.
func (m *ActivityMutation) SetIdentity(s string) {
	m.identity = &s
}

// Identity returns the value of the "identity" field in the mutation.
func (m *ActivityMutation) Identity() (r string, exists bool) {
	v := m.identity
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentity returns the old "identity" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldIdentity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentity: %w", err)
	}
	return oldValue.Identity, nil
}

// ResetIdentity resets all changes to the "identity" field.
func (m *ActivityMutation) ResetIdentity() {
	m.identity = nil
}

// SetStepID sets the "step_id" field.
func (m *ActivityMutation) SetStepID(s string) {
	m.step_id = &s
}

// StepID returns the value of the "step_id" field in the mutation.
func (m *ActivityMutation) StepID() (r string, exists bool) {
	v := m.step_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStepID returns the old "step_id" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldStepID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStepID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStepID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStepID: %w", err)
	}
	return oldValue.StepID, nil
}

// ResetStepID resets all changes to the "step_id" field.
func (m *ActivityMutation) ResetStepID() {
	m.step_id = nil
}

// SetStatus sets the "status" field.
func (m *ActivityMutation) SetStatus(a activity.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *ActivityMutation) Status() (r activity.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldStatus(ctx context.Context) (v activity.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ActivityMutation) ResetStatus() {
	m.status = nil
}

// SetQueueName sets the "queue_name" field.
func (m *ActivityMutation) SetQueueName(s string) {
	m.queue_name = &s
}

// QueueName returns the value of the "queue_name" field in the mutation.
func (m *ActivityMutation) QueueName() (r string, exists bool) {
	v := m.queue_name
	if v == nil {
		return
	}
	return *v, true
}

// OldQueueName returns the old "queue_name" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldQueueName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQueueName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQueueName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQueueName: %w", err)
	}
	return oldValue.QueueName, nil
}

// ResetQueueName resets all changes to the "queue_name" field.
func (m *ActivityMutation) ResetQueueName() {
	m.queue_name = nil
}

// SetHandlerName sets the "handler_name" field.
func (m *ActivityMutation) SetHandlerName(s string) {
	m.handler_name = &s
}

// HandlerName returns the value of the "handler_name" field in the mutation.
func (m *ActivityMutation) HandlerName() (r string, exists bool) {
	v := m.handler_name
	if v == nil {
		return
	}
	return *v, true
}

// OldHandlerName returns the old "handler_name" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldHandlerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandlerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandlerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandlerName: %w", err)
	}
	return oldValue.HandlerName, nil
}

// ResetHandlerName resets all changes to the "handler_name" field.
func (m *ActivityMutation) ResetHandlerName() {
	m.handler_name = nil
}

// SetInput sets the "input" field.
func (m *ActivityMutation) SetInput(u [][]uint8) {
	m.input = &u
	m.appendinput = nil
}

// Input returns the value of the "input" field in the mutation.
func (m *ActivityMutation) Input() (r [][]uint8, exists bool) {
	v := m.input
	if v == nil {
		return
	}
	return *v, true
}

// OldInput returns the old "input" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldInput(ctx context.Context) (v [][]uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInput: %w", err)
	}
	return oldValue.Input, nil
}

// AppendInput adds u to the "input" field.
func (m *ActivityMutation) AppendInput(u [][]uint8) {
	m.appendinput = append(m.appendinput, u...)
}

// AppendedInput returns the list of values that were appended to the "input" field in this mutation.
func (m *ActivityMutation) AppendedInput() ([][]uint8, bool) {
	if len(m.appendinput) == 0 {
		return nil, false
	}
	return m.appendinput, true
}

// ResetInput resets all changes to the "input" field.
func (m *ActivityMutation) ResetInput() {
	m.input = nil
	m.appendinput = nil
}

// SetRetryPolicy sets the "retry_policy" field.
func (m *ActivityMutation) SetRetryPolicy(sp schema.RetryPolicy) {
	m.retry_policy = &sp
}

// RetryPolicy returns the value of the "retry_policy" field in the mutation.
func (m *ActivityMutation) RetryPolicy() (r schema.RetryPolicy, exists bool) {
	v := m.retry_policy
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryPolicy returns the old "retry_policy" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldRetryPolicy(ctx context.Context) (v schema.RetryPolicy, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryPolicy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryPolicy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryPolicy: %w", err)
	}
	return oldValue.RetryPolicy, nil
}

// ClearRetryPolicy clears the value of the "retry_policy" field.
func (m *ActivityMutation) ClearRetryPolicy() {
	m.retry_policy = nil
	m.clearedFields[activity.FieldRetryPolicy] = struct{}{}
}

// RetryPolicyCleared returns if the "retry_policy" field was cleared in this mutation.
func (m *ActivityMutation) RetryPolicyCleared() bool {
	_, ok := m.clearedFields[activity.FieldRetryPolicy]
	return ok
}

// ResetRetryPolicy resets all changes to the "retry_policy" field.
func (m *ActivityMutation) ResetRetryPolicy() {
	m.retry_policy = nil
	delete(m.clearedFields, activity.FieldRetryPolicy)
}

// SetTimeout sets the "timeout" field.
func (m *ActivityMutation) SetTimeout(t time.Time) {
	m.timeout = &t
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *ActivityMutation) Timeout() (r time.Time, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldTimeout(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// ClearTimeout clears the value of the "timeout" field.
func (m *ActivityMutation) ClearTimeout() {
	m.timeout = nil
	m.clearedFields[activity.FieldTimeout] = struct{}{}
}

// TimeoutCleared returns if the "timeout" field was cleared in this mutation.
func (m *ActivityMutation) TimeoutCleared() bool {
	_, ok := m.clearedFields[activity.FieldTimeout]
	return ok
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *ActivityMutation) ResetTimeout() {
	m.timeout = nil
	delete(m.clearedFields, activity.FieldTimeout)
}

// SetCreatedAt sets the "created_at" field.
func (m *ActivityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ActivityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ActivityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddExecutionIDs adds the "executions" edge to the ActivityExecution entity by ids.
func (m *ActivityMutation) AddExecutionIDs(ids ...string) {
	if m.executions == nil {
		m.executions = make(map[string]struct{})
	}
	for i := range ids {
		m.executions[ids[i]] = struct{}{}
	}
}

// ClearExecutions clears the "executions" edge to the ActivityExecution entity.
func (m *ActivityMutation) ClearExecutions() {
	m.clearedexecutions = true
}

// ExecutionsCleared reports if the "executions" edge to the ActivityExecution entity was cleared.
func (m *ActivityMutation) ExecutionsCleared() bool {
	return m.clearedexecutions
}

// RemoveExecutionIDs removes the "executions" edge to the ActivityExecution entity by IDs.
func (m *ActivityMutation) RemoveExecutionIDs(ids ...string) {
	if m.removedexecutions == nil {
		m.removedexecutions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.executions, ids[i])
		m.removedexecutions[ids[i]] = struct{}{}
	}
}

// RemovedExecutions returns the removed IDs of the "executions" edge to the ActivityExecution entity.
func (m *ActivityMutation) RemovedExecutionsIDs() (ids []string) {
	for id := range m.removedexecutions {
		ids = append(ids, id)
	}
	return
}

// ExecutionsIDs returns the "executions" edge IDs in the mutation.
func (m *ActivityMutation) ExecutionsIDs() (ids []string) {
	for id := range m.executions {
		ids = append(ids, id)
	}
	return
}

// ResetExecutions resets all changes to the "executions" edge.
func (m *ActivityMutation) ResetExecutions() {
	m.executions = nil
	m.clearedexecutions = false
	m.removedexecutions = nil
}

// Where appends a list predicates to the ActivityMutation builder.
func (m *ActivityMutation) Where(ps ...predicate.Activity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ActivityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ActivityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Activity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ActivityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ActivityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Activity).
func (m *ActivityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActivityMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.identity != nil {
		fields = append(fields, activity.FieldIdentity)
	}
	if m.step_id != nil {
		fields = append(fields, activity.FieldStepID)
	}
	if m.status != nil {
		fields = append(fields, activity.FieldStatus)
	}
	if m.queue_name != nil {
		fields = append(fields, activity.FieldQueueName)
	}
	if m.handler_name != nil {
		fields = append(fields, activity.FieldHandlerName)
	}
	if m.input != nil {
		fields = append(fields, activity.FieldInput)
	}
	if m.retry_policy != nil {
		fields = append(fields, activity.FieldRetryPolicy)
	}
	if m.timeout != nil {
		fields = append(fields, activity.FieldTimeout)
	}
	if m.created_at != nil {
		fields = append(fields, activity.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActivityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case activity.FieldIdentity:
		return m.Identity()
	case activity.FieldStepID:
		return m.StepID()
	case activity.FieldStatus:
		return m.Status()
	case activity.FieldQueueName:
		return m.QueueName()
	case activity.FieldHandlerName:
		return m.HandlerName()
	case activity.FieldInput:
		return m.Input()
	case activity.FieldRetryPolicy:
		return m.RetryPolicy()
	case activity.FieldTimeout:
		return m.Timeout()
	case activity.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActivityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case activity.FieldIdentity:
		return m.OldIdentity(ctx)
	case activity.FieldStepID:
		return m.OldStepID(ctx)
	case activity.FieldStatus:
		return m.OldStatus(ctx)
	case activity.FieldQueueName:
		return m.OldQueueName(ctx)
	case activity.FieldHandlerName:
		return m.OldHandlerName(ctx)
	case activity.FieldInput:
		return m.OldInput(ctx)
	case activity.FieldRetryPolicy:
		return m.OldRetryPolicy(ctx)
	case activity.FieldTimeout:
		return m.OldTimeout(ctx)
	case activity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Activity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case activity.FieldIdentity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentity(v)
		return nil
	case activity.FieldStepID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStepID(v)
		return nil
	case activity.FieldStatus:
		v, ok := value.(activity.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case activity.FieldQueueName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQueueName(v)
		return nil
	case activity.FieldHandlerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandlerName(v)
		return nil
	case activity.FieldInput:
		v, ok := value.([][]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInput(v)
		return nil
	case activity.FieldRetryPolicy:
		v, ok := value.(schema.RetryPolicy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryPolicy(v)
		return nil
	case activity.FieldTimeout:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case activity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Activity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActivityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActivityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Activity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActivityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(activity.FieldRetryPolicy) {
		fields = append(fields, activity.FieldRetryPolicy)
	}
	if m.FieldCleared(activity.FieldTimeout) {
		fields = append(fields, activity.FieldTimeout)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActivityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActivityMutation) ClearField(name string) error {
	switch name {
	case activity.FieldRetryPolicy:
		m.ClearRetryPolicy()
		return nil
	case activity.FieldTimeout:
		m.ClearTimeout()
		return nil
	}
	return fmt.Errorf("unknown Activity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActivityMutation) ResetField(name string) error {
	switch name {
	case activity.FieldIdentity:
		m.ResetIdentity()
		return nil
	case activity.FieldStepID:
		m.ResetStepID()
		return nil
	case activity.FieldStatus:
		m.ResetStatus()
		return nil
	case activity.FieldQueueName:
		m.ResetQueueName()
		return nil
	case activity.FieldHandlerName:
		m.ResetHandlerName()
		return nil
	case activity.FieldInput:
		m.ResetInput()
		return nil
	case activity.FieldRetryPolicy:
		m.ResetRetryPolicy()
		return nil
	case activity.FieldTimeout:
		m.ResetTimeout()
		return nil
	case activity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Activity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActivityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.executions != nil {
		edges = append(edges, activity.EdgeExecutions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActivityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case activity.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.executions))
		for id := range m.executions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActivityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedexecutions != nil {
		edges = append(edges, activity.EdgeExecutions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActivityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case activity.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.removedexecutions))
		for id := range m.removedexecutions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActivityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedexecutions {
		edges = append(edges, activity.EdgeExecutions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActivityMutation) EdgeCleared(name string) bool {
	switch name {
	case activity.EdgeExecutions:
		return m.clearedexecutions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActivityMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Activity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActivityMutation) ResetEdge(name string) error {
	switch name {
	case activity.EdgeExecutions:
		m.ResetExecutions()
		return nil
	}
	return fmt.Errorf("unknown Activity edge %s", name)
}

// ActivityExecutionMutation represents an operation that mutates the ActivityExecution nodes in the graph.
type ActivityExecutionMutation struct {
	config
	op              Op
	typ             string
	id              *string
	run_id          *string
	status          *activityexecution.Status
	queue_name      *string
	attempt         *int
	addattempt      *int
	output          *[][]uint8
	appendoutput    [][]uint8
	error           *string
	started_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	activity        *string
	clearedactivity bool
	done            bool
	oldValue        func(context.Context) (*ActivityExecution, error)
	predicates      []predicate.ActivityExecution
}

var _ ent.Mutation = (*ActivityExecutionMutation)(nil)

// activityexecutionOption allows management of the mutation configuration using functional options.
type activityexecutionOption func(*ActivityExecutionMutation)

// newActivityExecutionMutation creates new mutation for the ActivityExecution entity.
func newActivityExecutionMutation(c config, op Op, opts ...activityexecutionOption) *ActivityExecutionMutation {
	m := &ActivityExecutionMutation{
		config:        c,
		op:            op,
		typ:           TypeActivityExecution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActivityExecutionID sets the ID field of the mutation.
func withActivityExecutionID(id string) activityexecutionOption {
	return func(m *ActivityExecutionMutation) {
		var (
			err   error
			once  sync.Once
			value *ActivityExecution
		)
		m.oldValue = func(ctx context.Context) (*ActivityExecution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ActivityExecution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActivityExecution sets the old ActivityExecution of the mutation.
func withActivityExecution(node *ActivityExecution) activityexecutionOption {
	return func(m *ActivityExecutionMutation) {
		m.oldValue = func(context.Context) (*ActivityExecution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActivityExecutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActivityExecutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ActivityExecution entities.
func (m *ActivityExecutionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActivityExecutionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActivityExecutionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ActivityExecution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRunID sets the "run_id" field.
func (m *ActivityExecutionMutation) SetRunID(s string) {
	m.run_id = &s
}

// RunID returns the value of the "run_id" field in the mutation.
func (m *ActivityExecutionMutation) RunID() (r string, exists bool) {
	v := m.run_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRunID returns the old "run_id" field's value of the ActivityExecution entity.
// If the ActivityExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityExecutionMutation) OldRunID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunID: %w", err)
	}
	return oldValue.RunID, nil
}

// ResetRunID resets all changes to the "run_id" field.
func (m *ActivityExecutionMutation) ResetRunID() {
	m.run_id = nil
}

// SetStatus sets the "status" field.
func (m *ActivityExecutionMutation) SetStatus(a activityexecution.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *ActivityExecutionMutation) Status() (r activityexecution.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ActivityExecution entity.
// If the ActivityExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityExecutionMutation) OldStatus(ctx context.Context) (v activityexecution.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ActivityExecutionMutation) ResetStatus() {
	m.status = nil
}

// SetQueueName sets the "queue_name" field.
func (m *ActivityExecutionMutation) SetQueueName(s string) {
	m.queue_name = &s
}

// QueueName returns the value of the "queue_name" field in the mutation.
func (m *ActivityExecutionMutation) QueueName() (r string, exists bool) {
	v := m.queue_name
	if v == nil {
		return
	}
	return *v, true
}

// OldQueueName returns the old "queue_name" field's value of the ActivityExecution entity.
// If the ActivityExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityExecutionMutation) OldQueueName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQueueName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQueueName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQueueName: %w", err)
	}
	return oldValue.QueueName, nil
}

// ResetQueueName resets all changes to the "queue_name" field.
func (m *ActivityExecutionMutation) ResetQueueName() {
	m.queue_name = nil
}

// SetAttempt sets the "attempt" field.
func (m *ActivityExecutionMutation) SetAttempt(i int) {
	m.attempt = &i
	m.addattempt = nil
}

// Attempt returns the value of the "attempt" field in the mutation.
func (m *ActivityExecutionMutation) Attempt() (r int, exists bool) {
	v := m.attempt
	if v == nil {
		return
	}
	return *v, true
}

// OldAttempt returns the old "attempt" field's value of the ActivityExecution entity.
// If the ActivityExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityExecutionMutation) OldAttempt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttempt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttempt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttempt: %w", err)
	}
	return oldValue.Attempt, nil
}

// AddAttempt adds i to the "attempt" field.
func (m *ActivityExecutionMutation) AddAttempt(i int) {
	if m.addattempt != nil {
		*m.addattempt += i
	} else {
		m.addattempt = &i
	}
}

// AddedAttempt returns the value that was added to the "attempt" field in this mutation.
func (m *ActivityExecutionMutation) AddedAttempt() (r int, exists bool) {
	v := m.addattempt
	if v == nil {
		return
	}
	return *v, true
}

// ResetAttempt resets all changes to the "attempt" field.
func (m *ActivityExecutionMutation) ResetAttempt() {
	m.attempt = nil
	m.addattempt = nil
}

// SetOutput sets the "output" field.
func (m *ActivityExecutionMutation) SetOutput(u [][]uint8) {
	m.output = &u
	m.appendoutput = nil
}

// Output returns the value of the "output" field in the mutation.
func (m *ActivityExecutionMutation) Output() (r [][]uint8, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the ActivityExecution entity.
// If the ActivityExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityExecutionMutation) OldOutput(ctx context.Context) (v [][]uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// AppendOutput adds u to the "output" field.
func (m *ActivityExecutionMutation) AppendOutput(u [][]uint8) {
	m.appendoutput = append(m.appendoutput, u...)
}

// AppendedOutput returns the list of values that were appended to the "output" field in this mutation.
func (m *ActivityExecutionMutation) AppendedOutput() ([][]uint8, bool) {
	if len(m.appendoutput) == 0 {
		return nil, false
	}
	return m.appendoutput, true
}

// ClearOutput clears the value of the "output" field.
func (m *ActivityExecutionMutation) ClearOutput() {
	m.output = nil
	m.appendoutput = nil
	m.clearedFields[activityexecution.FieldOutput] = struct{}{}
}

// OutputCleared returns if the "output" field was cleared in this mutation.
func (m *ActivityExecutionMutation) OutputCleared() bool {
	_, ok := m.clearedFields[activityexecution.FieldOutput]
	return ok
}

// ResetOutput resets all changes to the "output" field.
func (m *ActivityExecutionMutation) ResetOutput() {
	m.output = nil
	m.appendoutput = nil
	delete(m.clearedFields, activityexecution.FieldOutput)
}

// SetError sets the "error" field.
func (m *ActivityExecutionMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *ActivityExecutionMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the ActivityExecution entity.
// If the ActivityExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityExecutionMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *ActivityExecutionMutation) ClearError() {
	m.error = nil
	m.clearedFields[activityexecution.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *ActivityExecutionMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[activityexecution.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *ActivityExecutionMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, activityexecution.FieldError)
}

// SetStartedAt sets the "started_at" field.
func (m *ActivityExecutionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *ActivityExecutionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the ActivityExecution entity.
// If the ActivityExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityExecutionMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *ActivityExecutionMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ActivityExecutionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ActivityExecutionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ActivityExecution entity.
// If the ActivityExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityExecutionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ActivityExecutionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetActivityID sets the "activity" edge to the Activity entity by id.
func (m *ActivityExecutionMutation) SetActivityID(id string) {
	m.activity = &id
}

// ClearActivity clears the "activity" edge to the Activity entity.
func (m *ActivityExecutionMutation) ClearActivity() {
	m.clearedactivity = true
}

// ActivityCleared reports if the "activity" edge to the Activity entity was cleared.
func (m *ActivityExecutionMutation) ActivityCleared() bool {
	return m.clearedactivity
}

// ActivityID returns the "activity" edge ID in the mutation.
func (m *ActivityExecutionMutation) ActivityID() (id string, exists bool) {
	if m.activity != nil {
		return *m.activity, true
	}
	return
}

// ActivityIDs returns the "activity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActivityID instead. It exists only for internal usage by the builders.
func (m *ActivityExecutionMutation) ActivityIDs() (ids []string) {
	if id := m.activity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActivity resets all changes to the "activity" edge.
func (m *ActivityExecutionMutation) ResetActivity() {
	m.activity = nil
	m.clearedactivity = false
}

// Where appends a list predicates to the ActivityExecutionMutation builder.
func (m *ActivityExecutionMutation) Where(ps ...predicate.ActivityExecution) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ActivityExecutionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ActivityExecutionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ActivityExecution, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ActivityExecutionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ActivityExecutionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ActivityExecution).
func (m *ActivityExecutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActivityExecutionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.run_id != nil {
		fields = append(fields, activityexecution.FieldRunID)
	}
	if m.status != nil {
		fields = append(fields, activityexecution.FieldStatus)
	}
	if m.queue_name != nil {
		fields = append(fields, activityexecution.FieldQueueName)
	}
	if m.attempt != nil {
		fields = append(fields, activityexecution.FieldAttempt)
	}
	if m.output != nil {
		fields = append(fields, activityexecution.FieldOutput)
	}
	if m.error != nil {
		fields = append(fields, activityexecution.FieldError)
	}
	if m.started_at != nil {
		fields = append(fields, activityexecution.FieldStartedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, activityexecution.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActivityExecutionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case activityexecution.FieldRunID:
		return m.RunID()
	case activityexecution.FieldStatus:
		return m.Status()
	case activityexecution.FieldQueueName:
		return m.QueueName()
	case activityexecution.FieldAttempt:
		return m.Attempt()
	case activityexecution.FieldOutput:
		return m.Output()
	case activityexecution.FieldError:
		return m.Error()
	case activityexecution.FieldStartedAt:
		return m.StartedAt()
	case activityexecution.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActivityExecutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case activityexecution.FieldRunID:
		return m.OldRunID(ctx)
	case activityexecution.FieldStatus:
		return m.OldStatus(ctx)
	case activityexecution.FieldQueueName:
		return m.OldQueueName(ctx)
	case activityexecution.FieldAttempt:
		return m.OldAttempt(ctx)
	case activityexecution.FieldOutput:
		return m.OldOutput(ctx)
	case activityexecution.FieldError:
		return m.OldError(ctx)
	case activityexecution.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case activityexecution.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ActivityExecution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityExecutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case activityexecution.FieldRunID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunID(v)
		return nil
	case activityexecution.FieldStatus:
		v, ok := value.(activityexecution.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case activityexecution.FieldQueueName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQueueName(v)
		return nil
	case activityexecution.FieldAttempt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttempt(v)
		return nil
	case activityexecution.FieldOutput:
		v, ok := value.([][]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case activityexecution.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case activityexecution.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case activityexecution.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ActivityExecution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActivityExecutionMutation) AddedFields() []string {
	var fields []string
	if m.addattempt != nil {
		fields = append(fields, activityexecution.FieldAttempt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActivityExecutionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case activityexecution.FieldAttempt:
		return m.AddedAttempt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityExecutionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case activityexecution.FieldAttempt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAttempt(v)
		return nil
	}
	return fmt.Errorf("unknown ActivityExecution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActivityExecutionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(activityexecution.FieldOutput) {
		fields = append(fields, activityexecution.FieldOutput)
	}
	if m.FieldCleared(activityexecution.FieldError) {
		fields = append(fields, activityexecution.FieldError)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActivityExecutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActivityExecutionMutation) ClearField(name string) error {
	switch name {
	case activityexecution.FieldOutput:
		m.ClearOutput()
		return nil
	case activityexecution.FieldError:
		m.ClearError()
		return nil
	}
	return fmt.Errorf("unknown ActivityExecution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActivityExecutionMutation) ResetField(name string) error {
	switch name {
	case activityexecution.FieldRunID:
		m.ResetRunID()
		return nil
	case activityexecution.FieldStatus:
		m.ResetStatus()
		return nil
	case activityexecution.FieldQueueName:
		m.ResetQueueName()
		return nil
	case activityexecution.FieldAttempt:
		m.ResetAttempt()
		return nil
	case activityexecution.FieldOutput:
		m.ResetOutput()
		return nil
	case activityexecution.FieldError:
		m.ResetError()
		return nil
	case activityexecution.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case activityexecution.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ActivityExecution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActivityExecutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.activity != nil {
		edges = append(edges, activityexecution.EdgeActivity)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActivityExecutionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case activityexecution.EdgeActivity:
		if id := m.activity; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActivityExecutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActivityExecutionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActivityExecutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedactivity {
		edges = append(edges, activityexecution.EdgeActivity)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActivityExecutionMutation) EdgeCleared(name string) bool {
	switch name {
	case activityexecution.EdgeActivity:
		return m.clearedactivity
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActivityExecutionMutation) ClearEdge(name string) error {
	switch name {
	case activityexecution.EdgeActivity:
		m.ClearActivity()
		return nil
	}
	return fmt.Errorf("unknown ActivityExecution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActivityExecutionMutation) ResetEdge(name string) error {
	switch name {
	case activityexecution.EdgeActivity:
		m.ResetActivity()
		return nil
	}
	return fmt.Errorf("unknown ActivityExecution edge %s", name)
}

// ExecutionRelationshipMutation represents an operation that mutates the ExecutionRelationship nodes in the graph.
type ExecutionRelationshipMutation struct {
	config
	op               Op
	typ              string
	id               *int
	run_id           *string
	parent_entity_id *string
	child_entity_id  *string
	parent_id        *string
	child_id         *string
	parent_type      *executionrelationship.ParentType
	child_type       *executionrelationship.ChildType
	parent_step_id   *string
	child_step_id    *string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*ExecutionRelationship, error)
	predicates       []predicate.ExecutionRelationship
}

var _ ent.Mutation = (*ExecutionRelationshipMutation)(nil)

// executionrelationshipOption allows management of the mutation configuration using functional options.
type executionrelationshipOption func(*ExecutionRelationshipMutation)

// newExecutionRelationshipMutation creates new mutation for the ExecutionRelationship entity.
func newExecutionRelationshipMutation(c config, op Op, opts ...executionrelationshipOption) *ExecutionRelationshipMutation {
	m := &ExecutionRelationshipMutation{
		config:        c,
		op:            op,
		typ:           TypeExecutionRelationship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExecutionRelationshipID sets the ID field of the mutation.
func withExecutionRelationshipID(id int) executionrelationshipOption {
	return func(m *ExecutionRelationshipMutation) {
		var (
			err   error
			once  sync.Once
			value *ExecutionRelationship
		)
		m.oldValue = func(ctx context.Context) (*ExecutionRelationship, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ExecutionRelationship.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExecutionRelationship sets the old ExecutionRelationship of the mutation.
func withExecutionRelationship(node *ExecutionRelationship) executionrelationshipOption {
	return func(m *ExecutionRelationshipMutation) {
		m.oldValue = func(context.Context) (*ExecutionRelationship, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExecutionRelationshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExecutionRelationshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExecutionRelationshipMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExecutionRelationshipMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ExecutionRelationship.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRunID sets the "run_id" field.
func (m *ExecutionRelationshipMutation) SetRunID(s string) {
	m.run_id = &s
}

// RunID returns the value of the "run_id" field in the mutation.
func (m *ExecutionRelationshipMutation) RunID() (r string, exists bool) {
	v := m.run_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRunID returns the old "run_id" field's value of the ExecutionRelationship entity.
// If the ExecutionRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionRelationshipMutation) OldRunID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunID: %w", err)
	}
	return oldValue.RunID, nil
}

// ResetRunID resets all changes to the "run_id" field.
func (m *ExecutionRelationshipMutation) ResetRunID() {
	m.run_id = nil
}

// SetParentEntityID sets the "parent_entity_id" field.
func (m *ExecutionRelationshipMutation) SetParentEntityID(s string) {
	m.parent_entity_id = &s
}

// ParentEntityID returns the value of the "parent_entity_id" field in the mutation.
func (m *ExecutionRelationshipMutation) ParentEntityID() (r string, exists bool) {
	v := m.parent_entity_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentEntityID returns the old "parent_entity_id" field's value of the ExecutionRelationship entity.
// If the ExecutionRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionRelationshipMutation) OldParentEntityID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentEntityID: %w", err)
	}
	return oldValue.ParentEntityID, nil
}

// ResetParentEntityID resets all changes to the "parent_entity_id" field.
func (m *ExecutionRelationshipMutation) ResetParentEntityID() {
	m.parent_entity_id = nil
}

// SetChildEntityID sets the "child_entity_id" field.
func (m *ExecutionRelationshipMutation) SetChildEntityID(s string) {
	m.child_entity_id = &s
}

// ChildEntityID returns the value of the "child_entity_id" field in the mutation.
func (m *ExecutionRelationshipMutation) ChildEntityID() (r string, exists bool) {
	v := m.child_entity_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChildEntityID returns the old "child_entity_id" field's value of the ExecutionRelationship entity.
// If the ExecutionRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionRelationshipMutation) OldChildEntityID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChildEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChildEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChildEntityID: %w", err)
	}
	return oldValue.ChildEntityID, nil
}

// ResetChildEntityID resets all changes to the "child_entity_id" field.
func (m *ExecutionRelationshipMutation) ResetChildEntityID() {
	m.child_entity_id = nil
}

// SetParentID sets the "parent_id" field.
func (m *ExecutionRelationshipMutation) SetParentID(s string) {
	m.parent_id = &s
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *ExecutionRelationshipMutation) ParentID() (r string, exists bool) {
	v := m.parent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the ExecutionRelationship entity.
// If the ExecutionRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionRelationshipMutation) OldParentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *ExecutionRelationshipMutation) ResetParentID() {
	m.parent_id = nil
}

// SetChildID sets the "child_id" field.
func (m *ExecutionRelationshipMutation) SetChildID(s string) {
	m.child_id = &s
}

// ChildID returns the value of the "child_id" field in the mutation.
func (m *ExecutionRelationshipMutation) ChildID() (r string, exists bool) {
	v := m.child_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChildID returns the old "child_id" field's value of the ExecutionRelationship entity.
// If the ExecutionRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionRelationshipMutation) OldChildID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChildID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChildID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChildID: %w", err)
	}
	return oldValue.ChildID, nil
}

// ResetChildID resets all changes to the "child_id" field.
func (m *ExecutionRelationshipMutation) ResetChildID() {
	m.child_id = nil
}

// SetParentType sets the "parent_type" field.
func (m *ExecutionRelationshipMutation) SetParentType(et executionrelationship.ParentType) {
	m.parent_type = &et
}

// ParentType returns the value of the "parent_type" field in the mutation.
func (m *ExecutionRelationshipMutation) ParentType() (r executionrelationship.ParentType, exists bool) {
	v := m.parent_type
	if v == nil {
		return
	}
	return *v, true
}

// OldParentType returns the old "parent_type" field's value of the ExecutionRelationship entity.
// If the ExecutionRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionRelationshipMutation) OldParentType(ctx context.Context) (v executionrelationship.ParentType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentType: %w", err)
	}
	return oldValue.ParentType, nil
}

// ResetParentType resets all changes to the "parent_type" field.
func (m *ExecutionRelationshipMutation) ResetParentType() {
	m.parent_type = nil
}

// SetChildType sets the "child_type" field.
func (m *ExecutionRelationshipMutation) SetChildType(et executionrelationship.ChildType) {
	m.child_type = &et
}

// ChildType returns the value of the "child_type" field in the mutation.
func (m *ExecutionRelationshipMutation) ChildType() (r executionrelationship.ChildType, exists bool) {
	v := m.child_type
	if v == nil {
		return
	}
	return *v, true
}

// OldChildType returns the old "child_type" field's value of the ExecutionRelationship entity.
// If the ExecutionRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionRelationshipMutation) OldChildType(ctx context.Context) (v executionrelationship.ChildType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChildType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChildType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChildType: %w", err)
	}
	return oldValue.ChildType, nil
}

// ResetChildType resets all changes to the "child_type" field.
func (m *ExecutionRelationshipMutation) ResetChildType() {
	m.child_type = nil
}

// SetParentStepID sets the "parent_step_id" field.
func (m *ExecutionRelationshipMutation) SetParentStepID(s string) {
	m.parent_step_id = &s
}

// ParentStepID returns the value of the "parent_step_id" field in the mutation.
func (m *ExecutionRelationshipMutation) ParentStepID() (r string, exists bool) {
	v := m.parent_step_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentStepID returns the old "parent_step_id" field's value of the ExecutionRelationship entity.
// If the ExecutionRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionRelationshipMutation) OldParentStepID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentStepID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentStepID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentStepID: %w", err)
	}
	return oldValue.ParentStepID, nil
}

// ResetParentStepID resets all changes to the "parent_step_id" field.
func (m *ExecutionRelationshipMutation) ResetParentStepID() {
	m.parent_step_id = nil
}

// SetChildStepID sets the "child_step_id" field.
func (m *ExecutionRelationshipMutation) SetChildStepID(s string) {
	m.child_step_id = &s
}

// ChildStepID returns the value of the "child_step_id" field in the mutation.
func (m *ExecutionRelationshipMutation) ChildStepID() (r string, exists bool) {
	v := m.child_step_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChildStepID returns the old "child_step_id" field's value of the ExecutionRelationship entity.
// If the ExecutionRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionRelationshipMutation) OldChildStepID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChildStepID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChildStepID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChildStepID: %w", err)
	}
	return oldValue.ChildStepID, nil
}

// ResetChildStepID resets all changes to the "child_step_id" field.
func (m *ExecutionRelationshipMutation) ResetChildStepID() {
	m.child_step_id = nil
}

// Where appends a list predicates to the ExecutionRelationshipMutation builder.
func (m *ExecutionRelationshipMutation) Where(ps ...predicate.ExecutionRelationship) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExecutionRelationshipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExecutionRelationshipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ExecutionRelationship, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExecutionRelationshipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExecutionRelationshipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ExecutionRelationship).
func (m *ExecutionRelationshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExecutionRelationshipMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.run_id != nil {
		fields = append(fields, executionrelationship.FieldRunID)
	}
	if m.parent_entity_id != nil {
		fields = append(fields, executionrelationship.FieldParentEntityID)
	}
	if m.child_entity_id != nil {
		fields = append(fields, executionrelationship.FieldChildEntityID)
	}
	if m.parent_id != nil {
		fields = append(fields, executionrelationship.FieldParentID)
	}
	if m.child_id != nil {
		fields = append(fields, executionrelationship.FieldChildID)
	}
	if m.parent_type != nil {
		fields = append(fields, executionrelationship.FieldParentType)
	}
	if m.child_type != nil {
		fields = append(fields, executionrelationship.FieldChildType)
	}
	if m.parent_step_id != nil {
		fields = append(fields, executionrelationship.FieldParentStepID)
	}
	if m.child_step_id != nil {
		fields = append(fields, executionrelationship.FieldChildStepID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExecutionRelationshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case executionrelationship.FieldRunID:
		return m.RunID()
	case executionrelationship.FieldParentEntityID:
		return m.ParentEntityID()
	case executionrelationship.FieldChildEntityID:
		return m.ChildEntityID()
	case executionrelationship.FieldParentID:
		return m.ParentID()
	case executionrelationship.FieldChildID:
		return m.ChildID()
	case executionrelationship.FieldParentType:
		return m.ParentType()
	case executionrelationship.FieldChildType:
		return m.ChildType()
	case executionrelationship.FieldParentStepID:
		return m.ParentStepID()
	case executionrelationship.FieldChildStepID:
		return m.ChildStepID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExecutionRelationshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case executionrelationship.FieldRunID:
		return m.OldRunID(ctx)
	case executionrelationship.FieldParentEntityID:
		return m.OldParentEntityID(ctx)
	case executionrelationship.FieldChildEntityID:
		return m.OldChildEntityID(ctx)
	case executionrelationship.FieldParentID:
		return m.OldParentID(ctx)
	case executionrelationship.FieldChildID:
		return m.OldChildID(ctx)
	case executionrelationship.FieldParentType:
		return m.OldParentType(ctx)
	case executionrelationship.FieldChildType:
		return m.OldChildType(ctx)
	case executionrelationship.FieldParentStepID:
		return m.OldParentStepID(ctx)
	case executionrelationship.FieldChildStepID:
		return m.OldChildStepID(ctx)
	}
	return nil, fmt.Errorf("unknown ExecutionRelationship field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExecutionRelationshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case executionrelationship.FieldRunID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunID(v)
		return nil
	case executionrelationship.FieldParentEntityID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentEntityID(v)
		return nil
	case executionrelationship.FieldChildEntityID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChildEntityID(v)
		return nil
	case executionrelationship.FieldParentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case executionrelationship.FieldChildID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChildID(v)
		return nil
	case executionrelationship.FieldParentType:
		v, ok := value.(executionrelationship.ParentType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentType(v)
		return nil
	case executionrelationship.FieldChildType:
		v, ok := value.(executionrelationship.ChildType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChildType(v)
		return nil
	case executionrelationship.FieldParentStepID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentStepID(v)
		return nil
	case executionrelationship.FieldChildStepID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChildStepID(v)
		return nil
	}
	return fmt.Errorf("unknown ExecutionRelationship field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExecutionRelationshipMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExecutionRelationshipMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExecutionRelationshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ExecutionRelationship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExecutionRelationshipMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExecutionRelationshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExecutionRelationshipMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ExecutionRelationship nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExecutionRelationshipMutation) ResetField(name string) error {
	switch name {
	case executionrelationship.FieldRunID:
		m.ResetRunID()
		return nil
	case executionrelationship.FieldParentEntityID:
		m.ResetParentEntityID()
		return nil
	case executionrelationship.FieldChildEntityID:
		m.ResetChildEntityID()
		return nil
	case executionrelationship.FieldParentID:
		m.ResetParentID()
		return nil
	case executionrelationship.FieldChildID:
		m.ResetChildID()
		return nil
	case executionrelationship.FieldParentType:
		m.ResetParentType()
		return nil
	case executionrelationship.FieldChildType:
		m.ResetChildType()
		return nil
	case executionrelationship.FieldParentStepID:
		m.ResetParentStepID()
		return nil
	case executionrelationship.FieldChildStepID:
		m.ResetChildStepID()
		return nil
	}
	return fmt.Errorf("unknown ExecutionRelationship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExecutionRelationshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExecutionRelationshipMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExecutionRelationshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExecutionRelationshipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExecutionRelationshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExecutionRelationshipMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExecutionRelationshipMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ExecutionRelationship unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExecutionRelationshipMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ExecutionRelationship edge %s", name)
}

// FeatureFlagVersionMutation represents an operation that mutates the FeatureFlagVersion nodes in the graph.
type FeatureFlagVersionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	workflow_type *string
	workflow_id   *string
	change_id     *string
	version       *int
	addversion    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*FeatureFlagVersion, error)
	predicates    []predicate.FeatureFlagVersion
}

var _ ent.Mutation = (*FeatureFlagVersionMutation)(nil)

// featureflagversionOption allows management of the mutation configuration using functional options.
type featureflagversionOption func(*FeatureFlagVersionMutation)

// newFeatureFlagVersionMutation creates new mutation for the FeatureFlagVersion entity.
func newFeatureFlagVersionMutation(c config, op Op, opts ...featureflagversionOption) *FeatureFlagVersionMutation {
	m := &FeatureFlagVersionMutation{
		config:        c,
		op:            op,
		typ:           TypeFeatureFlagVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeatureFlagVersionID sets the ID field of the mutation.
func withFeatureFlagVersionID(id int) featureflagversionOption {
	return func(m *FeatureFlagVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *FeatureFlagVersion
		)
		m.oldValue = func(ctx context.Context) (*FeatureFlagVersion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FeatureFlagVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeatureFlagVersion sets the old FeatureFlagVersion of the mutation.
func withFeatureFlagVersion(node *FeatureFlagVersion) featureflagversionOption {
	return func(m *FeatureFlagVersionMutation) {
		m.oldValue = func(context.Context) (*FeatureFlagVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeatureFlagVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeatureFlagVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeatureFlagVersionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeatureFlagVersionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FeatureFlagVersion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWorkflowType sets the "workflow_type" field.
func (m *FeatureFlagVersionMutation) SetWorkflowType(s string) {
	m.workflow_type = &s
}

// WorkflowType returns the value of the "workflow_type" field in the mutation.
func (m *FeatureFlagVersionMutation) WorkflowType() (r string, exists bool) {
	v := m.workflow_type
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowType returns the old "workflow_type" field's value of the FeatureFlagVersion entity.
// If the FeatureFlagVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureFlagVersionMutation) OldWorkflowType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowType: %w", err)
	}
	return oldValue.WorkflowType, nil
}

// ResetWorkflowType resets all changes to the "workflow_type" field.
func (m *FeatureFlagVersionMutation) ResetWorkflowType() {
	m.workflow_type = nil
}

// SetWorkflowID sets the "workflow_id" field.
func (m *FeatureFlagVersionMutation) SetWorkflowID(s string) {
	m.workflow_id = &s
}

// WorkflowID returns the value of the "workflow_id" field in the mutation.
func (m *FeatureFlagVersionMutation) WorkflowID() (r string, exists bool) {
	v := m.workflow_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowID returns the old "workflow_id" field's value of the FeatureFlagVersion entity.
// If the FeatureFlagVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureFlagVersionMutation) OldWorkflowID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowID: %w", err)
	}
	return oldValue.WorkflowID, nil
}

// ResetWorkflowID resets all changes to the "workflow_id" field.
func (m *FeatureFlagVersionMutation) ResetWorkflowID() {
	m.workflow_id = nil
}

// SetChangeID sets the "change_id" field.
func (m *FeatureFlagVersionMutation) SetChangeID(s string) {
	m.change_id = &s
}

// ChangeID returns the value of the "change_id" field in the mutation.
func (m *FeatureFlagVersionMutation) ChangeID() (r string, exists bool) {
	v := m.change_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChangeID returns the old "change_id" field's value of the FeatureFlagVersion entity.
// If the FeatureFlagVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureFlagVersionMutation) OldChangeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChangeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChangeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChangeID: %w", err)
	}
	return oldValue.ChangeID, nil
}

// ResetChangeID resets all changes to the "change_id" field.
func (m *FeatureFlagVersionMutation) ResetChangeID() {
	m.change_id = nil
}

// SetVersion sets the "version" field.
func (m *FeatureFlagVersionMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *FeatureFlagVersionMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the FeatureFlagVersion entity.
// If the FeatureFlagVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureFlagVersionMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *FeatureFlagVersionMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *FeatureFlagVersionMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *FeatureFlagVersionMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// Where appends a list predicates to the FeatureFlagVersionMutation builder.
func (m *FeatureFlagVersionMutation) Where(ps ...predicate.FeatureFlagVersion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeatureFlagVersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeatureFlagVersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FeatureFlagVersion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeatureFlagVersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeatureFlagVersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FeatureFlagVersion).
func (m *FeatureFlagVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeatureFlagVersionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.workflow_type != nil {
		fields = append(fields, featureflagversion.FieldWorkflowType)
	}
	if m.workflow_id != nil {
		fields = append(fields, featureflagversion.FieldWorkflowID)
	}
	if m.change_id != nil {
		fields = append(fields, featureflagversion.FieldChangeID)
	}
	if m.version != nil {
		fields = append(fields, featureflagversion.FieldVersion)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeatureFlagVersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case featureflagversion.FieldWorkflowType:
		return m.WorkflowType()
	case featureflagversion.FieldWorkflowID:
		return m.WorkflowID()
	case featureflagversion.FieldChangeID:
		return m.ChangeID()
	case featureflagversion.FieldVersion:
		return m.Version()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeatureFlagVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case featureflagversion.FieldWorkflowType:
		return m.OldWorkflowType(ctx)
	case featureflagversion.FieldWorkflowID:
		return m.OldWorkflowID(ctx)
	case featureflagversion.FieldChangeID:
		return m.OldChangeID(ctx)
	case featureflagversion.FieldVersion:
		return m.OldVersion(ctx)
	}
	return nil, fmt.Errorf("unknown FeatureFlagVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureFlagVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case featureflagversion.FieldWorkflowType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowType(v)
		return nil
	case featureflagversion.FieldWorkflowID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowID(v)
		return nil
	case featureflagversion.FieldChangeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChangeID(v)
		return nil
	case featureflagversion.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	}
	return fmt.Errorf("unknown FeatureFlagVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeatureFlagVersionMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, featureflagversion.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeatureFlagVersionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case featureflagversion.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureFlagVersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case featureflagversion.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown FeatureFlagVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeatureFlagVersionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeatureFlagVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeatureFlagVersionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FeatureFlagVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeatureFlagVersionMutation) ResetField(name string) error {
	switch name {
	case featureflagversion.FieldWorkflowType:
		m.ResetWorkflowType()
		return nil
	case featureflagversion.FieldWorkflowID:
		m.ResetWorkflowID()
		return nil
	case featureflagversion.FieldChangeID:
		m.ResetChangeID()
		return nil
	case featureflagversion.FieldVersion:
		m.ResetVersion()
		return nil
	}
	return fmt.Errorf("unknown FeatureFlagVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeatureFlagVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeatureFlagVersionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeatureFlagVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeatureFlagVersionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeatureFlagVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeatureFlagVersionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeatureFlagVersionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FeatureFlagVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeatureFlagVersionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FeatureFlagVersion edge %s", name)
}

// RunMutation represents an operation that mutates the Run nodes in the graph.
type RunMutation struct {
	config
	op              Op
	typ             string
	id              *string
	run_id          *string
	_type           *run.Type
	created_at      *time.Time
	clearedFields   map[string]struct{}
	workflow        *string
	clearedworkflow bool
	activity        *string
	clearedactivity bool
	done            bool
	oldValue        func(context.Context) (*Run, error)
	predicates      []predicate.Run
}

var _ ent.Mutation = (*RunMutation)(nil)

// runOption allows management of the mutation configuration using functional options.
type runOption func(*RunMutation)

// newRunMutation creates new mutation for the Run entity.
func newRunMutation(c config, op Op, opts ...runOption) *RunMutation {
	m := &RunMutation{
		config:        c,
		op:            op,
		typ:           TypeRun,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRunID sets the ID field of the mutation.
func withRunID(id string) runOption {
	return func(m *RunMutation) {
		var (
			err   error
			once  sync.Once
			value *Run
		)
		m.oldValue = func(ctx context.Context) (*Run, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Run.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRun sets the old Run of the mutation.
func withRun(node *Run) runOption {
	return func(m *RunMutation) {
		m.oldValue = func(context.Context) (*Run, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RunMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RunMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Run entities.
func (m *RunMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RunMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RunMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Run.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRunID sets the "run_id" field.
func (m *RunMutation) SetRunID(s string) {
	m.run_id = &s
}

// RunID returns the value of the "run_id" field in the mutation.
func (m *RunMutation) RunID() (r string, exists bool) {
	v := m.run_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRunID returns the old "run_id" field's value of the Run entity.
// If the Run object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunMutation) OldRunID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunID: %w", err)
	}
	return oldValue.RunID, nil
}

// ResetRunID resets all changes to the "run_id" field.
func (m *RunMutation) ResetRunID() {
	m.run_id = nil
}

// SetType sets the "type" field.
func (m *RunMutation) SetType(r run.Type) {
	m._type = &r
}

// GetType returns the value of the "type" field in the mutation.
func (m *RunMutation) GetType() (r run.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Run entity.
// If the Run object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunMutation) OldType(ctx context.Context) (v run.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *RunMutation) ResetType() {
	m._type = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RunMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RunMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Run entity.
// If the Run object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RunMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetWorkflowID sets the "workflow" edge to the Workflow entity by id.
func (m *RunMutation) SetWorkflowID(id string) {
	m.workflow = &id
}

// ClearWorkflow clears the "workflow" edge to the Workflow entity.
func (m *RunMutation) ClearWorkflow() {
	m.clearedworkflow = true
}

// WorkflowCleared reports if the "workflow" edge to the Workflow entity was cleared.
func (m *RunMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowID returns the "workflow" edge ID in the mutation.
func (m *RunMutation) WorkflowID() (id string, exists bool) {
	if m.workflow != nil {
		return *m.workflow, true
	}
	return
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *RunMutation) WorkflowIDs() (ids []string) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *RunMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// SetActivityID sets the "activity" edge to the Activity entity by id.
func (m *RunMutation) SetActivityID(id string) {
	m.activity = &id
}

// ClearActivity clears the "activity" edge to the Activity entity.
func (m *RunMutation) ClearActivity() {
	m.clearedactivity = true
}

// ActivityCleared reports if the "activity" edge to the Activity entity was cleared.
func (m *RunMutation) ActivityCleared() bool {
	return m.clearedactivity
}

// ActivityID returns the "activity" edge ID in the mutation.
func (m *RunMutation) ActivityID() (id string, exists bool) {
	if m.activity != nil {
		return *m.activity, true
	}
	return
}

// ActivityIDs returns the "activity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActivityID instead. It exists only for internal usage by the builders.
func (m *RunMutation) ActivityIDs() (ids []string) {
	if id := m.activity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActivity resets all changes to the "activity" edge.
func (m *RunMutation) ResetActivity() {
	m.activity = nil
	m.clearedactivity = false
}

// Where appends a list predicates to the RunMutation builder.
func (m *RunMutation) Where(ps ...predicate.Run) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RunMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RunMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Run, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RunMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RunMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Run).
func (m *RunMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RunMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.run_id != nil {
		fields = append(fields, run.FieldRunID)
	}
	if m._type != nil {
		fields = append(fields, run.FieldType)
	}
	if m.created_at != nil {
		fields = append(fields, run.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RunMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case run.FieldRunID:
		return m.RunID()
	case run.FieldType:
		return m.GetType()
	case run.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RunMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case run.FieldRunID:
		return m.OldRunID(ctx)
	case run.FieldType:
		return m.OldType(ctx)
	case run.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Run field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RunMutation) SetField(name string, value ent.Value) error {
	switch name {
	case run.FieldRunID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunID(v)
		return nil
	case run.FieldType:
		v, ok := value.(run.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case run.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Run field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RunMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RunMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RunMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Run numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RunMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RunMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RunMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Run nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RunMutation) ResetField(name string) error {
	switch name {
	case run.FieldRunID:
		m.ResetRunID()
		return nil
	case run.FieldType:
		m.ResetType()
		return nil
	case run.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Run field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RunMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.workflow != nil {
		edges = append(edges, run.EdgeWorkflow)
	}
	if m.activity != nil {
		edges = append(edges, run.EdgeActivity)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RunMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case run.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	case run.EdgeActivity:
		if id := m.activity; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RunMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RunMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RunMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedworkflow {
		edges = append(edges, run.EdgeWorkflow)
	}
	if m.clearedactivity {
		edges = append(edges, run.EdgeActivity)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RunMutation) EdgeCleared(name string) bool {
	switch name {
	case run.EdgeWorkflow:
		return m.clearedworkflow
	case run.EdgeActivity:
		return m.clearedactivity
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RunMutation) ClearEdge(name string) error {
	switch name {
	case run.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	case run.EdgeActivity:
		m.ClearActivity()
		return nil
	}
	return fmt.Errorf("unknown Run unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RunMutation) ResetEdge(name string) error {
	switch name {
	case run.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	case run.EdgeActivity:
		m.ResetActivity()
		return nil
	}
	return fmt.Errorf("unknown Run edge %s", name)
}

// SagaMutation represents an operation that mutates the Saga nodes in the graph.
type SagaMutation struct {
	config
	op              Op
	typ             string
	id              *string
	run_id          *string
	step_id         *string
	status          *saga.Status
	queue_name      *string
	saga_definition *schema.SagaDefinitionData
	error           *string
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	steps           map[string]struct{}
	removedsteps    map[string]struct{}
	clearedsteps    bool
	done            bool
	oldValue        func(context.Context) (*Saga, error)
	predicates      []predicate.Saga
}

var _ ent.Mutation = (*SagaMutation)(nil)

// sagaOption allows management of the mutation configuration using functional options.
type sagaOption func(*SagaMutation)

// newSagaMutation creates new mutation for the Saga entity.
func newSagaMutation(c config, op Op, opts ...sagaOption) *SagaMutation {
	m := &SagaMutation{
		config:        c,
		op:            op,
		typ:           TypeSaga,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSagaID sets the ID field of the mutation.
func withSagaID(id string) sagaOption {
	return func(m *SagaMutation) {
		var (
			err   error
			once  sync.Once
			value *Saga
		)
		m.oldValue = func(ctx context.Context) (*Saga, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Saga.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSaga sets the old Saga of the mutation.
func withSaga(node *Saga) sagaOption {
	return func(m *SagaMutation) {
		m.oldValue = func(context.Context) (*Saga, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SagaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SagaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Saga entities.
func (m *SagaMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SagaMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SagaMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Saga.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRunID sets the "run_id" field.
func (m *SagaMutation) SetRunID(s string) {
	m.run_id = &s
}

// RunID returns the value of the "run_id" field in the mutation.
func (m *SagaMutation) RunID() (r string, exists bool) {
	v := m.run_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRunID returns the old "run_id" field's value of the Saga entity.
// If the Saga object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaMutation) OldRunID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunID: %w", err)
	}
	return oldValue.RunID, nil
}

// ResetRunID resets all changes to the "run_id" field.
func (m *SagaMutation) ResetRunID() {
	m.run_id = nil
}

// SetStepID sets the "step_id" field.
func (m *SagaMutation) SetStepID(s string) {
	m.step_id = &s
}

// StepID returns the value of the "step_id" field in the mutation.
func (m *SagaMutation) StepID() (r string, exists bool) {
	v := m.step_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStepID returns the old "step_id" field's value of the Saga entity.
// If the Saga object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaMutation) OldStepID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStepID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStepID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStepID: %w", err)
	}
	return oldValue.StepID, nil
}

// ResetStepID resets all changes to the "step_id" field.
func (m *SagaMutation) ResetStepID() {
	m.step_id = nil
}

// SetStatus sets the "status" field.
func (m *SagaMutation) SetStatus(s saga.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SagaMutation) Status() (r saga.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Saga entity.
// If the Saga object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaMutation) OldStatus(ctx context.Context) (v saga.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SagaMutation) ResetStatus() {
	m.status = nil
}

// SetQueueName sets the "queue_name" field.
func (m *SagaMutation) SetQueueName(s string) {
	m.queue_name = &s
}

// QueueName returns the value of the "queue_name" field in the mutation.
func (m *SagaMutation) QueueName() (r string, exists bool) {
	v := m.queue_name
	if v == nil {
		return
	}
	return *v, true
}

// OldQueueName returns the old "queue_name" field's value of the Saga entity.
// If the Saga object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaMutation) OldQueueName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQueueName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQueueName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQueueName: %w", err)
	}
	return oldValue.QueueName, nil
}

// ResetQueueName resets all changes to the "queue_name" field.
func (m *SagaMutation) ResetQueueName() {
	m.queue_name = nil
}

// SetSagaDefinition sets the "saga_definition" field.
func (m *SagaMutation) SetSagaDefinition(sdd schema.SagaDefinitionData) {
	m.saga_definition = &sdd
}

// SagaDefinition returns the value of the "saga_definition" field in the mutation.
func (m *SagaMutation) SagaDefinition() (r schema.SagaDefinitionData, exists bool) {
	v := m.saga_definition
	if v == nil {
		return
	}
	return *v, true
}

// OldSagaDefinition returns the old "saga_definition" field's value of the Saga entity.
// If the Saga object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaMutation) OldSagaDefinition(ctx context.Context) (v schema.SagaDefinitionData, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSagaDefinition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSagaDefinition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSagaDefinition: %w", err)
	}
	return oldValue.SagaDefinition, nil
}

// ResetSagaDefinition resets all changes to the "saga_definition" field.
func (m *SagaMutation) ResetSagaDefinition() {
	m.saga_definition = nil
}

// SetError sets the "error" field.
func (m *SagaMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *SagaMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the Saga entity.
// If the Saga object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *SagaMutation) ClearError() {
	m.error = nil
	m.clearedFields[saga.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *SagaMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[saga.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *SagaMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, saga.FieldError)
}

// SetCreatedAt sets the "created_at" field.
func (m *SagaMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SagaMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Saga entity.
// If the Saga object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SagaMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SagaMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SagaMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Saga entity.
// If the Saga object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SagaMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddStepIDs adds the "steps" edge to the SagaExecution entity by ids.
func (m *SagaMutation) AddStepIDs(ids ...string) {
	if m.steps == nil {
		m.steps = make(map[string]struct{})
	}
	for i := range ids {
		m.steps[ids[i]] = struct{}{}
	}
}

// ClearSteps clears the "steps" edge to the SagaExecution entity.
func (m *SagaMutation) ClearSteps() {
	m.clearedsteps = true
}

// StepsCleared reports if the "steps" edge to the SagaExecution entity was cleared.
func (m *SagaMutation) StepsCleared() bool {
	return m.clearedsteps
}

// RemoveStepIDs removes the "steps" edge to the SagaExecution entity by IDs.
func (m *SagaMutation) RemoveStepIDs(ids ...string) {
	if m.removedsteps == nil {
		m.removedsteps = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.steps, ids[i])
		m.removedsteps[ids[i]] = struct{}{}
	}
}

// RemovedSteps returns the removed IDs of the "steps" edge to the SagaExecution entity.
func (m *SagaMutation) RemovedStepsIDs() (ids []string) {
	for id := range m.removedsteps {
		ids = append(ids, id)
	}
	return
}

// StepsIDs returns the "steps" edge IDs in the mutation.
func (m *SagaMutation) StepsIDs() (ids []string) {
	for id := range m.steps {
		ids = append(ids, id)
	}
	return
}

// ResetSteps resets all changes to the "steps" edge.
func (m *SagaMutation) ResetSteps() {
	m.steps = nil
	m.clearedsteps = false
	m.removedsteps = nil
}

// Where appends a list predicates to the SagaMutation builder.
func (m *SagaMutation) Where(ps ...predicate.Saga) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SagaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SagaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Saga, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SagaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SagaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Saga).
func (m *SagaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SagaMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.run_id != nil {
		fields = append(fields, saga.FieldRunID)
	}
	if m.step_id != nil {
		fields = append(fields, saga.FieldStepID)
	}
	if m.status != nil {
		fields = append(fields, saga.FieldStatus)
	}
	if m.queue_name != nil {
		fields = append(fields, saga.FieldQueueName)
	}
	if m.saga_definition != nil {
		fields = append(fields, saga.FieldSagaDefinition)
	}
	if m.error != nil {
		fields = append(fields, saga.FieldError)
	}
	if m.created_at != nil {
		fields = append(fields, saga.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, saga.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SagaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case saga.FieldRunID:
		return m.RunID()
	case saga.FieldStepID:
		return m.StepID()
	case saga.FieldStatus:
		return m.Status()
	case saga.FieldQueueName:
		return m.QueueName()
	case saga.FieldSagaDefinition:
		return m.SagaDefinition()
	case saga.FieldError:
		return m.Error()
	case saga.FieldCreatedAt:
		return m.CreatedAt()
	case saga.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SagaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case saga.FieldRunID:
		return m.OldRunID(ctx)
	case saga.FieldStepID:
		return m.OldStepID(ctx)
	case saga.FieldStatus:
		return m.OldStatus(ctx)
	case saga.FieldQueueName:
		return m.OldQueueName(ctx)
	case saga.FieldSagaDefinition:
		return m.OldSagaDefinition(ctx)
	case saga.FieldError:
		return m.OldError(ctx)
	case saga.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case saga.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Saga field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SagaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case saga.FieldRunID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunID(v)
		return nil
	case saga.FieldStepID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStepID(v)
		return nil
	case saga.FieldStatus:
		v, ok := value.(saga.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case saga.FieldQueueName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQueueName(v)
		return nil
	case saga.FieldSagaDefinition:
		v, ok := value.(schema.SagaDefinitionData)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSagaDefinition(v)
		return nil
	case saga.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case saga.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case saga.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Saga field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SagaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SagaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SagaMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Saga numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SagaMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(saga.FieldError) {
		fields = append(fields, saga.FieldError)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SagaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SagaMutation) ClearField(name string) error {
	switch name {
	case saga.FieldError:
		m.ClearError()
		return nil
	}
	return fmt.Errorf("unknown Saga nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SagaMutation) ResetField(name string) error {
	switch name {
	case saga.FieldRunID:
		m.ResetRunID()
		return nil
	case saga.FieldStepID:
		m.ResetStepID()
		return nil
	case saga.FieldStatus:
		m.ResetStatus()
		return nil
	case saga.FieldQueueName:
		m.ResetQueueName()
		return nil
	case saga.FieldSagaDefinition:
		m.ResetSagaDefinition()
		return nil
	case saga.FieldError:
		m.ResetError()
		return nil
	case saga.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case saga.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Saga field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SagaMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.steps != nil {
		edges = append(edges, saga.EdgeSteps)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SagaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case saga.EdgeSteps:
		ids := make([]ent.Value, 0, len(m.steps))
		for id := range m.steps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SagaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedsteps != nil {
		edges = append(edges, saga.EdgeSteps)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SagaMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case saga.EdgeSteps:
		ids := make([]ent.Value, 0, len(m.removedsteps))
		for id := range m.removedsteps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SagaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsteps {
		edges = append(edges, saga.EdgeSteps)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SagaMutation) EdgeCleared(name string) bool {
	switch name {
	case saga.EdgeSteps:
		return m.clearedsteps
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SagaMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Saga unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SagaMutation) ResetEdge(name string) error {
	switch name {
	case saga.EdgeSteps:
		m.ResetSteps()
		return nil
	}
	return fmt.Errorf("unknown Saga edge %s", name)
}

// SagaExecutionMutation represents an operation that mutates the SagaExecution nodes in the graph.
type SagaExecutionMutation struct {
	config
	op            Op
	typ           string
	id            *string
	handler_name  *string
	step_type     *sagaexecution.StepType
	status        *sagaexecution.Status
	queue_name    *string
	sequence      *int
	addsequence   *int
	error         *string
	started_at    *time.Time
	completed_at  *time.Time
	clearedFields map[string]struct{}
	saga          *string
	clearedsaga   bool
	done          bool
	oldValue      func(context.Context) (*SagaExecution, error)
	predicates    []predicate.SagaExecution
}

var _ ent.Mutation = (*SagaExecutionMutation)(nil)

// sagaexecutionOption allows management of the mutation configuration using functional options.
type sagaexecutionOption func(*SagaExecutionMutation)

// newSagaExecutionMutation creates new mutation for the SagaExecution entity.
func newSagaExecutionMutation(c config, op Op, opts ...sagaexecutionOption) *SagaExecutionMutation {
	m := &SagaExecutionMutation{
		config:        c,
		op:            op,
		typ:           TypeSagaExecution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSagaExecutionID sets the ID field of the mutation.
func withSagaExecutionID(id string) sagaexecutionOption {
	return func(m *SagaExecutionMutation) {
		var (
			err   error
			once  sync.Once
			value *SagaExecution
		)
		m.oldValue = func(ctx context.Context) (*SagaExecution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SagaExecution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSagaExecution sets the old SagaExecution of the mutation.
func withSagaExecution(node *SagaExecution) sagaexecutionOption {
	return func(m *SagaExecutionMutation) {
		m.oldValue = func(context.Context) (*SagaExecution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SagaExecutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SagaExecutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SagaExecution entities.
func (m *SagaExecutionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SagaExecutionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SagaExecutionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SagaExecution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHandlerName sets the "handler_name" field.
func (m *SagaExecutionMutation) SetHandlerName(s string) {
	m.handler_name = &s
}

// HandlerName returns the value of the "handler_name" field in the mutation.
func (m *SagaExecutionMutation) HandlerName() (r string, exists bool) {
	v := m.handler_name
	if v == nil {
		return
	}
	return *v, true
}

// OldHandlerName returns the old "handler_name" field's value of the SagaExecution entity.
// If the SagaExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaExecutionMutation) OldHandlerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandlerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandlerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandlerName: %w", err)
	}
	return oldValue.HandlerName, nil
}

// ResetHandlerName resets all changes to the "handler_name" field.
func (m *SagaExecutionMutation) ResetHandlerName() {
	m.handler_name = nil
}

// SetStepType sets the "step_type" field.
func (m *SagaExecutionMutation) SetStepType(st sagaexecution.StepType) {
	m.step_type = &st
}

// StepType returns the value of the "step_type" field in the mutation.
func (m *SagaExecutionMutation) StepType() (r sagaexecution.StepType, exists bool) {
	v := m.step_type
	if v == nil {
		return
	}
	return *v, true
}

// OldStepType returns the old "step_type" field's value of the SagaExecution entity.
// If the SagaExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaExecutionMutation) OldStepType(ctx context.Context) (v sagaexecution.StepType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStepType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStepType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStepType: %w", err)
	}
	return oldValue.StepType, nil
}

// ResetStepType resets all changes to the "step_type" field.
func (m *SagaExecutionMutation) ResetStepType() {
	m.step_type = nil
}

// SetStatus sets the "status" field.
func (m *SagaExecutionMutation) SetStatus(s sagaexecution.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SagaExecutionMutation) Status() (r sagaexecution.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SagaExecution entity.
// If the SagaExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaExecutionMutation) OldStatus(ctx context.Context) (v sagaexecution.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SagaExecutionMutation) ResetStatus() {
	m.status = nil
}

// SetQueueName sets the "queue_name" field.
func (m *SagaExecutionMutation) SetQueueName(s string) {
	m.queue_name = &s
}

// QueueName returns the value of the "queue_name" field in the mutation.
func (m *SagaExecutionMutation) QueueName() (r string, exists bool) {
	v := m.queue_name
	if v == nil {
		return
	}
	return *v, true
}

// OldQueueName returns the old "queue_name" field's value of the SagaExecution entity.
// If the SagaExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaExecutionMutation) OldQueueName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQueueName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQueueName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQueueName: %w", err)
	}
	return oldValue.QueueName, nil
}

// ResetQueueName resets all changes to the "queue_name" field.
func (m *SagaExecutionMutation) ResetQueueName() {
	m.queue_name = nil
}

// SetSequence sets the "sequence" field.
func (m *SagaExecutionMutation) SetSequence(i int) {
	m.sequence = &i
	m.addsequence = nil
}

// Sequence returns the value of the "sequence" field in the mutation.
func (m *SagaExecutionMutation) Sequence() (r int, exists bool) {
	v := m.sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldSequence returns the old "sequence" field's value of the SagaExecution entity.
// If the SagaExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaExecutionMutation) OldSequence(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSequence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequence: %w", err)
	}
	return oldValue.Sequence, nil
}

// AddSequence adds i to the "sequence" field.
func (m *SagaExecutionMutation) AddSequence(i int) {
	if m.addsequence != nil {
		*m.addsequence += i
	} else {
		m.addsequence = &i
	}
}

// AddedSequence returns the value that was added to the "sequence" field in this mutation.
func (m *SagaExecutionMutation) AddedSequence() (r int, exists bool) {
	v := m.addsequence
	if v == nil {
		return
	}
	return *v, true
}

// ResetSequence resets all changes to the "sequence" field.
func (m *SagaExecutionMutation) ResetSequence() {
	m.sequence = nil
	m.addsequence = nil
}

// SetError sets the "error" field.
func (m *SagaExecutionMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *SagaExecutionMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the SagaExecution entity.
// If the SagaExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaExecutionMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *SagaExecutionMutation) ClearError() {
	m.error = nil
	m.clearedFields[sagaexecution.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *SagaExecutionMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[sagaexecution.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *SagaExecutionMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, sagaexecution.FieldError)
}

// SetStartedAt sets the "started_at" field.
func (m *SagaExecutionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *SagaExecutionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the SagaExecution entity.
// If the SagaExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaExecutionMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *SagaExecutionMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetCompletedAt sets the "completed_at" field.
func (m *SagaExecutionMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *SagaExecutionMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the SagaExecution entity.
// If the SagaExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaExecutionMutation) OldCompletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *SagaExecutionMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[sagaexecution.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *SagaExecutionMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[sagaexecution.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *SagaExecutionMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, sagaexecution.FieldCompletedAt)
}

// SetSagaID sets the "saga" edge to the Saga entity by id.
func (m *SagaExecutionMutation) SetSagaID(id string) {
	m.saga = &id
}

// ClearSaga clears the "saga" edge to the Saga entity.
func (m *SagaExecutionMutation) ClearSaga() {
	m.clearedsaga = true
}

// SagaCleared reports if the "saga" edge to the Saga entity was cleared.
func (m *SagaExecutionMutation) SagaCleared() bool {
	return m.clearedsaga
}

// SagaID returns the "saga" edge ID in the mutation.
func (m *SagaExecutionMutation) SagaID() (id string, exists bool) {
	if m.saga != nil {
		return *m.saga, true
	}
	return
}

// SagaIDs returns the "saga" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SagaID instead. It exists only for internal usage by the builders.
func (m *SagaExecutionMutation) SagaIDs() (ids []string) {
	if id := m.saga; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSaga resets all changes to the "saga" edge.
func (m *SagaExecutionMutation) ResetSaga() {
	m.saga = nil
	m.clearedsaga = false
}

// Where appends a list predicates to the SagaExecutionMutation builder.
func (m *SagaExecutionMutation) Where(ps ...predicate.SagaExecution) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SagaExecutionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SagaExecutionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SagaExecution, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SagaExecutionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SagaExecutionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SagaExecution).
func (m *SagaExecutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SagaExecutionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.handler_name != nil {
		fields = append(fields, sagaexecution.FieldHandlerName)
	}
	if m.step_type != nil {
		fields = append(fields, sagaexecution.FieldStepType)
	}
	if m.status != nil {
		fields = append(fields, sagaexecution.FieldStatus)
	}
	if m.queue_name != nil {
		fields = append(fields, sagaexecution.FieldQueueName)
	}
	if m.sequence != nil {
		fields = append(fields, sagaexecution.FieldSequence)
	}
	if m.error != nil {
		fields = append(fields, sagaexecution.FieldError)
	}
	if m.started_at != nil {
		fields = append(fields, sagaexecution.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, sagaexecution.FieldCompletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SagaExecutionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sagaexecution.FieldHandlerName:
		return m.HandlerName()
	case sagaexecution.FieldStepType:
		return m.StepType()
	case sagaexecution.FieldStatus:
		return m.Status()
	case sagaexecution.FieldQueueName:
		return m.QueueName()
	case sagaexecution.FieldSequence:
		return m.Sequence()
	case sagaexecution.FieldError:
		return m.Error()
	case sagaexecution.FieldStartedAt:
		return m.StartedAt()
	case sagaexecution.FieldCompletedAt:
		return m.CompletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SagaExecutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sagaexecution.FieldHandlerName:
		return m.OldHandlerName(ctx)
	case sagaexecution.FieldStepType:
		return m.OldStepType(ctx)
	case sagaexecution.FieldStatus:
		return m.OldStatus(ctx)
	case sagaexecution.FieldQueueName:
		return m.OldQueueName(ctx)
	case sagaexecution.FieldSequence:
		return m.OldSequence(ctx)
	case sagaexecution.FieldError:
		return m.OldError(ctx)
	case sagaexecution.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case sagaexecution.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SagaExecution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SagaExecutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sagaexecution.FieldHandlerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandlerName(v)
		return nil
	case sagaexecution.FieldStepType:
		v, ok := value.(sagaexecution.StepType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStepType(v)
		return nil
	case sagaexecution.FieldStatus:
		v, ok := value.(sagaexecution.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case sagaexecution.FieldQueueName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQueueName(v)
		return nil
	case sagaexecution.FieldSequence:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequence(v)
		return nil
	case sagaexecution.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case sagaexecution.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case sagaexecution.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SagaExecution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SagaExecutionMutation) AddedFields() []string {
	var fields []string
	if m.addsequence != nil {
		fields = append(fields, sagaexecution.FieldSequence)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SagaExecutionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sagaexecution.FieldSequence:
		return m.AddedSequence()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SagaExecutionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sagaexecution.FieldSequence:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequence(v)
		return nil
	}
	return fmt.Errorf("unknown SagaExecution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SagaExecutionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sagaexecution.FieldError) {
		fields = append(fields, sagaexecution.FieldError)
	}
	if m.FieldCleared(sagaexecution.FieldCompletedAt) {
		fields = append(fields, sagaexecution.FieldCompletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SagaExecutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SagaExecutionMutation) ClearField(name string) error {
	switch name {
	case sagaexecution.FieldError:
		m.ClearError()
		return nil
	case sagaexecution.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown SagaExecution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SagaExecutionMutation) ResetField(name string) error {
	switch name {
	case sagaexecution.FieldHandlerName:
		m.ResetHandlerName()
		return nil
	case sagaexecution.FieldStepType:
		m.ResetStepType()
		return nil
	case sagaexecution.FieldStatus:
		m.ResetStatus()
		return nil
	case sagaexecution.FieldQueueName:
		m.ResetQueueName()
		return nil
	case sagaexecution.FieldSequence:
		m.ResetSequence()
		return nil
	case sagaexecution.FieldError:
		m.ResetError()
		return nil
	case sagaexecution.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case sagaexecution.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown SagaExecution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SagaExecutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.saga != nil {
		edges = append(edges, sagaexecution.EdgeSaga)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SagaExecutionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sagaexecution.EdgeSaga:
		if id := m.saga; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SagaExecutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SagaExecutionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SagaExecutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsaga {
		edges = append(edges, sagaexecution.EdgeSaga)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SagaExecutionMutation) EdgeCleared(name string) bool {
	switch name {
	case sagaexecution.EdgeSaga:
		return m.clearedsaga
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SagaExecutionMutation) ClearEdge(name string) error {
	switch name {
	case sagaexecution.EdgeSaga:
		m.ClearSaga()
		return nil
	}
	return fmt.Errorf("unknown SagaExecution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SagaExecutionMutation) ResetEdge(name string) error {
	switch name {
	case sagaexecution.EdgeSaga:
		m.ResetSaga()
		return nil
	}
	return fmt.Errorf("unknown SagaExecution edge %s", name)
}

// SideEffectMutation represents an operation that mutates the SideEffect nodes in the graph.
type SideEffectMutation struct {
	config
	op                Op
	typ               string
	id                *string
	identity          *string
	step_id           *string
	handler_name      *string
	status            *sideeffect.Status
	queue_name        *string
	retry_policy      *schema.RetryPolicy
	timeout           *time.Time
	created_at        *time.Time
	clearedFields     map[string]struct{}
	executions        map[string]struct{}
	removedexecutions map[string]struct{}
	clearedexecutions bool
	done              bool
	oldValue          func(context.Context) (*SideEffect, error)
	predicates        []predicate.SideEffect
}

var _ ent.Mutation = (*SideEffectMutation)(nil)

// sideeffectOption allows management of the mutation configuration using functional options.
type sideeffectOption func(*SideEffectMutation)

// newSideEffectMutation creates new mutation for the SideEffect entity.
func newSideEffectMutation(c config, op Op, opts ...sideeffectOption) *SideEffectMutation {
	m := &SideEffectMutation{
		config:        c,
		op:            op,
		typ:           TypeSideEffect,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSideEffectID sets the ID field of the mutation.
func withSideEffectID(id string) sideeffectOption {
	return func(m *SideEffectMutation) {
		var (
			err   error
			once  sync.Once
			value *SideEffect
		)
		m.oldValue = func(ctx context.Context) (*SideEffect, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SideEffect.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSideEffect sets the old SideEffect of the mutation.
func withSideEffect(node *SideEffect) sideeffectOption {
	return func(m *SideEffectMutation) {
		m.oldValue = func(context.Context) (*SideEffect, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SideEffectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SideEffectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SideEffect entities.
func (m *SideEffectMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SideEffectMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SideEffectMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SideEffect.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIdentity sets the "identity" field.
func (m *SideEffectMutation) SetIdentity(s string) {
	m.identity = &s
}

// Identity returns the value of the "identity" field in the mutation.
func (m *SideEffectMutation) Identity() (r string, exists bool) {
	v := m.identity
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentity returns the old "identity" field's value of the SideEffect entity.
// If the SideEffect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectMutation) OldIdentity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentity: %w", err)
	}
	return oldValue.Identity, nil
}

// ResetIdentity resets all changes to the "identity" field.
func (m *SideEffectMutation) ResetIdentity() {
	m.identity = nil
}

// SetStepID sets the "step_id" field.
func (m *SideEffectMutation) SetStepID(s string) {
	m.step_id = &s
}

// StepID returns the value of the "step_id" field in the mutation.
func (m *SideEffectMutation) StepID() (r string, exists bool) {
	v := m.step_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStepID returns the old "step_id" field's value of the SideEffect entity.
// If the SideEffect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectMutation) OldStepID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStepID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStepID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStepID: %w", err)
	}
	return oldValue.StepID, nil
}

// ResetStepID resets all changes to the "step_id" field.
func (m *SideEffectMutation) ResetStepID() {
	m.step_id = nil
}

// SetHandlerName sets the "handler_name" field.
func (m *SideEffectMutation) SetHandlerName(s string) {
	m.handler_name = &s
}

// HandlerName returns the value of the "handler_name" field in the mutation.
func (m *SideEffectMutation) HandlerName() (r string, exists bool) {
	v := m.handler_name
	if v == nil {
		return
	}
	return *v, true
}

// OldHandlerName returns the old "handler_name" field's value of the SideEffect entity.
// If the SideEffect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectMutation) OldHandlerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandlerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandlerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandlerName: %w", err)
	}
	return oldValue.HandlerName, nil
}

// ResetHandlerName resets all changes to the "handler_name" field.
func (m *SideEffectMutation) ResetHandlerName() {
	m.handler_name = nil
}

// SetStatus sets the "status" field.
func (m *SideEffectMutation) SetStatus(s sideeffect.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SideEffectMutation) Status() (r sideeffect.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SideEffect entity.
// If the SideEffect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectMutation) OldStatus(ctx context.Context) (v sideeffect.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SideEffectMutation) ResetStatus() {
	m.status = nil
}

// SetQueueName sets the "queue_name" field.
func (m *SideEffectMutation) SetQueueName(s string) {
	m.queue_name = &s
}

// QueueName returns the value of the "queue_name" field in the mutation.
func (m *SideEffectMutation) QueueName() (r string, exists bool) {
	v := m.queue_name
	if v == nil {
		return
	}
	return *v, true
}

// OldQueueName returns the old "queue_name" field's value of the SideEffect entity.
// If the SideEffect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectMutation) OldQueueName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQueueName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQueueName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQueueName: %w", err)
	}
	return oldValue.QueueName, nil
}

// ResetQueueName resets all changes to the "queue_name" field.
func (m *SideEffectMutation) ResetQueueName() {
	m.queue_name = nil
}

// SetRetryPolicy sets the "retry_policy" field.
func (m *SideEffectMutation) SetRetryPolicy(sp schema.RetryPolicy) {
	m.retry_policy = &sp
}

// RetryPolicy returns the value of the "retry_policy" field in the mutation.
func (m *SideEffectMutation) RetryPolicy() (r schema.RetryPolicy, exists bool) {
	v := m.retry_policy
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryPolicy returns the old "retry_policy" field's value of the SideEffect entity.
// If the SideEffect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectMutation) OldRetryPolicy(ctx context.Context) (v schema.RetryPolicy, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryPolicy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryPolicy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryPolicy: %w", err)
	}
	return oldValue.RetryPolicy, nil
}

// ClearRetryPolicy clears the value of the "retry_policy" field.
func (m *SideEffectMutation) ClearRetryPolicy() {
	m.retry_policy = nil
	m.clearedFields[sideeffect.FieldRetryPolicy] = struct{}{}
}

// RetryPolicyCleared returns if the "retry_policy" field was cleared in this mutation.
func (m *SideEffectMutation) RetryPolicyCleared() bool {
	_, ok := m.clearedFields[sideeffect.FieldRetryPolicy]
	return ok
}

// ResetRetryPolicy resets all changes to the "retry_policy" field.
func (m *SideEffectMutation) ResetRetryPolicy() {
	m.retry_policy = nil
	delete(m.clearedFields, sideeffect.FieldRetryPolicy)
}

// SetTimeout sets the "timeout" field.
func (m *SideEffectMutation) SetTimeout(t time.Time) {
	m.timeout = &t
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *SideEffectMutation) Timeout() (r time.Time, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the SideEffect entity.
// If the SideEffect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectMutation) OldTimeout(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// ClearTimeout clears the value of the "timeout" field.
func (m *SideEffectMutation) ClearTimeout() {
	m.timeout = nil
	m.clearedFields[sideeffect.FieldTimeout] = struct{}{}
}

// TimeoutCleared returns if the "timeout" field was cleared in this mutation.
func (m *SideEffectMutation) TimeoutCleared() bool {
	_, ok := m.clearedFields[sideeffect.FieldTimeout]
	return ok
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *SideEffectMutation) ResetTimeout() {
	m.timeout = nil
	delete(m.clearedFields, sideeffect.FieldTimeout)
}

// SetCreatedAt sets the "created_at" field.
func (m *SideEffectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SideEffectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SideEffect entity.
// If the SideEffect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SideEffectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddExecutionIDs adds the "executions" edge to the SideEffectExecution entity by ids.
func (m *SideEffectMutation) AddExecutionIDs(ids ...string) {
	if m.executions == nil {
		m.executions = make(map[string]struct{})
	}
	for i := range ids {
		m.executions[ids[i]] = struct{}{}
	}
}

// ClearExecutions clears the "executions" edge to the SideEffectExecution entity.
func (m *SideEffectMutation) ClearExecutions() {
	m.clearedexecutions = true
}

// ExecutionsCleared reports if the "executions" edge to the SideEffectExecution entity was cleared.
func (m *SideEffectMutation) ExecutionsCleared() bool {
	return m.clearedexecutions
}

// RemoveExecutionIDs removes the "executions" edge to the SideEffectExecution entity by IDs.
func (m *SideEffectMutation) RemoveExecutionIDs(ids ...string) {
	if m.removedexecutions == nil {
		m.removedexecutions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.executions, ids[i])
		m.removedexecutions[ids[i]] = struct{}{}
	}
}

// RemovedExecutions returns the removed IDs of the "executions" edge to the SideEffectExecution entity.
func (m *SideEffectMutation) RemovedExecutionsIDs() (ids []string) {
	for id := range m.removedexecutions {
		ids = append(ids, id)
	}
	return
}

// ExecutionsIDs returns the "executions" edge IDs in the mutation.
func (m *SideEffectMutation) ExecutionsIDs() (ids []string) {
	for id := range m.executions {
		ids = append(ids, id)
	}
	return
}

// ResetExecutions resets all changes to the "executions" edge.
func (m *SideEffectMutation) ResetExecutions() {
	m.executions = nil
	m.clearedexecutions = false
	m.removedexecutions = nil
}

// Where appends a list predicates to the SideEffectMutation builder.
func (m *SideEffectMutation) Where(ps ...predicate.SideEffect) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SideEffectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SideEffectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SideEffect, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SideEffectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SideEffectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SideEffect).
func (m *SideEffectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SideEffectMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.identity != nil {
		fields = append(fields, sideeffect.FieldIdentity)
	}
	if m.step_id != nil {
		fields = append(fields, sideeffect.FieldStepID)
	}
	if m.handler_name != nil {
		fields = append(fields, sideeffect.FieldHandlerName)
	}
	if m.status != nil {
		fields = append(fields, sideeffect.FieldStatus)
	}
	if m.queue_name != nil {
		fields = append(fields, sideeffect.FieldQueueName)
	}
	if m.retry_policy != nil {
		fields = append(fields, sideeffect.FieldRetryPolicy)
	}
	if m.timeout != nil {
		fields = append(fields, sideeffect.FieldTimeout)
	}
	if m.created_at != nil {
		fields = append(fields, sideeffect.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SideEffectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sideeffect.FieldIdentity:
		return m.Identity()
	case sideeffect.FieldStepID:
		return m.StepID()
	case sideeffect.FieldHandlerName:
		return m.HandlerName()
	case sideeffect.FieldStatus:
		return m.Status()
	case sideeffect.FieldQueueName:
		return m.QueueName()
	case sideeffect.FieldRetryPolicy:
		return m.RetryPolicy()
	case sideeffect.FieldTimeout:
		return m.Timeout()
	case sideeffect.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SideEffectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sideeffect.FieldIdentity:
		return m.OldIdentity(ctx)
	case sideeffect.FieldStepID:
		return m.OldStepID(ctx)
	case sideeffect.FieldHandlerName:
		return m.OldHandlerName(ctx)
	case sideeffect.FieldStatus:
		return m.OldStatus(ctx)
	case sideeffect.FieldQueueName:
		return m.OldQueueName(ctx)
	case sideeffect.FieldRetryPolicy:
		return m.OldRetryPolicy(ctx)
	case sideeffect.FieldTimeout:
		return m.OldTimeout(ctx)
	case sideeffect.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SideEffect field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SideEffectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sideeffect.FieldIdentity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentity(v)
		return nil
	case sideeffect.FieldStepID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStepID(v)
		return nil
	case sideeffect.FieldHandlerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandlerName(v)
		return nil
	case sideeffect.FieldStatus:
		v, ok := value.(sideeffect.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case sideeffect.FieldQueueName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQueueName(v)
		return nil
	case sideeffect.FieldRetryPolicy:
		v, ok := value.(schema.RetryPolicy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryPolicy(v)
		return nil
	case sideeffect.FieldTimeout:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case sideeffect.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SideEffect field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SideEffectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SideEffectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SideEffectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SideEffect numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SideEffectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sideeffect.FieldRetryPolicy) {
		fields = append(fields, sideeffect.FieldRetryPolicy)
	}
	if m.FieldCleared(sideeffect.FieldTimeout) {
		fields = append(fields, sideeffect.FieldTimeout)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SideEffectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SideEffectMutation) ClearField(name string) error {
	switch name {
	case sideeffect.FieldRetryPolicy:
		m.ClearRetryPolicy()
		return nil
	case sideeffect.FieldTimeout:
		m.ClearTimeout()
		return nil
	}
	return fmt.Errorf("unknown SideEffect nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SideEffectMutation) ResetField(name string) error {
	switch name {
	case sideeffect.FieldIdentity:
		m.ResetIdentity()
		return nil
	case sideeffect.FieldStepID:
		m.ResetStepID()
		return nil
	case sideeffect.FieldHandlerName:
		m.ResetHandlerName()
		return nil
	case sideeffect.FieldStatus:
		m.ResetStatus()
		return nil
	case sideeffect.FieldQueueName:
		m.ResetQueueName()
		return nil
	case sideeffect.FieldRetryPolicy:
		m.ResetRetryPolicy()
		return nil
	case sideeffect.FieldTimeout:
		m.ResetTimeout()
		return nil
	case sideeffect.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown SideEffect field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SideEffectMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.executions != nil {
		edges = append(edges, sideeffect.EdgeExecutions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SideEffectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sideeffect.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.executions))
		for id := range m.executions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SideEffectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedexecutions != nil {
		edges = append(edges, sideeffect.EdgeExecutions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SideEffectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sideeffect.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.removedexecutions))
		for id := range m.removedexecutions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SideEffectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedexecutions {
		edges = append(edges, sideeffect.EdgeExecutions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SideEffectMutation) EdgeCleared(name string) bool {
	switch name {
	case sideeffect.EdgeExecutions:
		return m.clearedexecutions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SideEffectMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown SideEffect unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SideEffectMutation) ResetEdge(name string) error {
	switch name {
	case sideeffect.EdgeExecutions:
		m.ResetExecutions()
		return nil
	}
	return fmt.Errorf("unknown SideEffect edge %s", name)
}

// SideEffectExecutionMutation represents an operation that mutates the SideEffectExecution nodes in the graph.
type SideEffectExecutionMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	status             *sideeffectexecution.Status
	queue_name         *string
	attempt            *int
	addattempt         *int
	output             *[][]uint8
	appendoutput       [][]uint8
	error              *string
	started_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	side_effect        *string
	clearedside_effect bool
	done               bool
	oldValue           func(context.Context) (*SideEffectExecution, error)
	predicates         []predicate.SideEffectExecution
}

var _ ent.Mutation = (*SideEffectExecutionMutation)(nil)

// sideeffectexecutionOption allows management of the mutation configuration using functional options.
type sideeffectexecutionOption func(*SideEffectExecutionMutation)

// newSideEffectExecutionMutation creates new mutation for the SideEffectExecution entity.
func newSideEffectExecutionMutation(c config, op Op, opts ...sideeffectexecutionOption) *SideEffectExecutionMutation {
	m := &SideEffectExecutionMutation{
		config:        c,
		op:            op,
		typ:           TypeSideEffectExecution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSideEffectExecutionID sets the ID field of the mutation.
func withSideEffectExecutionID(id string) sideeffectexecutionOption {
	return func(m *SideEffectExecutionMutation) {
		var (
			err   error
			once  sync.Once
			value *SideEffectExecution
		)
		m.oldValue = func(ctx context.Context) (*SideEffectExecution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SideEffectExecution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSideEffectExecution sets the old SideEffectExecution of the mutation.
func withSideEffectExecution(node *SideEffectExecution) sideeffectexecutionOption {
	return func(m *SideEffectExecutionMutation) {
		m.oldValue = func(context.Context) (*SideEffectExecution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SideEffectExecutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SideEffectExecutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SideEffectExecution entities.
func (m *SideEffectExecutionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SideEffectExecutionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SideEffectExecutionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SideEffectExecution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *SideEffectExecutionMutation) SetStatus(s sideeffectexecution.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SideEffectExecutionMutation) Status() (r sideeffectexecution.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SideEffectExecution entity.
// If the SideEffectExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectExecutionMutation) OldStatus(ctx context.Context) (v sideeffectexecution.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SideEffectExecutionMutation) ResetStatus() {
	m.status = nil
}

// SetQueueName sets the "queue_name" field.
func (m *SideEffectExecutionMutation) SetQueueName(s string) {
	m.queue_name = &s
}

// QueueName returns the value of the "queue_name" field in the mutation.
func (m *SideEffectExecutionMutation) QueueName() (r string, exists bool) {
	v := m.queue_name
	if v == nil {
		return
	}
	return *v, true
}

// OldQueueName returns the old "queue_name" field's value of the SideEffectExecution entity.
// If the SideEffectExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectExecutionMutation) OldQueueName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQueueName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQueueName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQueueName: %w", err)
	}
	return oldValue.QueueName, nil
}

// ResetQueueName resets all changes to the "queue_name" field.
func (m *SideEffectExecutionMutation) ResetQueueName() {
	m.queue_name = nil
}

// SetAttempt sets the "attempt" field.
func (m *SideEffectExecutionMutation) SetAttempt(i int) {
	m.attempt = &i
	m.addattempt = nil
}

// Attempt returns the value of the "attempt" field in the mutation.
func (m *SideEffectExecutionMutation) Attempt() (r int, exists bool) {
	v := m.attempt
	if v == nil {
		return
	}
	return *v, true
}

// OldAttempt returns the old "attempt" field's value of the SideEffectExecution entity.
// If the SideEffectExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectExecutionMutation) OldAttempt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttempt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttempt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttempt: %w", err)
	}
	return oldValue.Attempt, nil
}

// AddAttempt adds i to the "attempt" field.
func (m *SideEffectExecutionMutation) AddAttempt(i int) {
	if m.addattempt != nil {
		*m.addattempt += i
	} else {
		m.addattempt = &i
	}
}

// AddedAttempt returns the value that was added to the "attempt" field in this mutation.
func (m *SideEffectExecutionMutation) AddedAttempt() (r int, exists bool) {
	v := m.addattempt
	if v == nil {
		return
	}
	return *v, true
}

// ResetAttempt resets all changes to the "attempt" field.
func (m *SideEffectExecutionMutation) ResetAttempt() {
	m.attempt = nil
	m.addattempt = nil
}

// SetOutput sets the "output" field.
func (m *SideEffectExecutionMutation) SetOutput(u [][]uint8) {
	m.output = &u
	m.appendoutput = nil
}

// Output returns the value of the "output" field in the mutation.
func (m *SideEffectExecutionMutation) Output() (r [][]uint8, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the SideEffectExecution entity.
// If the SideEffectExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectExecutionMutation) OldOutput(ctx context.Context) (v [][]uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// AppendOutput adds u to the "output" field.
func (m *SideEffectExecutionMutation) AppendOutput(u [][]uint8) {
	m.appendoutput = append(m.appendoutput, u...)
}

// AppendedOutput returns the list of values that were appended to the "output" field in this mutation.
func (m *SideEffectExecutionMutation) AppendedOutput() ([][]uint8, bool) {
	if len(m.appendoutput) == 0 {
		return nil, false
	}
	return m.appendoutput, true
}

// ClearOutput clears the value of the "output" field.
func (m *SideEffectExecutionMutation) ClearOutput() {
	m.output = nil
	m.appendoutput = nil
	m.clearedFields[sideeffectexecution.FieldOutput] = struct{}{}
}

// OutputCleared returns if the "output" field was cleared in this mutation.
func (m *SideEffectExecutionMutation) OutputCleared() bool {
	_, ok := m.clearedFields[sideeffectexecution.FieldOutput]
	return ok
}

// ResetOutput resets all changes to the "output" field.
func (m *SideEffectExecutionMutation) ResetOutput() {
	m.output = nil
	m.appendoutput = nil
	delete(m.clearedFields, sideeffectexecution.FieldOutput)
}

// SetError sets the "error" field.
func (m *SideEffectExecutionMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *SideEffectExecutionMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the SideEffectExecution entity.
// If the SideEffectExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectExecutionMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *SideEffectExecutionMutation) ClearError() {
	m.error = nil
	m.clearedFields[sideeffectexecution.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *SideEffectExecutionMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[sideeffectexecution.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *SideEffectExecutionMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, sideeffectexecution.FieldError)
}

// SetStartedAt sets the "started_at" field.
func (m *SideEffectExecutionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *SideEffectExecutionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the SideEffectExecution entity.
// If the SideEffectExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectExecutionMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *SideEffectExecutionMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SideEffectExecutionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SideEffectExecutionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SideEffectExecution entity.
// If the SideEffectExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectExecutionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SideEffectExecutionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSideEffectID sets the "side_effect" edge to the SideEffect entity by id.
func (m *SideEffectExecutionMutation) SetSideEffectID(id string) {
	m.side_effect = &id
}

// ClearSideEffect clears the "side_effect" edge to the SideEffect entity.
func (m *SideEffectExecutionMutation) ClearSideEffect() {
	m.clearedside_effect = true
}

// SideEffectCleared reports if the "side_effect" edge to the SideEffect entity was cleared.
func (m *SideEffectExecutionMutation) SideEffectCleared() bool {
	return m.clearedside_effect
}

// SideEffectID returns the "side_effect" edge ID in the mutation.
func (m *SideEffectExecutionMutation) SideEffectID() (id string, exists bool) {
	if m.side_effect != nil {
		return *m.side_effect, true
	}
	return
}

// SideEffectIDs returns the "side_effect" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SideEffectID instead. It exists only for internal usage by the builders.
func (m *SideEffectExecutionMutation) SideEffectIDs() (ids []string) {
	if id := m.side_effect; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSideEffect resets all changes to the "side_effect" edge.
func (m *SideEffectExecutionMutation) ResetSideEffect() {
	m.side_effect = nil
	m.clearedside_effect = false
}

// Where appends a list predicates to the SideEffectExecutionMutation builder.
func (m *SideEffectExecutionMutation) Where(ps ...predicate.SideEffectExecution) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SideEffectExecutionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SideEffectExecutionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SideEffectExecution, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SideEffectExecutionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SideEffectExecutionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SideEffectExecution).
func (m *SideEffectExecutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SideEffectExecutionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.status != nil {
		fields = append(fields, sideeffectexecution.FieldStatus)
	}
	if m.queue_name != nil {
		fields = append(fields, sideeffectexecution.FieldQueueName)
	}
	if m.attempt != nil {
		fields = append(fields, sideeffectexecution.FieldAttempt)
	}
	if m.output != nil {
		fields = append(fields, sideeffectexecution.FieldOutput)
	}
	if m.error != nil {
		fields = append(fields, sideeffectexecution.FieldError)
	}
	if m.started_at != nil {
		fields = append(fields, sideeffectexecution.FieldStartedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sideeffectexecution.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SideEffectExecutionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sideeffectexecution.FieldStatus:
		return m.Status()
	case sideeffectexecution.FieldQueueName:
		return m.QueueName()
	case sideeffectexecution.FieldAttempt:
		return m.Attempt()
	case sideeffectexecution.FieldOutput:
		return m.Output()
	case sideeffectexecution.FieldError:
		return m.Error()
	case sideeffectexecution.FieldStartedAt:
		return m.StartedAt()
	case sideeffectexecution.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SideEffectExecutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sideeffectexecution.FieldStatus:
		return m.OldStatus(ctx)
	case sideeffectexecution.FieldQueueName:
		return m.OldQueueName(ctx)
	case sideeffectexecution.FieldAttempt:
		return m.OldAttempt(ctx)
	case sideeffectexecution.FieldOutput:
		return m.OldOutput(ctx)
	case sideeffectexecution.FieldError:
		return m.OldError(ctx)
	case sideeffectexecution.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case sideeffectexecution.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SideEffectExecution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SideEffectExecutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sideeffectexecution.FieldStatus:
		v, ok := value.(sideeffectexecution.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case sideeffectexecution.FieldQueueName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQueueName(v)
		return nil
	case sideeffectexecution.FieldAttempt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttempt(v)
		return nil
	case sideeffectexecution.FieldOutput:
		v, ok := value.([][]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case sideeffectexecution.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case sideeffectexecution.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case sideeffectexecution.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SideEffectExecution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SideEffectExecutionMutation) AddedFields() []string {
	var fields []string
	if m.addattempt != nil {
		fields = append(fields, sideeffectexecution.FieldAttempt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SideEffectExecutionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sideeffectexecution.FieldAttempt:
		return m.AddedAttempt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SideEffectExecutionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sideeffectexecution.FieldAttempt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAttempt(v)
		return nil
	}
	return fmt.Errorf("unknown SideEffectExecution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SideEffectExecutionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sideeffectexecution.FieldOutput) {
		fields = append(fields, sideeffectexecution.FieldOutput)
	}
	if m.FieldCleared(sideeffectexecution.FieldError) {
		fields = append(fields, sideeffectexecution.FieldError)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SideEffectExecutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SideEffectExecutionMutation) ClearField(name string) error {
	switch name {
	case sideeffectexecution.FieldOutput:
		m.ClearOutput()
		return nil
	case sideeffectexecution.FieldError:
		m.ClearError()
		return nil
	}
	return fmt.Errorf("unknown SideEffectExecution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SideEffectExecutionMutation) ResetField(name string) error {
	switch name {
	case sideeffectexecution.FieldStatus:
		m.ResetStatus()
		return nil
	case sideeffectexecution.FieldQueueName:
		m.ResetQueueName()
		return nil
	case sideeffectexecution.FieldAttempt:
		m.ResetAttempt()
		return nil
	case sideeffectexecution.FieldOutput:
		m.ResetOutput()
		return nil
	case sideeffectexecution.FieldError:
		m.ResetError()
		return nil
	case sideeffectexecution.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case sideeffectexecution.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SideEffectExecution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SideEffectExecutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.side_effect != nil {
		edges = append(edges, sideeffectexecution.EdgeSideEffect)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SideEffectExecutionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sideeffectexecution.EdgeSideEffect:
		if id := m.side_effect; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SideEffectExecutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SideEffectExecutionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SideEffectExecutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedside_effect {
		edges = append(edges, sideeffectexecution.EdgeSideEffect)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SideEffectExecutionMutation) EdgeCleared(name string) bool {
	switch name {
	case sideeffectexecution.EdgeSideEffect:
		return m.clearedside_effect
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SideEffectExecutionMutation) ClearEdge(name string) error {
	switch name {
	case sideeffectexecution.EdgeSideEffect:
		m.ClearSideEffect()
		return nil
	}
	return fmt.Errorf("unknown SideEffectExecution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SideEffectExecutionMutation) ResetEdge(name string) error {
	switch name {
	case sideeffectexecution.EdgeSideEffect:
		m.ResetSideEffect()
		return nil
	}
	return fmt.Errorf("unknown SideEffectExecution edge %s", name)
}

// SignalMutation represents an operation that mutates the Signal nodes in the graph.
type SignalMutation struct {
	config
	op                Op
	typ               string
	id                *string
	step_id           *string
	status            *signal.Status
	queue_name        *string
	created_at        *time.Time
	consumed          *bool
	clearedFields     map[string]struct{}
	executions        map[string]struct{}
	removedexecutions map[string]struct{}
	clearedexecutions bool
	done              bool
	oldValue          func(context.Context) (*Signal, error)
	predicates        []predicate.Signal
}

var _ ent.Mutation = (*SignalMutation)(nil)

// signalOption allows management of the mutation configuration using functional options.
type signalOption func(*SignalMutation)

// newSignalMutation creates new mutation for the Signal entity.
func newSignalMutation(c config, op Op, opts ...signalOption) *SignalMutation {
	m := &SignalMutation{
		config:        c,
		op:            op,
		typ:           TypeSignal,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSignalID sets the ID field of the mutation.
func withSignalID(id string) signalOption {
	return func(m *SignalMutation) {
		var (
			err   error
			once  sync.Once
			value *Signal
		)
		m.oldValue = func(ctx context.Context) (*Signal, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Signal.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSignal sets the old Signal of the mutation.
func withSignal(node *Signal) signalOption {
	return func(m *SignalMutation) {
		m.oldValue = func(context.Context) (*Signal, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SignalMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SignalMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Signal entities.
func (m *SignalMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SignalMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SignalMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Signal.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStepID sets the "step_id" field.
func (m *SignalMutation) SetStepID(s string) {
	m.step_id = &s
}

// StepID returns the value of the "step_id" field in the mutation.
func (m *SignalMutation) StepID() (r string, exists bool) {
	v := m.step_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStepID returns the old "step_id" field's value of the Signal entity.
// If the Signal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalMutation) OldStepID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStepID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStepID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStepID: %w", err)
	}
	return oldValue.StepID, nil
}

// ResetStepID resets all changes to the "step_id" field.
func (m *SignalMutation) ResetStepID() {
	m.step_id = nil
}

// SetStatus sets the "status" field.
func (m *SignalMutation) SetStatus(s signal.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SignalMutation) Status() (r signal.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Signal entity.
// If the Signal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalMutation) OldStatus(ctx context.Context) (v signal.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SignalMutation) ResetStatus() {
	m.status = nil
}

// SetQueueName sets the "queue_name" field.
func (m *SignalMutation) SetQueueName(s string) {
	m.queue_name = &s
}

// QueueName returns the value of the "queue_name" field in the mutation.
func (m *SignalMutation) QueueName() (r string, exists bool) {
	v := m.queue_name
	if v == nil {
		return
	}
	return *v, true
}

// OldQueueName returns the old "queue_name" field's value of the Signal entity.
// If the Signal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalMutation) OldQueueName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQueueName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQueueName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQueueName: %w", err)
	}
	return oldValue.QueueName, nil
}

// ResetQueueName resets all changes to the "queue_name" field.
func (m *SignalMutation) ResetQueueName() {
	m.queue_name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SignalMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SignalMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Signal entity.
// If the Signal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SignalMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetConsumed sets the "consumed" field.
func (m *SignalMutation) SetConsumed(b bool) {
	m.consumed = &b
}

// Consumed returns the value of the "consumed" field in the mutation.
func (m *SignalMutation) Consumed() (r bool, exists bool) {
	v := m.consumed
	if v == nil {
		return
	}
	return *v, true
}

// OldConsumed returns the old "consumed" field's value of the Signal entity.
// If the Signal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalMutation) OldConsumed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConsumed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConsumed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConsumed: %w", err)
	}
	return oldValue.Consumed, nil
}

// ResetConsumed resets all changes to the "consumed" field.
func (m *SignalMutation) ResetConsumed() {
	m.consumed = nil
}

// AddExecutionIDs adds the "executions" edge to the SignalExecution entity by ids.
func (m *SignalMutation) AddExecutionIDs(ids ...string) {
	if m.executions == nil {
		m.executions = make(map[string]struct{})
	}
	for i := range ids {
		m.executions[ids[i]] = struct{}{}
	}
}

// ClearExecutions clears the "executions" edge to the SignalExecution entity.
func (m *SignalMutation) ClearExecutions() {
	m.clearedexecutions = true
}

// ExecutionsCleared reports if the "executions" edge to the SignalExecution entity was cleared.
func (m *SignalMutation) ExecutionsCleared() bool {
	return m.clearedexecutions
}

// RemoveExecutionIDs removes the "executions" edge to the SignalExecution entity by IDs.
func (m *SignalMutation) RemoveExecutionIDs(ids ...string) {
	if m.removedexecutions == nil {
		m.removedexecutions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.executions, ids[i])
		m.removedexecutions[ids[i]] = struct{}{}
	}
}

// RemovedExecutions returns the removed IDs of the "executions" edge to the SignalExecution entity.
func (m *SignalMutation) RemovedExecutionsIDs() (ids []string) {
	for id := range m.removedexecutions {
		ids = append(ids, id)
	}
	return
}

// ExecutionsIDs returns the "executions" edge IDs in the mutation.
func (m *SignalMutation) ExecutionsIDs() (ids []string) {
	for id := range m.executions {
		ids = append(ids, id)
	}
	return
}

// ResetExecutions resets all changes to the "executions" edge.
func (m *SignalMutation) ResetExecutions() {
	m.executions = nil
	m.clearedexecutions = false
	m.removedexecutions = nil
}

// Where appends a list predicates to the SignalMutation builder.
func (m *SignalMutation) Where(ps ...predicate.Signal) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SignalMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SignalMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Signal, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SignalMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SignalMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Signal).
func (m *SignalMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SignalMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.step_id != nil {
		fields = append(fields, signal.FieldStepID)
	}
	if m.status != nil {
		fields = append(fields, signal.FieldStatus)
	}
	if m.queue_name != nil {
		fields = append(fields, signal.FieldQueueName)
	}
	if m.created_at != nil {
		fields = append(fields, signal.FieldCreatedAt)
	}
	if m.consumed != nil {
		fields = append(fields, signal.FieldConsumed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SignalMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case signal.FieldStepID:
		return m.StepID()
	case signal.FieldStatus:
		return m.Status()
	case signal.FieldQueueName:
		return m.QueueName()
	case signal.FieldCreatedAt:
		return m.CreatedAt()
	case signal.FieldConsumed:
		return m.Consumed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SignalMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case signal.FieldStepID:
		return m.OldStepID(ctx)
	case signal.FieldStatus:
		return m.OldStatus(ctx)
	case signal.FieldQueueName:
		return m.OldQueueName(ctx)
	case signal.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case signal.FieldConsumed:
		return m.OldConsumed(ctx)
	}
	return nil, fmt.Errorf("unknown Signal field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SignalMutation) SetField(name string, value ent.Value) error {
	switch name {
	case signal.FieldStepID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStepID(v)
		return nil
	case signal.FieldStatus:
		v, ok := value.(signal.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case signal.FieldQueueName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQueueName(v)
		return nil
	case signal.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case signal.FieldConsumed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConsumed(v)
		return nil
	}
	return fmt.Errorf("unknown Signal field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SignalMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SignalMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SignalMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Signal numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SignalMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SignalMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SignalMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Signal nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SignalMutation) ResetField(name string) error {
	switch name {
	case signal.FieldStepID:
		m.ResetStepID()
		return nil
	case signal.FieldStatus:
		m.ResetStatus()
		return nil
	case signal.FieldQueueName:
		m.ResetQueueName()
		return nil
	case signal.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case signal.FieldConsumed:
		m.ResetConsumed()
		return nil
	}
	return fmt.Errorf("unknown Signal field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SignalMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.executions != nil {
		edges = append(edges, signal.EdgeExecutions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SignalMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case signal.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.executions))
		for id := range m.executions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SignalMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedexecutions != nil {
		edges = append(edges, signal.EdgeExecutions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SignalMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case signal.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.removedexecutions))
		for id := range m.removedexecutions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SignalMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedexecutions {
		edges = append(edges, signal.EdgeExecutions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SignalMutation) EdgeCleared(name string) bool {
	switch name {
	case signal.EdgeExecutions:
		return m.clearedexecutions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SignalMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Signal unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SignalMutation) ResetEdge(name string) error {
	switch name {
	case signal.EdgeExecutions:
		m.ResetExecutions()
		return nil
	}
	return fmt.Errorf("unknown Signal edge %s", name)
}

// SignalExecutionMutation represents an operation that mutates the SignalExecution nodes in the graph.
type SignalExecutionMutation struct {
	config
	op            Op
	typ           string
	id            *string
	run_id        *string
	status        *signalexecution.Status
	queue_name    *string
	output        *[][]uint8
	appendoutput  [][]uint8
	error         *string
	started_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	signal        *string
	clearedsignal bool
	done          bool
	oldValue      func(context.Context) (*SignalExecution, error)
	predicates    []predicate.SignalExecution
}

var _ ent.Mutation = (*SignalExecutionMutation)(nil)

// signalexecutionOption allows management of the mutation configuration using functional options.
type signalexecutionOption func(*SignalExecutionMutation)

// newSignalExecutionMutation creates new mutation for the SignalExecution entity.
func newSignalExecutionMutation(c config, op Op, opts ...signalexecutionOption) *SignalExecutionMutation {
	m := &SignalExecutionMutation{
		config:        c,
		op:            op,
		typ:           TypeSignalExecution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSignalExecutionID sets the ID field of the mutation.
func withSignalExecutionID(id string) signalexecutionOption {
	return func(m *SignalExecutionMutation) {
		var (
			err   error
			once  sync.Once
			value *SignalExecution
		)
		m.oldValue = func(ctx context.Context) (*SignalExecution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SignalExecution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSignalExecution sets the old SignalExecution of the mutation.
func withSignalExecution(node *SignalExecution) signalexecutionOption {
	return func(m *SignalExecutionMutation) {
		m.oldValue = func(context.Context) (*SignalExecution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SignalExecutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SignalExecutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SignalExecution entities.
func (m *SignalExecutionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SignalExecutionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SignalExecutionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SignalExecution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRunID sets the "run_id" field.
func (m *SignalExecutionMutation) SetRunID(s string) {
	m.run_id = &s
}

// RunID returns the value of the "run_id" field in the mutation.
func (m *SignalExecutionMutation) RunID() (r string, exists bool) {
	v := m.run_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRunID returns the old "run_id" field's value of the SignalExecution entity.
// If the SignalExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalExecutionMutation) OldRunID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunID: %w", err)
	}
	return oldValue.RunID, nil
}

// ResetRunID resets all changes to the "run_id" field.
func (m *SignalExecutionMutation) ResetRunID() {
	m.run_id = nil
}

// SetStatus sets the "status" field.
func (m *SignalExecutionMutation) SetStatus(s signalexecution.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SignalExecutionMutation) Status() (r signalexecution.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SignalExecution entity.
// If the SignalExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalExecutionMutation) OldStatus(ctx context.Context) (v signalexecution.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SignalExecutionMutation) ResetStatus() {
	m.status = nil
}

// SetQueueName sets the "queue_name" field.
func (m *SignalExecutionMutation) SetQueueName(s string) {
	m.queue_name = &s
}

// QueueName returns the value of the "queue_name" field in the mutation.
func (m *SignalExecutionMutation) QueueName() (r string, exists bool) {
	v := m.queue_name
	if v == nil {
		return
	}
	return *v, true
}

// OldQueueName returns the old "queue_name" field's value of the SignalExecution entity.
// If the SignalExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalExecutionMutation) OldQueueName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQueueName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQueueName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQueueName: %w", err)
	}
	return oldValue.QueueName, nil
}

// ResetQueueName resets all changes to the "queue_name" field.
func (m *SignalExecutionMutation) ResetQueueName() {
	m.queue_name = nil
}

// SetOutput sets the "output" field.
func (m *SignalExecutionMutation) SetOutput(u [][]uint8) {
	m.output = &u
	m.appendoutput = nil
}

// Output returns the value of the "output" field in the mutation.
func (m *SignalExecutionMutation) Output() (r [][]uint8, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the SignalExecution entity.
// If the SignalExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalExecutionMutation) OldOutput(ctx context.Context) (v [][]uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// AppendOutput adds u to the "output" field.
func (m *SignalExecutionMutation) AppendOutput(u [][]uint8) {
	m.appendoutput = append(m.appendoutput, u...)
}

// AppendedOutput returns the list of values that were appended to the "output" field in this mutation.
func (m *SignalExecutionMutation) AppendedOutput() ([][]uint8, bool) {
	if len(m.appendoutput) == 0 {
		return nil, false
	}
	return m.appendoutput, true
}

// ClearOutput clears the value of the "output" field.
func (m *SignalExecutionMutation) ClearOutput() {
	m.output = nil
	m.appendoutput = nil
	m.clearedFields[signalexecution.FieldOutput] = struct{}{}
}

// OutputCleared returns if the "output" field was cleared in this mutation.
func (m *SignalExecutionMutation) OutputCleared() bool {
	_, ok := m.clearedFields[signalexecution.FieldOutput]
	return ok
}

// ResetOutput resets all changes to the "output" field.
func (m *SignalExecutionMutation) ResetOutput() {
	m.output = nil
	m.appendoutput = nil
	delete(m.clearedFields, signalexecution.FieldOutput)
}

// SetError sets the "error" field.
func (m *SignalExecutionMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *SignalExecutionMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the SignalExecution entity.
// If the SignalExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalExecutionMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *SignalExecutionMutation) ClearError() {
	m.error = nil
	m.clearedFields[signalexecution.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *SignalExecutionMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[signalexecution.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *SignalExecutionMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, signalexecution.FieldError)
}

// SetStartedAt sets the "started_at" field.
func (m *SignalExecutionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *SignalExecutionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the SignalExecution entity.
// If the SignalExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalExecutionMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *SignalExecutionMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SignalExecutionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SignalExecutionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SignalExecution entity.
// If the SignalExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalExecutionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SignalExecutionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSignalID sets the "signal" edge to the Signal entity by id.
func (m *SignalExecutionMutation) SetSignalID(id string) {
	m.signal = &id
}

// ClearSignal clears the "signal" edge to the Signal entity.
func (m *SignalExecutionMutation) ClearSignal() {
	m.clearedsignal = true
}

// SignalCleared reports if the "signal" edge to the Signal entity was cleared.
func (m *SignalExecutionMutation) SignalCleared() bool {
	return m.clearedsignal
}

// SignalID returns the "signal" edge ID in the mutation.
func (m *SignalExecutionMutation) SignalID() (id string, exists bool) {
	if m.signal != nil {
		return *m.signal, true
	}
	return
}

// SignalIDs returns the "signal" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SignalID instead. It exists only for internal usage by the builders.
func (m *SignalExecutionMutation) SignalIDs() (ids []string) {
	if id := m.signal; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSignal resets all changes to the "signal" edge.
func (m *SignalExecutionMutation) ResetSignal() {
	m.signal = nil
	m.clearedsignal = false
}

// Where appends a list predicates to the SignalExecutionMutation builder.
func (m *SignalExecutionMutation) Where(ps ...predicate.SignalExecution) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SignalExecutionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SignalExecutionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SignalExecution, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SignalExecutionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SignalExecutionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SignalExecution).
func (m *SignalExecutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SignalExecutionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.run_id != nil {
		fields = append(fields, signalexecution.FieldRunID)
	}
	if m.status != nil {
		fields = append(fields, signalexecution.FieldStatus)
	}
	if m.queue_name != nil {
		fields = append(fields, signalexecution.FieldQueueName)
	}
	if m.output != nil {
		fields = append(fields, signalexecution.FieldOutput)
	}
	if m.error != nil {
		fields = append(fields, signalexecution.FieldError)
	}
	if m.started_at != nil {
		fields = append(fields, signalexecution.FieldStartedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, signalexecution.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SignalExecutionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case signalexecution.FieldRunID:
		return m.RunID()
	case signalexecution.FieldStatus:
		return m.Status()
	case signalexecution.FieldQueueName:
		return m.QueueName()
	case signalexecution.FieldOutput:
		return m.Output()
	case signalexecution.FieldError:
		return m.Error()
	case signalexecution.FieldStartedAt:
		return m.StartedAt()
	case signalexecution.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SignalExecutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case signalexecution.FieldRunID:
		return m.OldRunID(ctx)
	case signalexecution.FieldStatus:
		return m.OldStatus(ctx)
	case signalexecution.FieldQueueName:
		return m.OldQueueName(ctx)
	case signalexecution.FieldOutput:
		return m.OldOutput(ctx)
	case signalexecution.FieldError:
		return m.OldError(ctx)
	case signalexecution.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case signalexecution.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SignalExecution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SignalExecutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case signalexecution.FieldRunID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunID(v)
		return nil
	case signalexecution.FieldStatus:
		v, ok := value.(signalexecution.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case signalexecution.FieldQueueName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQueueName(v)
		return nil
	case signalexecution.FieldOutput:
		v, ok := value.([][]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case signalexecution.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case signalexecution.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case signalexecution.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SignalExecution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SignalExecutionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SignalExecutionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SignalExecutionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SignalExecution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SignalExecutionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(signalexecution.FieldOutput) {
		fields = append(fields, signalexecution.FieldOutput)
	}
	if m.FieldCleared(signalexecution.FieldError) {
		fields = append(fields, signalexecution.FieldError)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SignalExecutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SignalExecutionMutation) ClearField(name string) error {
	switch name {
	case signalexecution.FieldOutput:
		m.ClearOutput()
		return nil
	case signalexecution.FieldError:
		m.ClearError()
		return nil
	}
	return fmt.Errorf("unknown SignalExecution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SignalExecutionMutation) ResetField(name string) error {
	switch name {
	case signalexecution.FieldRunID:
		m.ResetRunID()
		return nil
	case signalexecution.FieldStatus:
		m.ResetStatus()
		return nil
	case signalexecution.FieldQueueName:
		m.ResetQueueName()
		return nil
	case signalexecution.FieldOutput:
		m.ResetOutput()
		return nil
	case signalexecution.FieldError:
		m.ResetError()
		return nil
	case signalexecution.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case signalexecution.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SignalExecution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SignalExecutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.signal != nil {
		edges = append(edges, signalexecution.EdgeSignal)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SignalExecutionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case signalexecution.EdgeSignal:
		if id := m.signal; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SignalExecutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SignalExecutionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SignalExecutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsignal {
		edges = append(edges, signalexecution.EdgeSignal)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SignalExecutionMutation) EdgeCleared(name string) bool {
	switch name {
	case signalexecution.EdgeSignal:
		return m.clearedsignal
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SignalExecutionMutation) ClearEdge(name string) error {
	switch name {
	case signalexecution.EdgeSignal:
		m.ClearSignal()
		return nil
	}
	return fmt.Errorf("unknown SignalExecution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SignalExecutionMutation) ResetEdge(name string) error {
	switch name {
	case signalexecution.EdgeSignal:
		m.ResetSignal()
		return nil
	}
	return fmt.Errorf("unknown SignalExecution edge %s", name)
}

// WorkflowMutation represents an operation that mutates the Workflow nodes in the graph.
type WorkflowMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	step_id               *string
	status                *workflow.Status
	identity              *string
	handler_name          *string
	input                 *[][]uint8
	appendinput           [][]uint8
	queue_name            *string
	retry_policy          *schema.RetryPolicy
	is_paused             *bool
	is_ready              *bool
	timeout               *time.Time
	created_at            *time.Time
	clearedFields         map[string]struct{}
	executions            map[string]struct{}
	removedexecutions     map[string]struct{}
	clearedexecutions     bool
	continued_from        *string
	clearedcontinued_from bool
	continued_to          *string
	clearedcontinued_to   bool
	retried_from          *string
	clearedretried_from   bool
	retried_to            map[string]struct{}
	removedretried_to     map[string]struct{}
	clearedretried_to     bool
	done                  bool
	oldValue              func(context.Context) (*Workflow, error)
	predicates            []predicate.Workflow
}

var _ ent.Mutation = (*WorkflowMutation)(nil)

// workflowOption allows management of the mutation configuration using functional options.
type workflowOption func(*WorkflowMutation)

// newWorkflowMutation creates new mutation for the Workflow entity.
func newWorkflowMutation(c config, op Op, opts ...workflowOption) *WorkflowMutation {
	m := &WorkflowMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowID sets the ID field of the mutation.
func withWorkflowID(id string) workflowOption {
	return func(m *WorkflowMutation) {
		var (
			err   error
			once  sync.Once
			value *Workflow
		)
		m.oldValue = func(ctx context.Context) (*Workflow, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Workflow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflow sets the old Workflow of the mutation.
func withWorkflow(node *Workflow) workflowOption {
	return func(m *WorkflowMutation) {
		m.oldValue = func(context.Context) (*Workflow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Workflow entities.
func (m *WorkflowMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Workflow.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStepID sets the "step_id" field.
func (m *WorkflowMutation) SetStepID(s string) {
	m.step_id = &s
}

// StepID returns the value of the "step_id" field in the mutation.
func (m *WorkflowMutation) StepID() (r string, exists bool) {
	v := m.step_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStepID returns the old "step_id" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldStepID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStepID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStepID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStepID: %w", err)
	}
	return oldValue.StepID, nil
}

// ResetStepID resets all changes to the "step_id" field.
func (m *WorkflowMutation) ResetStepID() {
	m.step_id = nil
}

// SetStatus sets the "status" field.
func (m *WorkflowMutation) SetStatus(w workflow.Status) {
	m.status = &w
}

// Status returns the value of the "status" field in the mutation.
func (m *WorkflowMutation) Status() (r workflow.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldStatus(ctx context.Context) (v workflow.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *WorkflowMutation) ResetStatus() {
	m.status = nil
}

// SetIdentity sets the "identity" field.
func (m *WorkflowMutation) SetIdentity(s string) {
	m.identity = &s
}

// Identity returns the value of the "identity" field in the mutation.
func (m *WorkflowMutation) Identity() (r string, exists bool) {
	v := m.identity
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentity returns the old "identity" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldIdentity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentity: %w", err)
	}
	return oldValue.Identity, nil
}

// ResetIdentity resets all changes to the "identity" field.
func (m *WorkflowMutation) ResetIdentity() {
	m.identity = nil
}

// SetHandlerName sets the "handler_name" field.
func (m *WorkflowMutation) SetHandlerName(s string) {
	m.handler_name = &s
}

// HandlerName returns the value of the "handler_name" field in the mutation.
func (m *WorkflowMutation) HandlerName() (r string, exists bool) {
	v := m.handler_name
	if v == nil {
		return
	}
	return *v, true
}

// OldHandlerName returns the old "handler_name" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldHandlerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandlerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandlerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandlerName: %w", err)
	}
	return oldValue.HandlerName, nil
}

// ResetHandlerName resets all changes to the "handler_name" field.
func (m *WorkflowMutation) ResetHandlerName() {
	m.handler_name = nil
}

// SetInput sets the "input" field.
func (m *WorkflowMutation) SetInput(u [][]uint8) {
	m.input = &u
	m.appendinput = nil
}

// Input returns the value of the "input" field in the mutation.
func (m *WorkflowMutation) Input() (r [][]uint8, exists bool) {
	v := m.input
	if v == nil {
		return
	}
	return *v, true
}

// OldInput returns the old "input" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldInput(ctx context.Context) (v [][]uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInput: %w", err)
	}
	return oldValue.Input, nil
}

// AppendInput adds u to the "input" field.
func (m *WorkflowMutation) AppendInput(u [][]uint8) {
	m.appendinput = append(m.appendinput, u...)
}

// AppendedInput returns the list of values that were appended to the "input" field in this mutation.
func (m *WorkflowMutation) AppendedInput() ([][]uint8, bool) {
	if len(m.appendinput) == 0 {
		return nil, false
	}
	return m.appendinput, true
}

// ResetInput resets all changes to the "input" field.
func (m *WorkflowMutation) ResetInput() {
	m.input = nil
	m.appendinput = nil
}

// SetQueueName sets the "queue_name" field.
func (m *WorkflowMutation) SetQueueName(s string) {
	m.queue_name = &s
}

// QueueName returns the value of the "queue_name" field in the mutation.
func (m *WorkflowMutation) QueueName() (r string, exists bool) {
	v := m.queue_name
	if v == nil {
		return
	}
	return *v, true
}

// OldQueueName returns the old "queue_name" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldQueueName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQueueName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQueueName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQueueName: %w", err)
	}
	return oldValue.QueueName, nil
}

// ResetQueueName resets all changes to the "queue_name" field.
func (m *WorkflowMutation) ResetQueueName() {
	m.queue_name = nil
}

// SetRetryPolicy sets the "retry_policy" field.
func (m *WorkflowMutation) SetRetryPolicy(sp schema.RetryPolicy) {
	m.retry_policy = &sp
}

// RetryPolicy returns the value of the "retry_policy" field in the mutation.
func (m *WorkflowMutation) RetryPolicy() (r schema.RetryPolicy, exists bool) {
	v := m.retry_policy
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryPolicy returns the old "retry_policy" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldRetryPolicy(ctx context.Context) (v schema.RetryPolicy, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryPolicy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryPolicy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryPolicy: %w", err)
	}
	return oldValue.RetryPolicy, nil
}

// ClearRetryPolicy clears the value of the "retry_policy" field.
func (m *WorkflowMutation) ClearRetryPolicy() {
	m.retry_policy = nil
	m.clearedFields[workflow.FieldRetryPolicy] = struct{}{}
}

// RetryPolicyCleared returns if the "retry_policy" field was cleared in this mutation.
func (m *WorkflowMutation) RetryPolicyCleared() bool {
	_, ok := m.clearedFields[workflow.FieldRetryPolicy]
	return ok
}

// ResetRetryPolicy resets all changes to the "retry_policy" field.
func (m *WorkflowMutation) ResetRetryPolicy() {
	m.retry_policy = nil
	delete(m.clearedFields, workflow.FieldRetryPolicy)
}

// SetIsPaused sets the "is_paused" field.
func (m *WorkflowMutation) SetIsPaused(b bool) {
	m.is_paused = &b
}

// IsPaused returns the value of the "is_paused" field in the mutation.
func (m *WorkflowMutation) IsPaused() (r bool, exists bool) {
	v := m.is_paused
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPaused returns the old "is_paused" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldIsPaused(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPaused is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPaused requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPaused: %w", err)
	}
	return oldValue.IsPaused, nil
}

// ResetIsPaused resets all changes to the "is_paused" field.
func (m *WorkflowMutation) ResetIsPaused() {
	m.is_paused = nil
}

// SetIsReady sets the "is_ready" field.
func (m *WorkflowMutation) SetIsReady(b bool) {
	m.is_ready = &b
}

// IsReady returns the value of the "is_ready" field in the mutation.
func (m *WorkflowMutation) IsReady() (r bool, exists bool) {
	v := m.is_ready
	if v == nil {
		return
	}
	return *v, true
}

// OldIsReady returns the old "is_ready" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldIsReady(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsReady is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsReady requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsReady: %w", err)
	}
	return oldValue.IsReady, nil
}

// ResetIsReady resets all changes to the "is_ready" field.
func (m *WorkflowMutation) ResetIsReady() {
	m.is_ready = nil
}

// SetTimeout sets the "timeout" field.
func (m *WorkflowMutation) SetTimeout(t time.Time) {
	m.timeout = &t
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *WorkflowMutation) Timeout() (r time.Time, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldTimeout(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// ClearTimeout clears the value of the "timeout" field.
func (m *WorkflowMutation) ClearTimeout() {
	m.timeout = nil
	m.clearedFields[workflow.FieldTimeout] = struct{}{}
}

// TimeoutCleared returns if the "timeout" field was cleared in this mutation.
func (m *WorkflowMutation) TimeoutCleared() bool {
	_, ok := m.clearedFields[workflow.FieldTimeout]
	return ok
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *WorkflowMutation) ResetTimeout() {
	m.timeout = nil
	delete(m.clearedFields, workflow.FieldTimeout)
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkflowMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkflowMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkflowMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetContinuedFromID sets the "continued_from_id" field.
func (m *WorkflowMutation) SetContinuedFromID(s string) {
	m.continued_from = &s
}

// ContinuedFromID returns the value of the "continued_from_id" field in the mutation.
func (m *WorkflowMutation) ContinuedFromID() (r string, exists bool) {
	v := m.continued_from
	if v == nil {
		return
	}
	return *v, true
}

// OldContinuedFromID returns the old "continued_from_id" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldContinuedFromID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContinuedFromID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContinuedFromID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContinuedFromID: %w", err)
	}
	return oldValue.ContinuedFromID, nil
}

// ClearContinuedFromID clears the value of the "continued_from_id" field.
func (m *WorkflowMutation) ClearContinuedFromID() {
	m.continued_from = nil
	m.clearedFields[workflow.FieldContinuedFromID] = struct{}{}
}

// ContinuedFromIDCleared returns if the "continued_from_id" field was cleared in this mutation.
func (m *WorkflowMutation) ContinuedFromIDCleared() bool {
	_, ok := m.clearedFields[workflow.FieldContinuedFromID]
	return ok
}

// ResetContinuedFromID resets all changes to the "continued_from_id" field.
func (m *WorkflowMutation) ResetContinuedFromID() {
	m.continued_from = nil
	delete(m.clearedFields, workflow.FieldContinuedFromID)
}

// SetRetriedFromID sets the "retried_from_id" field.
func (m *WorkflowMutation) SetRetriedFromID(s string) {
	m.retried_from = &s
}

// RetriedFromID returns the value of the "retried_from_id" field in the mutation.
func (m *WorkflowMutation) RetriedFromID() (r string, exists bool) {
	v := m.retried_from
	if v == nil {
		return
	}
	return *v, true
}

// OldRetriedFromID returns the old "retried_from_id" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldRetriedFromID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetriedFromID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetriedFromID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetriedFromID: %w", err)
	}
	return oldValue.RetriedFromID, nil
}

// ClearRetriedFromID clears the value of the "retried_from_id" field.
func (m *WorkflowMutation) ClearRetriedFromID() {
	m.retried_from = nil
	m.clearedFields[workflow.FieldRetriedFromID] = struct{}{}
}

// RetriedFromIDCleared returns if the "retried_from_id" field was cleared in this mutation.
func (m *WorkflowMutation) RetriedFromIDCleared() bool {
	_, ok := m.clearedFields[workflow.FieldRetriedFromID]
	return ok
}

// ResetRetriedFromID resets all changes to the "retried_from_id" field.
func (m *WorkflowMutation) ResetRetriedFromID() {
	m.retried_from = nil
	delete(m.clearedFields, workflow.FieldRetriedFromID)
}

// AddExecutionIDs adds the "executions" edge to the WorkflowExecution entity by ids.
func (m *WorkflowMutation) AddExecutionIDs(ids ...string) {
	if m.executions == nil {
		m.executions = make(map[string]struct{})
	}
	for i := range ids {
		m.executions[ids[i]] = struct{}{}
	}
}

// ClearExecutions clears the "executions" edge to the WorkflowExecution entity.
func (m *WorkflowMutation) ClearExecutions() {
	m.clearedexecutions = true
}

// ExecutionsCleared reports if the "executions" edge to the WorkflowExecution entity was cleared.
func (m *WorkflowMutation) ExecutionsCleared() bool {
	return m.clearedexecutions
}

// RemoveExecutionIDs removes the "executions" edge to the WorkflowExecution entity by IDs.
func (m *WorkflowMutation) RemoveExecutionIDs(ids ...string) {
	if m.removedexecutions == nil {
		m.removedexecutions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.executions, ids[i])
		m.removedexecutions[ids[i]] = struct{}{}
	}
}

// RemovedExecutions returns the removed IDs of the "executions" edge to the WorkflowExecution entity.
func (m *WorkflowMutation) RemovedExecutionsIDs() (ids []string) {
	for id := range m.removedexecutions {
		ids = append(ids, id)
	}
	return
}

// ExecutionsIDs returns the "executions" edge IDs in the mutation.
func (m *WorkflowMutation) ExecutionsIDs() (ids []string) {
	for id := range m.executions {
		ids = append(ids, id)
	}
	return
}

// ResetExecutions resets all changes to the "executions" edge.
func (m *WorkflowMutation) ResetExecutions() {
	m.executions = nil
	m.clearedexecutions = false
	m.removedexecutions = nil
}

// ClearContinuedFrom clears the "continued_from" edge to the Workflow entity.
func (m *WorkflowMutation) ClearContinuedFrom() {
	m.clearedcontinued_from = true
	m.clearedFields[workflow.FieldContinuedFromID] = struct{}{}
}

// ContinuedFromCleared reports if the "continued_from" edge to the Workflow entity was cleared.
func (m *WorkflowMutation) ContinuedFromCleared() bool {
	return m.ContinuedFromIDCleared() || m.clearedcontinued_from
}

// ContinuedFromIDs returns the "continued_from" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContinuedFromID instead. It exists only for internal usage by the builders.
func (m *WorkflowMutation) ContinuedFromIDs() (ids []string) {
	if id := m.continued_from; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContinuedFrom resets all changes to the "continued_from" edge.
func (m *WorkflowMutation) ResetContinuedFrom() {
	m.continued_from = nil
	m.clearedcontinued_from = false
}

// SetContinuedToID sets the "continued_to" edge to the Workflow entity by id.
func (m *WorkflowMutation) SetContinuedToID(id string) {
	m.continued_to = &id
}

// ClearContinuedTo clears the "continued_to" edge to the Workflow entity.
func (m *WorkflowMutation) ClearContinuedTo() {
	m.clearedcontinued_to = true
}

// ContinuedToCleared reports if the "continued_to" edge to the Workflow entity was cleared.
func (m *WorkflowMutation) ContinuedToCleared() bool {
	return m.clearedcontinued_to
}

// ContinuedToID returns the "continued_to" edge ID in the mutation.
func (m *WorkflowMutation) ContinuedToID() (id string, exists bool) {
	if m.continued_to != nil {
		return *m.continued_to, true
	}
	return
}

// ContinuedToIDs returns the "continued_to" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContinuedToID instead. It exists only for internal usage by the builders.
func (m *WorkflowMutation) ContinuedToIDs() (ids []string) {
	if id := m.continued_to; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContinuedTo resets all changes to the "continued_to" edge.
func (m *WorkflowMutation) ResetContinuedTo() {
	m.continued_to = nil
	m.clearedcontinued_to = false
}

// ClearRetriedFrom clears the "retried_from" edge to the Workflow entity.
func (m *WorkflowMutation) ClearRetriedFrom() {
	m.clearedretried_from = true
	m.clearedFields[workflow.FieldRetriedFromID] = struct{}{}
}

// RetriedFromCleared reports if the "retried_from" edge to the Workflow entity was cleared.
func (m *WorkflowMutation) RetriedFromCleared() bool {
	return m.RetriedFromIDCleared() || m.clearedretried_from
}

// RetriedFromIDs returns the "retried_from" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RetriedFromID instead. It exists only for internal usage by the builders.
func (m *WorkflowMutation) RetriedFromIDs() (ids []string) {
	if id := m.retried_from; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRetriedFrom resets all changes to the "retried_from" edge.
func (m *WorkflowMutation) ResetRetriedFrom() {
	m.retried_from = nil
	m.clearedretried_from = false
}

// AddRetriedToIDs adds the "retried_to" edge to the Workflow entity by ids.
func (m *WorkflowMutation) AddRetriedToIDs(ids ...string) {
	if m.retried_to == nil {
		m.retried_to = make(map[string]struct{})
	}
	for i := range ids {
		m.retried_to[ids[i]] = struct{}{}
	}
}

// ClearRetriedTo clears the "retried_to" edge to the Workflow entity.
func (m *WorkflowMutation) ClearRetriedTo() {
	m.clearedretried_to = true
}

// RetriedToCleared reports if the "retried_to" edge to the Workflow entity was cleared.
func (m *WorkflowMutation) RetriedToCleared() bool {
	return m.clearedretried_to
}

// RemoveRetriedToIDs removes the "retried_to" edge to the Workflow entity by IDs.
func (m *WorkflowMutation) RemoveRetriedToIDs(ids ...string) {
	if m.removedretried_to == nil {
		m.removedretried_to = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.retried_to, ids[i])
		m.removedretried_to[ids[i]] = struct{}{}
	}
}

// RemovedRetriedTo returns the removed IDs of the "retried_to" edge to the Workflow entity.
func (m *WorkflowMutation) RemovedRetriedToIDs() (ids []string) {
	for id := range m.removedretried_to {
		ids = append(ids, id)
	}
	return
}

// RetriedToIDs returns the "retried_to" edge IDs in the mutation.
func (m *WorkflowMutation) RetriedToIDs() (ids []string) {
	for id := range m.retried_to {
		ids = append(ids, id)
	}
	return
}

// ResetRetriedTo resets all changes to the "retried_to" edge.
func (m *WorkflowMutation) ResetRetriedTo() {
	m.retried_to = nil
	m.clearedretried_to = false
	m.removedretried_to = nil
}

// Where appends a list predicates to the WorkflowMutation builder.
func (m *WorkflowMutation) Where(ps ...predicate.Workflow) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Workflow, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Workflow).
func (m *WorkflowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.step_id != nil {
		fields = append(fields, workflow.FieldStepID)
	}
	if m.status != nil {
		fields = append(fields, workflow.FieldStatus)
	}
	if m.identity != nil {
		fields = append(fields, workflow.FieldIdentity)
	}
	if m.handler_name != nil {
		fields = append(fields, workflow.FieldHandlerName)
	}
	if m.input != nil {
		fields = append(fields, workflow.FieldInput)
	}
	if m.queue_name != nil {
		fields = append(fields, workflow.FieldQueueName)
	}
	if m.retry_policy != nil {
		fields = append(fields, workflow.FieldRetryPolicy)
	}
	if m.is_paused != nil {
		fields = append(fields, workflow.FieldIsPaused)
	}
	if m.is_ready != nil {
		fields = append(fields, workflow.FieldIsReady)
	}
	if m.timeout != nil {
		fields = append(fields, workflow.FieldTimeout)
	}
	if m.created_at != nil {
		fields = append(fields, workflow.FieldCreatedAt)
	}
	if m.continued_from != nil {
		fields = append(fields, workflow.FieldContinuedFromID)
	}
	if m.retried_from != nil {
		fields = append(fields, workflow.FieldRetriedFromID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflow.FieldStepID:
		return m.StepID()
	case workflow.FieldStatus:
		return m.Status()
	case workflow.FieldIdentity:
		return m.Identity()
	case workflow.FieldHandlerName:
		return m.HandlerName()
	case workflow.FieldInput:
		return m.Input()
	case workflow.FieldQueueName:
		return m.QueueName()
	case workflow.FieldRetryPolicy:
		return m.RetryPolicy()
	case workflow.FieldIsPaused:
		return m.IsPaused()
	case workflow.FieldIsReady:
		return m.IsReady()
	case workflow.FieldTimeout:
		return m.Timeout()
	case workflow.FieldCreatedAt:
		return m.CreatedAt()
	case workflow.FieldContinuedFromID:
		return m.ContinuedFromID()
	case workflow.FieldRetriedFromID:
		return m.RetriedFromID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflow.FieldStepID:
		return m.OldStepID(ctx)
	case workflow.FieldStatus:
		return m.OldStatus(ctx)
	case workflow.FieldIdentity:
		return m.OldIdentity(ctx)
	case workflow.FieldHandlerName:
		return m.OldHandlerName(ctx)
	case workflow.FieldInput:
		return m.OldInput(ctx)
	case workflow.FieldQueueName:
		return m.OldQueueName(ctx)
	case workflow.FieldRetryPolicy:
		return m.OldRetryPolicy(ctx)
	case workflow.FieldIsPaused:
		return m.OldIsPaused(ctx)
	case workflow.FieldIsReady:
		return m.OldIsReady(ctx)
	case workflow.FieldTimeout:
		return m.OldTimeout(ctx)
	case workflow.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workflow.FieldContinuedFromID:
		return m.OldContinuedFromID(ctx)
	case workflow.FieldRetriedFromID:
		return m.OldRetriedFromID(ctx)
	}
	return nil, fmt.Errorf("unknown Workflow field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflow.FieldStepID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStepID(v)
		return nil
	case workflow.FieldStatus:
		v, ok := value.(workflow.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case workflow.FieldIdentity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentity(v)
		return nil
	case workflow.FieldHandlerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandlerName(v)
		return nil
	case workflow.FieldInput:
		v, ok := value.([][]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInput(v)
		return nil
	case workflow.FieldQueueName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQueueName(v)
		return nil
	case workflow.FieldRetryPolicy:
		v, ok := value.(schema.RetryPolicy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryPolicy(v)
		return nil
	case workflow.FieldIsPaused:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPaused(v)
		return nil
	case workflow.FieldIsReady:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsReady(v)
		return nil
	case workflow.FieldTimeout:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case workflow.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workflow.FieldContinuedFromID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContinuedFromID(v)
		return nil
	case workflow.FieldRetriedFromID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetriedFromID(v)
		return nil
	}
	return fmt.Errorf("unknown Workflow field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Workflow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflow.FieldRetryPolicy) {
		fields = append(fields, workflow.FieldRetryPolicy)
	}
	if m.FieldCleared(workflow.FieldTimeout) {
		fields = append(fields, workflow.FieldTimeout)
	}
	if m.FieldCleared(workflow.FieldContinuedFromID) {
		fields = append(fields, workflow.FieldContinuedFromID)
	}
	if m.FieldCleared(workflow.FieldRetriedFromID) {
		fields = append(fields, workflow.FieldRetriedFromID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowMutation) ClearField(name string) error {
	switch name {
	case workflow.FieldRetryPolicy:
		m.ClearRetryPolicy()
		return nil
	case workflow.FieldTimeout:
		m.ClearTimeout()
		return nil
	case workflow.FieldContinuedFromID:
		m.ClearContinuedFromID()
		return nil
	case workflow.FieldRetriedFromID:
		m.ClearRetriedFromID()
		return nil
	}
	return fmt.Errorf("unknown Workflow nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowMutation) ResetField(name string) error {
	switch name {
	case workflow.FieldStepID:
		m.ResetStepID()
		return nil
	case workflow.FieldStatus:
		m.ResetStatus()
		return nil
	case workflow.FieldIdentity:
		m.ResetIdentity()
		return nil
	case workflow.FieldHandlerName:
		m.ResetHandlerName()
		return nil
	case workflow.FieldInput:
		m.ResetInput()
		return nil
	case workflow.FieldQueueName:
		m.ResetQueueName()
		return nil
	case workflow.FieldRetryPolicy:
		m.ResetRetryPolicy()
		return nil
	case workflow.FieldIsPaused:
		m.ResetIsPaused()
		return nil
	case workflow.FieldIsReady:
		m.ResetIsReady()
		return nil
	case workflow.FieldTimeout:
		m.ResetTimeout()
		return nil
	case workflow.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workflow.FieldContinuedFromID:
		m.ResetContinuedFromID()
		return nil
	case workflow.FieldRetriedFromID:
		m.ResetRetriedFromID()
		return nil
	}
	return fmt.Errorf("unknown Workflow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.executions != nil {
		edges = append(edges, workflow.EdgeExecutions)
	}
	if m.continued_from != nil {
		edges = append(edges, workflow.EdgeContinuedFrom)
	}
	if m.continued_to != nil {
		edges = append(edges, workflow.EdgeContinuedTo)
	}
	if m.retried_from != nil {
		edges = append(edges, workflow.EdgeRetriedFrom)
	}
	if m.retried_to != nil {
		edges = append(edges, workflow.EdgeRetriedTo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workflow.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.executions))
		for id := range m.executions {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeContinuedFrom:
		if id := m.continued_from; id != nil {
			return []ent.Value{*id}
		}
	case workflow.EdgeContinuedTo:
		if id := m.continued_to; id != nil {
			return []ent.Value{*id}
		}
	case workflow.EdgeRetriedFrom:
		if id := m.retried_from; id != nil {
			return []ent.Value{*id}
		}
	case workflow.EdgeRetriedTo:
		ids := make([]ent.Value, 0, len(m.retried_to))
		for id := range m.retried_to {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedexecutions != nil {
		edges = append(edges, workflow.EdgeExecutions)
	}
	if m.removedretried_to != nil {
		edges = append(edges, workflow.EdgeRetriedTo)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workflow.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.removedexecutions))
		for id := range m.removedexecutions {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeRetriedTo:
		ids := make([]ent.Value, 0, len(m.removedretried_to))
		for id := range m.removedretried_to {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedexecutions {
		edges = append(edges, workflow.EdgeExecutions)
	}
	if m.clearedcontinued_from {
		edges = append(edges, workflow.EdgeContinuedFrom)
	}
	if m.clearedcontinued_to {
		edges = append(edges, workflow.EdgeContinuedTo)
	}
	if m.clearedretried_from {
		edges = append(edges, workflow.EdgeRetriedFrom)
	}
	if m.clearedretried_to {
		edges = append(edges, workflow.EdgeRetriedTo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowMutation) EdgeCleared(name string) bool {
	switch name {
	case workflow.EdgeExecutions:
		return m.clearedexecutions
	case workflow.EdgeContinuedFrom:
		return m.clearedcontinued_from
	case workflow.EdgeContinuedTo:
		return m.clearedcontinued_to
	case workflow.EdgeRetriedFrom:
		return m.clearedretried_from
	case workflow.EdgeRetriedTo:
		return m.clearedretried_to
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowMutation) ClearEdge(name string) error {
	switch name {
	case workflow.EdgeContinuedFrom:
		m.ClearContinuedFrom()
		return nil
	case workflow.EdgeContinuedTo:
		m.ClearContinuedTo()
		return nil
	case workflow.EdgeRetriedFrom:
		m.ClearRetriedFrom()
		return nil
	}
	return fmt.Errorf("unknown Workflow unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowMutation) ResetEdge(name string) error {
	switch name {
	case workflow.EdgeExecutions:
		m.ResetExecutions()
		return nil
	case workflow.EdgeContinuedFrom:
		m.ResetContinuedFrom()
		return nil
	case workflow.EdgeContinuedTo:
		m.ResetContinuedTo()
		return nil
	case workflow.EdgeRetriedFrom:
		m.ResetRetriedFrom()
		return nil
	case workflow.EdgeRetriedTo:
		m.ResetRetriedTo()
		return nil
	}
	return fmt.Errorf("unknown Workflow edge %s", name)
}

// WorkflowExecutionMutation represents an operation that mutates the WorkflowExecution nodes in the graph.
type WorkflowExecutionMutation struct {
	config
	op              Op
	typ             string
	id              *string
	run_id          *string
	status          *workflowexecution.Status
	queue_name      *string
	output          *[][]uint8
	appendoutput    [][]uint8
	error           *string
	is_replay       *bool
	started_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	workflow        *string
	clearedworkflow bool
	done            bool
	oldValue        func(context.Context) (*WorkflowExecution, error)
	predicates      []predicate.WorkflowExecution
}

var _ ent.Mutation = (*WorkflowExecutionMutation)(nil)

// workflowexecutionOption allows management of the mutation configuration using functional options.
type workflowexecutionOption func(*WorkflowExecutionMutation)

// newWorkflowExecutionMutation creates new mutation for the WorkflowExecution entity.
func newWorkflowExecutionMutation(c config, op Op, opts ...workflowexecutionOption) *WorkflowExecutionMutation {
	m := &WorkflowExecutionMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflowExecution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowExecutionID sets the ID field of the mutation.
func withWorkflowExecutionID(id string) workflowexecutionOption {
	return func(m *WorkflowExecutionMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkflowExecution
		)
		m.oldValue = func(ctx context.Context) (*WorkflowExecution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkflowExecution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflowExecution sets the old WorkflowExecution of the mutation.
func withWorkflowExecution(node *WorkflowExecution) workflowexecutionOption {
	return func(m *WorkflowExecutionMutation) {
		m.oldValue = func(context.Context) (*WorkflowExecution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowExecutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowExecutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkflowExecution entities.
func (m *WorkflowExecutionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowExecutionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowExecutionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkflowExecution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRunID sets the "run_id" field.
func (m *WorkflowExecutionMutation) SetRunID(s string) {
	m.run_id = &s
}

// RunID returns the value of the "run_id" field in the mutation.
func (m *WorkflowExecutionMutation) RunID() (r string, exists bool) {
	v := m.run_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRunID returns the old "run_id" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldRunID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunID: %w", err)
	}
	return oldValue.RunID, nil
}

// ResetRunID resets all changes to the "run_id" field.
func (m *WorkflowExecutionMutation) ResetRunID() {
	m.run_id = nil
}

// SetStatus sets the "status" field.
func (m *WorkflowExecutionMutation) SetStatus(w workflowexecution.Status) {
	m.status = &w
}

// Status returns the value of the "status" field in the mutation.
func (m *WorkflowExecutionMutation) Status() (r workflowexecution.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldStatus(ctx context.Context) (v workflowexecution.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *WorkflowExecutionMutation) ResetStatus() {
	m.status = nil
}

// SetQueueName sets the "queue_name" field.
func (m *WorkflowExecutionMutation) SetQueueName(s string) {
	m.queue_name = &s
}

// QueueName returns the value of the "queue_name" field in the mutation.
func (m *WorkflowExecutionMutation) QueueName() (r string, exists bool) {
	v := m.queue_name
	if v == nil {
		return
	}
	return *v, true
}

// OldQueueName returns the old "queue_name" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldQueueName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQueueName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQueueName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQueueName: %w", err)
	}
	return oldValue.QueueName, nil
}

// ResetQueueName resets all changes to the "queue_name" field.
func (m *WorkflowExecutionMutation) ResetQueueName() {
	m.queue_name = nil
}

// SetOutput sets the "output" field.
func (m *WorkflowExecutionMutation) SetOutput(u [][]uint8) {
	m.output = &u
	m.appendoutput = nil
}

// Output returns the value of the "output" field in the mutation.
func (m *WorkflowExecutionMutation) Output() (r [][]uint8, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldOutput(ctx context.Context) (v [][]uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// AppendOutput adds u to the "output" field.
func (m *WorkflowExecutionMutation) AppendOutput(u [][]uint8) {
	m.appendoutput = append(m.appendoutput, u...)
}

// AppendedOutput returns the list of values that were appended to the "output" field in this mutation.
func (m *WorkflowExecutionMutation) AppendedOutput() ([][]uint8, bool) {
	if len(m.appendoutput) == 0 {
		return nil, false
	}
	return m.appendoutput, true
}

// ClearOutput clears the value of the "output" field.
func (m *WorkflowExecutionMutation) ClearOutput() {
	m.output = nil
	m.appendoutput = nil
	m.clearedFields[workflowexecution.FieldOutput] = struct{}{}
}

// OutputCleared returns if the "output" field was cleared in this mutation.
func (m *WorkflowExecutionMutation) OutputCleared() bool {
	_, ok := m.clearedFields[workflowexecution.FieldOutput]
	return ok
}

// ResetOutput resets all changes to the "output" field.
func (m *WorkflowExecutionMutation) ResetOutput() {
	m.output = nil
	m.appendoutput = nil
	delete(m.clearedFields, workflowexecution.FieldOutput)
}

// SetError sets the "error" field.
func (m *WorkflowExecutionMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *WorkflowExecutionMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *WorkflowExecutionMutation) ClearError() {
	m.error = nil
	m.clearedFields[workflowexecution.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *WorkflowExecutionMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[workflowexecution.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *WorkflowExecutionMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, workflowexecution.FieldError)
}

// SetIsReplay sets the "is_replay" field.
func (m *WorkflowExecutionMutation) SetIsReplay(b bool) {
	m.is_replay = &b
}

// IsReplay returns the value of the "is_replay" field in the mutation.
func (m *WorkflowExecutionMutation) IsReplay() (r bool, exists bool) {
	v := m.is_replay
	if v == nil {
		return
	}
	return *v, true
}

// OldIsReplay returns the old "is_replay" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldIsReplay(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsReplay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsReplay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsReplay: %w", err)
	}
	return oldValue.IsReplay, nil
}

// ResetIsReplay resets all changes to the "is_replay" field.
func (m *WorkflowExecutionMutation) ResetIsReplay() {
	m.is_replay = nil
}

// SetStartedAt sets the "started_at" field.
func (m *WorkflowExecutionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *WorkflowExecutionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *WorkflowExecutionMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkflowExecutionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkflowExecutionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkflowExecutionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetWorkflowID sets the "workflow" edge to the Workflow entity by id.
func (m *WorkflowExecutionMutation) SetWorkflowID(id string) {
	m.workflow = &id
}

// ClearWorkflow clears the "workflow" edge to the Workflow entity.
func (m *WorkflowExecutionMutation) ClearWorkflow() {
	m.clearedworkflow = true
}

// WorkflowCleared reports if the "workflow" edge to the Workflow entity was cleared.
func (m *WorkflowExecutionMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowID returns the "workflow" edge ID in the mutation.
func (m *WorkflowExecutionMutation) WorkflowID() (id string, exists bool) {
	if m.workflow != nil {
		return *m.workflow, true
	}
	return
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *WorkflowExecutionMutation) WorkflowIDs() (ids []string) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *WorkflowExecutionMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// Where appends a list predicates to the WorkflowExecutionMutation builder.
func (m *WorkflowExecutionMutation) Where(ps ...predicate.WorkflowExecution) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowExecutionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowExecutionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkflowExecution, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowExecutionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowExecutionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkflowExecution).
func (m *WorkflowExecutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowExecutionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.run_id != nil {
		fields = append(fields, workflowexecution.FieldRunID)
	}
	if m.status != nil {
		fields = append(fields, workflowexecution.FieldStatus)
	}
	if m.queue_name != nil {
		fields = append(fields, workflowexecution.FieldQueueName)
	}
	if m.output != nil {
		fields = append(fields, workflowexecution.FieldOutput)
	}
	if m.error != nil {
		fields = append(fields, workflowexecution.FieldError)
	}
	if m.is_replay != nil {
		fields = append(fields, workflowexecution.FieldIsReplay)
	}
	if m.started_at != nil {
		fields = append(fields, workflowexecution.FieldStartedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workflowexecution.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowExecutionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflowexecution.FieldRunID:
		return m.RunID()
	case workflowexecution.FieldStatus:
		return m.Status()
	case workflowexecution.FieldQueueName:
		return m.QueueName()
	case workflowexecution.FieldOutput:
		return m.Output()
	case workflowexecution.FieldError:
		return m.Error()
	case workflowexecution.FieldIsReplay:
		return m.IsReplay()
	case workflowexecution.FieldStartedAt:
		return m.StartedAt()
	case workflowexecution.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowExecutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflowexecution.FieldRunID:
		return m.OldRunID(ctx)
	case workflowexecution.FieldStatus:
		return m.OldStatus(ctx)
	case workflowexecution.FieldQueueName:
		return m.OldQueueName(ctx)
	case workflowexecution.FieldOutput:
		return m.OldOutput(ctx)
	case workflowexecution.FieldError:
		return m.OldError(ctx)
	case workflowexecution.FieldIsReplay:
		return m.OldIsReplay(ctx)
	case workflowexecution.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case workflowexecution.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown WorkflowExecution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowExecutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflowexecution.FieldRunID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunID(v)
		return nil
	case workflowexecution.FieldStatus:
		v, ok := value.(workflowexecution.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case workflowexecution.FieldQueueName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQueueName(v)
		return nil
	case workflowexecution.FieldOutput:
		v, ok := value.([][]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case workflowexecution.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case workflowexecution.FieldIsReplay:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsReplay(v)
		return nil
	case workflowexecution.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case workflowexecution.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowExecutionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowExecutionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowExecutionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkflowExecution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowExecutionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflowexecution.FieldOutput) {
		fields = append(fields, workflowexecution.FieldOutput)
	}
	if m.FieldCleared(workflowexecution.FieldError) {
		fields = append(fields, workflowexecution.FieldError)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowExecutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowExecutionMutation) ClearField(name string) error {
	switch name {
	case workflowexecution.FieldOutput:
		m.ClearOutput()
		return nil
	case workflowexecution.FieldError:
		m.ClearError()
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowExecutionMutation) ResetField(name string) error {
	switch name {
	case workflowexecution.FieldRunID:
		m.ResetRunID()
		return nil
	case workflowexecution.FieldStatus:
		m.ResetStatus()
		return nil
	case workflowexecution.FieldQueueName:
		m.ResetQueueName()
		return nil
	case workflowexecution.FieldOutput:
		m.ResetOutput()
		return nil
	case workflowexecution.FieldError:
		m.ResetError()
		return nil
	case workflowexecution.FieldIsReplay:
		m.ResetIsReplay()
		return nil
	case workflowexecution.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case workflowexecution.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowExecutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.workflow != nil {
		edges = append(edges, workflowexecution.EdgeWorkflow)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowExecutionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workflowexecution.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowExecutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowExecutionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowExecutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedworkflow {
		edges = append(edges, workflowexecution.EdgeWorkflow)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowExecutionMutation) EdgeCleared(name string) bool {
	switch name {
	case workflowexecution.EdgeWorkflow:
		return m.clearedworkflow
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowExecutionMutation) ClearEdge(name string) error {
	switch name {
	case workflowexecution.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowExecutionMutation) ResetEdge(name string) error {
	switch name {
	case workflowexecution.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecution edge %s", name)
}
